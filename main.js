/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to2;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MostUsedWordsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/@kurkle/color/dist/color.esm.js
function round(v) {
  return v + 0.5 | 0;
}
var lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = [..."0123456789ABCDEF"];
var h1 = (b) => hex[b & 15];
var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
var eq = (b) => (b & 240) >> 4 === (b & 15);
var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a, f) => a < 255 ? f(a) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
}
var map = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t) {
    if (color2) {
      this._rgb = interpolate(this._rgb, color2._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};

// node_modules/chart.js/dist/chunks/helpers.segment.js
function noop() {
}
var uid = (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone2(source) {
  if (isArray(source)) {
    return source.map(clone2);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone2(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone2(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i = 0; i < ilen; ++i) {
    current = sources[i];
    if (!isObject(current)) {
      continue;
    }
    const keys = Object.keys(current);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone2(sval);
  }
}
var keyResolvers = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (v) => v,
  // default resolvers
  x: (o) => o.x,
  y: (o) => o.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k of keys) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index2) => table[index2] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
  const ti = table[index2][key];
  return ti < value || ti === value && table[index2 + 1][key] === value;
} : (index2) => table[index2][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set(items);
  if (set2.size === items.length) {
    return items;
  }
  return Array.from(set2);
}
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, axis, min).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
      ), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
      ), start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return {
    start,
    count
  };
}
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
var atEdge = (t) => t === 0 || t === 1;
var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
var effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: (t) => Math.sin(t * HALF_PI),
  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}
var numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
var colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults2) {
  defaults2.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults2.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults2.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults2.describe("animations", {
    _fallback: "animation"
  });
  defaults2.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults2) {
  defaults2.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index2 > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index2, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults2) {
  defaults2.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults2.route("scale.ticks", "color", "", "color");
  defaults2.route("scale.grid", "color", "", "borderColor");
  defaults2.route("scale.border", "color", "", "borderColor");
  defaults2.route("scale.title", "color", "", "color");
  defaults2.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
  });
  defaults2.describe("scales", {
    _fallback: "scale"
  });
  defaults2.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
};
var defaults = /* @__PURE__ */ new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && !isArray(thing)) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}
function drawPointLegend(ctx, options, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width = w ? w / 2 : radius;
      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w ? w / 2 : size;
        ctx.rect(x - width, y - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "line":
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
      break;
    case false:
      ctx.closePath();
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [
    text
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += Number(font.lineHeight);
  }
  ctx.restore();
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index2, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index2 !== void 0 && isArray(value)) {
      value = value[index2 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [
  ""
], rootScopes, fallback, getTarget = () => scopes[0]) {
  const finalRootScopes = rootScopes || scopes;
  if (typeof fallback === "undefined") {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: finalRootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes, finalRootScopes, fallback)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  let value = getValue(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (typeof _context.index !== "undefined" && isIndexable(prop)) {
    return value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (typeof fallback !== "undefined" && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (typeof value !== "undefined") {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (typeof value !== "undefined") {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
  const { iScale } = meta;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i, ilen, index2, item;
  for (i = 0, ilen = count; i < ilen; ++i) {
    index2 = i + start;
    item = data[index2];
    parsed[i] = {
      r: iScale.parse(resolveObjectKey(item, key), index2)
    };
  }
  return parsed;
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
var positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {
    x,
    y,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    if (_isDomSupported()) {
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    }
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p2.cp1x,
    y: p2.cp1y
  };
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start, end, loop } = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return {
    start,
    end,
    loop,
    style: segment.style
  };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [
      segment
    ];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({
        start: subStart,
        end: i,
        loop,
        count,
        style
      }));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({
      start: subStart,
      end,
      loop,
      count,
      style
    }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {
    start,
    end
  };
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({
          start: start % count,
          end: (end - 1) % count,
          loop
        });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({
      start: start % count,
      end: last % count,
      loop
    });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [
      {
        start,
        end,
        loop
      }
    ], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({
        start: s % count,
        end: e % count,
        loop: l,
        style: st
      });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  if (!prevStyle) {
    return false;
  }
  const cache = [];
  const replacer = function(key, value) {
    if (!isPatternOrGradient(value)) {
      return value;
    }
    if (!cache.includes(value)) {
      cache.push(value);
    }
    return cache.indexOf(value);
  };
  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}

// node_modules/chart.js/dist/chart.js
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw2 = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = /* @__PURE__ */ new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([
      cfg.to,
      to2,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to2
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
};
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index2) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index2,
    index: index2,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index2, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index2;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements2[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index2, active) {
    const mode = active ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index2];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index2, active, mode);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index2, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index2, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index2, mode, active) {
    element.active = active;
    const options = this.getStyle(index2, active);
    this._resolveAnimations(index2, mode, active).update(element, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", false);
  }
  setHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
};
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index2, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index2] - size / 2
  };
}
function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return {
    start,
    end,
    reverse,
    top,
    bottom
  };
}
function setBorderSkipped(properties, options, stack, index2) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index2) {
      edge = top;
    } else if ((stack._bottom || 0) === index2) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index2);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const skipNull = (meta) => {
      const parsed = meta.controller.getParsed(dataIndex);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
      }
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
};
__publicField(BarController, "id", "bar");
__publicField(BarController, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
});
__publicField(BarController, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
var BubbleController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
  }
  resolveDataElementOptions(index2, mode) {
    const parsed = this.getParsed(index2);
    let values = super.resolveDataElementOptions(index2, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {
        $shared: false
      });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
};
__publicField(BubbleController, "id", "bubble");
__publicField(BubbleController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
});
__publicField(BubbleController, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2], chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(DoughnutController, "descriptors", {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
});
__publicField(DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
var LineController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    const end = start + count;
    const pointsCount = points.length;
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = 0; i < pointsCount; ++i) {
      const point = points[i];
      const properties = directUpdate ? point : {};
      if (i < start || i >= end) {
        properties.skip = true;
        continue;
      }
      const parsed = this.getParsed(i);
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
};
__publicField(LineController, "id", "line");
__publicField(LineController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
});
__publicField(LineController, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
var PolarAreaController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    meta.data.forEach((element, index2) => {
      const parsed = this.getParsed(index2).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
        if (parsed < range.min) {
          range.min = parsed;
        }
        if (parsed > range.max) {
          range.max = parsed;
        }
      }
    });
    return range;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index2) => {
      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index2, mode, defaultAngle) {
    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
  }
};
__publicField(PolarAreaController, "id", "polarArea");
__publicField(PolarAreaController, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
});
__publicField(PolarAreaController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
});
var PieController = class extends DoughnutController {
};
__publicField(PieController, "id", "pie");
__publicField(PieController, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
var RadarController = class extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
};
__publicField(RadarController, "id", "radar");
__publicField(RadarController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
});
__publicField(RadarController, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
var ScatterController = class extends DatasetController {
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + ")"
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { data: points = [] } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      if (!this.datasetElementType) {
        this.addElements();
      }
      const { dataset: line, _dataset } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
    } else if (this.datasetElementType) {
      delete meta.dataset;
      this.datasetElementType = false;
    }
    this.updateElements(points, start, count, mode);
  }
  addElements() {
    const { showLine } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = this.chart.registry.getElement("line");
    }
    super.addElements();
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];
    if (!this.options.showLine) {
      let max = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max > 0 && max;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
};
__publicField(ScatterController, "id", "scatter");
__publicField(ScatterController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  showLine: false,
  fill: false
});
__publicField(ScatterController, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PieController,
  PolarAreaController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapterBase = class {
  constructor(options) {
    __publicField(this, "options");
    this.options = options || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(DateAdapterBase.prototype, members);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
};
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index: index2, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index2, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index2) {
    const { startAngle, endAngle } = element.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index2) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element,
          datasetIndex,
          index: index2
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index2 = items[0].index;
        const element = meta.data[index2];
        if (element && !element.skip) {
          elements2.push({
            element,
            datasetIndex: meta.index,
            index: index2
          });
        }
      });
      return elements2;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({
            element: data[i],
            datasetIndex,
            index: i
          });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  if (node) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
}
function removeListener(chart, type, listener) {
  if (chart && chart.canvas) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element = class {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "active", false);
    __publicField(this, "options");
    __publicField(this, "$animations");
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
__publicField(Element, "defaults", {});
__publicField(Element, "defaultRoutes");
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index2, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index2 === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index2, tick) {
  return createContext(parent, {
    tick,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
var Scale = class extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length, maxTicksLimit) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; i += increment) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index2) {
    const ticks = this.ticks || [];
    if (index2 >= 0 && index2 < ticks.length) {
      const tick = ticks[index2];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const context = this.getContext(i);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
          case "inner":
            if (i === ilen - 1) {
              left -= width;
            } else if (i > 0) {
              left -= width / 2;
            }
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x,
            y
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index2 = ticks.findIndex((t) => t.value === value);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = /* @__PURE__ */ new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const localIds = {};
  const plugins2 = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins2.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins2.indexOf(plugin) === -1) {
      plugins2.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins: plugins2,
    localIds
  };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins2) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, ...scaleOptions) {
  if (idMatchesAxis(id)) {
    return id;
  }
  for (const opts of scaleOptions) {
    const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
    if (axis) {
      return axis;
    }
  }
  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
  if (dataset[axis + "AxisID"] === id) {
    return {
      axis
    };
  }
}
function retrieveAxisFromDatasets(id, config) {
  if (config.data && config.data.datasets) {
    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);
    if (boundDs.length) {
      return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
    }
  }
  return {};
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales2 = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales2[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [
      defaults.scales[scale.type],
      defaults.scale
    ]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {
        type
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.4.2";
var KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
function getSizeForArea(scale, chartArea, field) {
  return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: getSizeForArea(xScale, chartArea, "left"),
      right: getSizeForArea(xScale, chartArea, "right"),
      top: getSizeForArea(yScale, chartArea, "top"),
      bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
  }
  return chartArea;
}
var Chart = class {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index2) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({
        datasetIndex: i
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index2, mode) {
    const meta = this.getDatasetMeta(index2);
    const args = {
      meta,
      index: index2,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta, this.chartArea);
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e,
        active,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
__publicField(Chart, "defaults", defaults);
__publicField(Chart, "instances", instances);
__publicField(Chart, "overrides", overrides);
__publicField(Chart, "registry", registry);
__publicField(Chart, "version", version);
__publicField(Chart, "getChart", getChart);
function invalidatePlugins() {
  return each(Chart.instances, (chart) => chart._plugins.invalidate());
}
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset, spacing, end, circular) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element;
  const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  ctx.setLineDash(borderDash || []);
  ctx.lineDashOffset = borderDashOffset;
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
}
var ArcElement = class extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "circumference");
    __publicField(this, "endAngle");
    __publicField(this, "fullCircles");
    __publicField(this, "innerRadius");
    __publicField(this, "outerRadius");
    __publicField(this, "pixelMargin");
    __publicField(this, "startAngle");
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
};
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
});
__publicField(ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
__publicField(ArcElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash"
});
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {
      start,
      end: start + count - 1
    })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
var LineElement = class extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, {
      property,
      start: value,
      end: value
    });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const { start, end } = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, {
        start,
        end: start + count - 1
      });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
__publicField(LineElement, "id", "line");
__publicField(LineElement, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
});
__publicField(LineElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
__publicField(LineElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
});
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([
    axis
  ], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
var PointElement = class extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "parsed");
    __publicField(this, "skip");
    __publicField(this, "stop");
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
};
__publicField(PointElement, "id", "point");
/**
* @type {any}
*/
__publicField(PointElement, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
});
/**
* @type {any}
*/
__publicField(PointElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return {
    left,
    top,
    right,
    bottom
  };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
var BarElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
__publicField(BarElement, "id", "bar");
__publicField(BarElement, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
});
__publicField(BarElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  BarElement,
  LineElement,
  PointElement
});
var BORDER_COLORS = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
];
var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function getBorderColor(i) {
  return BORDER_COLORS[i % BORDER_COLORS.length];
}
function getBackgroundColor(i) {
  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i) {
  dataset.borderColor = getBorderColor(i);
  dataset.backgroundColor = getBackgroundColor(i);
  return ++i;
}
function colorizeDoughnutDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
  return i;
}
function colorizePolarAreaDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));
  return i;
}
function getColorizer(chart) {
  let i = 0;
  return (dataset, datasetIndex) => {
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    if (controller instanceof DoughnutController) {
      i = colorizeDoughnutDataset(dataset, i);
    } else if (controller instanceof PolarAreaController) {
      i = colorizePolarAreaDataset(dataset, i);
    } else if (controller) {
      i = colorizeDefaultDataset(dataset, i);
    }
  };
}
function containsColorsDefinitions(descriptors2) {
  let k;
  for (k in descriptors2) {
    if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {
      return true;
    }
  }
  return false;
}
function containsColorsDefinition(descriptor) {
  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
var plugin_colors = {
  id: "colors",
  defaults: {
    enabled: true,
    forceOverride: false
  },
  beforeLayout(chart, _args, options) {
    if (!options.enabled) {
      return;
    }
    const { data: { datasets }, options: chartOptions } = chart.config;
    const { elements: elements2 } = chartOptions;
    if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2))) {
      return;
    }
    const colorizer = getColorizer(chart);
    datasets.forEach(colorizer);
  }
};
function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const { x: pointAx, y: pointAy } = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: data
    });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const { iScale } = meta;
  const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return {
    start,
    count
  };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([
        indexAxis,
        chart.options.indexAxis
      ]) === "y") {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = _findSegmentEnd(start, end, points);
    const bounds = _getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return {
    property,
    start,
    end
  };
}
function _pointsFromSegments(boundary, line) {
  const { x = null, y = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({
        x: first.x,
        y
      });
      points.push({
        x: last.x,
        y
      });
    } else if (x !== null) {
      points.push({
        x,
        y: first.y
      });
      points.push({
        x,
        y: last.y
      });
    }
  });
  return points;
}
function _findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {
      tension: 0
    },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index2, propagate) {
  const source = sources[index2];
  let fill2 = source.fill;
  const visited = [
    index2
  ];
  let target;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target = sources[fill2];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target.fill;
  }
  return false;
}
function _decodeFill(line, index2, count) {
  const fill2 = parseFillOption(line);
  if (isObject(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target = parseFloat(fill2);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill2[0], index2, target, count);
  }
  return [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index2, target, count) {
  if (firstCh === "-" || firstCh === "+") {
    target = index2 + target;
  }
  if (target === index2 || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill2, scale) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale.bottom;
  } else if (fill2 === "end") {
    pixel = scale.top;
  } else if (isObject(fill2)) {
    pixel = scale.getPixelForValue(fill2.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale, startValue) {
  let value;
  if (fill2 === "start") {
    value = startValue;
  } else if (fill2 === "end") {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject(fill2)) {
    value = fill2.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source) {
  const { scale, index: index2, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index2);
  linesBelow.push(_createBoundaryLine({
    x: null,
    y: scale.bottom
  }, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({
    points,
    options: {}
  });
}
function getLinesBelow(scale, index2) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index2) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {
    first,
    last,
    point
  };
}
var simpleArc = class {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x, y, radius } = this;
    bounds = bounds || {
      start: 0,
      end: TAU
    };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x, y, radius } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
};
function _getTarget(source) {
  const { chart, fill: fill2, line } = source;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index2) {
  const meta = chart.getDatasetMeta(index2);
  const visible = meta && chart.isDatasetVisible(index2);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const { scale = {}, fill: fill2 } = source;
  const pixel = _getTargetPixel(fill2, scale);
  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const { scale, fill: fill2 } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start = options.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill2, scale, start);
  const target = [];
  if (options.grid.circular) {
    const center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}
function _drawfill(ctx, source, area) {
  const target = _getTarget(source);
  const { line, scale, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, {
      line,
      target,
      above,
      below,
      area,
      scale,
      axis
    });
    unclipArea(ctx);
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property === "x" && below !== above) {
    clipVertical(ctx, target, area.top);
    fill(ctx, {
      line,
      target,
      color: above,
      scale,
      property
    });
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target, area.bottom);
  }
  fill(ctx, {
    line,
    target,
    color: below,
    scale,
    property
  });
  ctx.restore();
}
function clipVertical(ctx, target, clipY) {
  const { segments, points } = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const { start, end } = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, {
      move: lineLoop
    });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function fill(ctx, cfg) {
  const { line, target, property, color: color2, scale } = cfg;
  const segments = _segments(line, target, property);
  for (const { source: src, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, {
        move: lineLoop,
        reverse: true
      });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function clipBounds(ctx, scale, bounds) {
  const { top, bottom } = scale.chart.chartArea;
  const { property, start, end } = bounds || {};
  if (property === "x") {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: _decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2 && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
var Legend = class extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e,
        hoveredItem,
        this
      ], this);
    }
  }
};
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name)
    }
  }
};
var Title = class extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map2 = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map2.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map2.get(chart));
    map2.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map2.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let xSet = /* @__PURE__ */ new Set();
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        xSet.add(pos.x);
        y += pos.y;
        ++count;
      }
    }
    const xAverage = [
      ...xSet
    ].reduce((a, b) => a + b) / xSet.size;
    return {
      x: xAverage,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result = callbacks[name].call(ctx, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name].call(ctx, arg);
  }
  return result;
}
var Tooltip = class extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColor = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColor.borderColor;
      ctx.fillStyle = labelColor.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
      ctx.strokeStyle = labelColor.borderColor;
      ctx.setLineDash(labelColor.borderDash || []);
      ctx.lineDashOffset = labelColor.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = toTRBLCorners(labelColor.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: plugin_colors,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
var addIfString = (labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({
      index: index2,
      label: raw
    });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
var validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
    if (maxDefined && tickValue > max) {
      break;
    }
    ticks.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
var log10Floor = (v) => Math.floor(log10(v));
var changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start;
}
function startExp(min, max) {
  const range = max - min;
  let rangeExp = log10Floor(range);
  while (steps(min, max, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max }) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base) * precision) / precision;
  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index2
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max, -1));
    }
    if (max <= 0) {
      setMax(changeExponent(min, 1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function createPointLabelItem(scale, index2, itemOpts) {
  const outerDistance = scale.drawingArea;
  const { extra, additionalAngle, padding, size } = itemOpts;
  const pointLabelPosition = scale.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
  const y = yForAngle(pointLabelPosition.y, size.h, angle);
  const textAlign = getTextAlignForAngle(angle);
  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
  return {
    visible: true,
    x: pointLabelPosition.x,
    y,
    textAlign,
    left,
    top: y,
    right: left + size.w,
    bottom: y + size.h
  };
}
function isNotOverlapped(item, area) {
  if (!area) {
    return true;
  }
  const { left, top, right, bottom } = item;
  const apexesInArea = _isPointInArea({
    x: left,
    y: top
  }, area) || _isPointInArea({
    x: left,
    y: bottom
  }, area) || _isPointInArea({
    x: right,
    y: top
  }, area) || _isPointInArea({
    x: right,
    y: bottom
  }, area);
  return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const { centerPointLabels, display } = opts.pointLabels;
  const itemOpts = {
    extra: getTickBackdropHeight(opts) / 2,
    additionalAngle: centerPointLabels ? PI / valueCount : 0
  };
  let area;
  for (let i = 0; i < valueCount; i++) {
    itemOpts.padding = padding[i];
    itemOpts.size = labelSizes[i];
    const item = createPointLabelItem(scale, i, itemOpts);
    items.push(item);
    if (display === "auto") {
      item.visible = isNotOverlapped(item, area);
      if (item.visible) {
        area = item;
      }
    }
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabelBox(ctx, opts, item) {
  const { left, top, right, bottom } = item;
  const { backdropColor } = opts;
  if (!isNullOrUndef(backdropColor)) {
    const borderRadius = toTRBLCorners(opts.borderRadius);
    const padding = toPadding(opts.backdropPadding);
    ctx.fillStyle = backdropColor;
    const backdropLeft = left - padding.left;
    const backdropTop = top - padding.top;
    const backdropWidth = right - left + padding.width;
    const backdropHeight = bottom - top + padding.height;
    if (Object.values(borderRadius).some((v) => v !== 0)) {
      ctx.beginPath();
      addRoundedRectPath(ctx, {
        x: backdropLeft,
        y: backdropTop,
        w: backdropWidth,
        h: backdropHeight,
        radius: borderRadius
      });
      ctx.fill();
    } else {
      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
  }
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const item = scale._pointLabelItems[i];
    if (!item.visible) {
      continue;
    }
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    drawPointLabelBox(ctx, optsAtIndex, item);
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign } = item;
    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index2, label) {
  return createContext(parent, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index2) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index2
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left, top, right, bottom } = this._pointLabelItems[index2];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index2) => {
        if (index2 !== 0 || index2 === 0 && this.min < 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index2);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index2) => {
      if (index2 === 0 && this.min >= 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color,
        strokeColor: optsAtIndex.textStrokeColor,
        strokeWidth: optsAtIndex.textStrokeWidth
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
var INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map3[major];
    if (index2 >= 0) {
      ticks[index2].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map3[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {
      min,
      max
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort(sorter).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const fmt = format || formats[unit];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time, index2, ticks, format) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index2,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index2];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate2(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate2(table, this.min);
    this._tableRange = interpolate2(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max,
          pos: 1
        }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }
    return table;
  }
  _generate() {
    const min = this.min;
    const max = this.max;
    let timestamps = super.getDataTimestamps();
    if (!timestamps.includes(min) || !timestamps.length) {
      timestamps.splice(0, 0, min);
    }
    if (!timestamps.includes(max) || timestamps.length === 1) {
      timestamps.push(max);
    }
    return timestamps.sort((a, b) => a - b);
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
var registerables = [
  controllers,
  elements,
  plugins,
  scales
];

// node_modules/chart.js/auto/auto.js
Chart.register(...registerables);
var auto_default = Chart;

// main.ts
var MostUsedWordsPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.wordCountMap = /* @__PURE__ */ new Map();
    this.activeView = null;
  }
  onload() {
    this.addRibbonIcon("document", "Show Most Used Words graph", async () => {
      await this.showMostUsedWordsGraph();
    });
    this.addCommand({
      id: "show-most-used-words-graph",
      name: "Show Most Used Words graph",
      callback: async () => {
        await this.showMostUsedWordsGraph();
      }
    });
    this.registerEvent(this.app.workspace.on("file-open", this.handleFileOpen.bind(this)));
    this.registerEvent(this.app.workspace.on("editor-change", this.handleEditorChange.bind(this)));
    this.registerEvent(this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange.bind(this)));
    this.registerEvent(this.app.workspace.on("quit", () => {
      this.closeMostUsedWordsGraph();
    }));
  }
  async showMostUsedWordsGraph() {
    if (!this.activeView) {
      await this.calculateWordCountMap();
      const sortedWords = this.getSortedWords();
      const topWords = sortedWords.slice(0, 100);
      const labels = topWords.map(([word]) => word);
      const data = topWords.map(([_, count]) => count);
      const leaf = this.app.workspace.getLeaf();
      const view = new MostUsedWordsView(leaf, labels, data, this);
      leaf.open(view);
      this.activeView = view;
    }
  }
  async calculateWordCountMap() {
    this.wordCountMap.clear();
    const vault = this.app.vault;
    const notes = vault.getMarkdownFiles();
    for (const note of notes) {
      const content = await vault.read(note);
      const words = content.split(/\s+/);
      words.forEach((word) => {
        const normalizedWord = word.toLowerCase().replace(/[^a-zA-Z0-9]/g, "");
        if (normalizedWord.length > 0) {
          const count = this.wordCountMap.get(normalizedWord) || 0;
          this.wordCountMap.set(normalizedWord, count + 1);
        }
      });
    }
    if (this.activeView) {
      const sortedWords = this.getSortedWords();
      const topWords = sortedWords.slice(0, 100);
      const labels = topWords.map(([word]) => word);
      const data = topWords.map(([_, count]) => count);
      this.activeView.updateContent(labels, data);
      this.activeView.setTabText();
    }
  }
  getSortedWords() {
    return Array.from(this.wordCountMap.entries()).sort((a, b) => b[1] - a[1]);
  }
  handleFileOpen(file) {
    this.calculateWordCountMap();
  }
  handleEditorChange() {
    this.calculateWordCountMap();
  }
  handleActiveLeafChange(leaf) {
    if (leaf && leaf.view instanceof MostUsedWordsView) {
      this.activeView = leaf.view;
      this.calculateWordCountMap();
    }
  }
  closeMostUsedWordsGraph() {
    if (this.activeView) {
      this.activeView.unload();
    }
  }
  onunload() {
    this.wordCountMap.clear();
    this.closeMostUsedWordsGraph();
  }
};
var MostUsedWordsView = class extends import_obsidian.View {
  constructor(leaf, labels, data, plugin) {
    super(leaf);
    this.chart = null;
    this.labels = labels;
    this.data = data;
    this.plugin = plugin;
  }
  getViewType() {
    return "most-used-words-view";
  }
  getDisplayText() {
    return "Most Used Words";
  }
  onload() {
    this.renderChart();
  }
  updateContent(labels, data) {
    this.labels = labels;
    this.data = data;
    if (this.chart) {
      this.chart.data.labels = labels;
      this.chart.data.datasets[0].data = data;
      this.chart.update();
    }
  }
  renderChart() {
    const canvas = document.createElement("canvas");
    canvas.width = 400;
    canvas.height = 300;
    this.containerEl.appendChild(canvas);
    const ctx = canvas.getContext("2d");
    if (ctx) {
      this.chart = new auto_default(ctx, {
        type: "bar",
        data: {
          labels: this.labels,
          datasets: [{
            label: "Word Count",
            data: this.data,
            backgroundColor: "rgba(75, 192, 192, 0.2)",
            borderColor: "rgba(75, 192, 192, 1)",
            borderWidth: 1
          }]
        },
        options: {
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }
  }
  setTabText() {
    var _a, _b, _c;
    const leafTitle = (_a = this.app.workspace.activeLeaf) == null ? void 0 : _a.getViewState().type;
    if (leafTitle) {
      (_c = this.app.workspace.activeLeaf) == null ? void 0 : _c.setEphemeralState({
        ...(_b = this.app.workspace.activeLeaf) == null ? void 0 : _b.getEphemeralState(),
        title: "Most Used Words"
      });
    }
  }
  unload() {
    if (this.chart) {
      this.chart.destroy();
      this.chart = null;
    }
    super.unload();
    if (this.plugin) {
      this.plugin.activeView = null;
    }
  }
};
/*! Bundled license information:

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.2
   * https://github.com/kurkle/color#readme
   * (c) 2023 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.js:
  (*!
   * Chart.js v4.4.2
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.4.2
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJub2RlX21vZHVsZXMvQGt1cmtsZS9jb2xvci9kaXN0L2NvbG9yLmVzbS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb3JlLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLm1hdGgudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5leHRyYXMudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZWFzaW5nLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbG9yLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdGlvbnMuZGVmYXVsdHMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUubGF5b3V0cy5kZWZhdWx0cy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5pbnRsLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnRpY2tzLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnNjYWxlLmRlZmF1bHRzLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmRlZmF1bHRzLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNhbnZhcy50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbmZpZy50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jdXJ2ZS50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5kb20udHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuaW50ZXJwb2xhdGlvbi50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5ydGwudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuc2VnbWVudC5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRvci5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb24uanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9ucy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuYmFyLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5idWJibGUuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmRvdWdobnV0LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5saW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5wb2xhckFyZWEuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnBpZS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIucmFkYXIuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnNjYXR0ZXIuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYWRhcHRlcnMudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuaW50ZXJhY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUubGF5b3V0cy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2UuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9wbGF0Zm9ybS5iYXNpYy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmRvbS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmVsZW1lbnQudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuc2NhbGUuYXV0b3NraXAuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuc2NhbGUuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUudHlwZWRSZWdpc3RyeS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5yZWdpc3RyeS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5wbHVnaW5zLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmNvbmZpZy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5jb250cm9sbGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5hcmMudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LmxpbmUuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LnBvaW50LnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5iYXIuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5jb2xvcnMudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5kZWNpbWF0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5zZWdtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5oZWxwZXIuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLm9wdGlvbnMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLnRhcmdldC5zdGFjay5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9zaW1wbGVBcmMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLnRhcmdldC5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuZHJhd2luZy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmxlZ2VuZC5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLnRpdGxlLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uc3VidGl0bGUuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi50b29sdGlwLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmNhdGVnb3J5LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmxpbmVhcmJhc2UuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUubGluZWFyLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmxvZ2FyaXRobWljLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnJhZGlhbExpbmVhci5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS50aW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnRpbWVzZXJpZXMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvYXV0by9hdXRvLmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBQbHVnaW4sIFdvcmtzcGFjZUxlYWYsIFZpZXcsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgQ2hhcnQgZnJvbSAnY2hhcnQuanMvYXV0byc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb3N0VXNlZFdvcmRzUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcclxuICAgIHByaXZhdGUgd29yZENvdW50TWFwOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xyXG4gICAgcHVibGljIGFjdGl2ZVZpZXc6IE1vc3RVc2VkV29yZHNWaWV3IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgb25sb2FkKCkge1xyXG4gICAgICAgIHRoaXMuYWRkUmliYm9uSWNvbignZG9jdW1lbnQnLCAnU2hvdyBNb3N0IFVzZWQgV29yZHMgZ3JhcGgnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2hvd01vc3RVc2VkV29yZHNHcmFwaCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICAgICAgICBpZDogJ3Nob3ctbW9zdC11c2VkLXdvcmRzLWdyYXBoJyxcclxuICAgICAgICAgICAgbmFtZTogJ1Nob3cgTW9zdCBVc2VkIFdvcmRzIGdyYXBoJyxcclxuICAgICAgICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2hvd01vc3RVc2VkV29yZHNHcmFwaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudCh0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2ZpbGUtb3BlbicsIHRoaXMuaGFuZGxlRmlsZU9wZW4uYmluZCh0aGlzKSkpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudCh0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2VkaXRvci1jaGFuZ2UnLCB0aGlzLmhhbmRsZUVkaXRvckNoYW5nZS5iaW5kKHRoaXMpKSk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KHRoaXMuYXBwLndvcmtzcGFjZS5vbignYWN0aXZlLWxlYWYtY2hhbmdlJywgdGhpcy5oYW5kbGVBY3RpdmVMZWFmQ2hhbmdlLmJpbmQodGhpcykpKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KHRoaXMuYXBwLndvcmtzcGFjZS5vbigncXVpdCcsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZU1vc3RVc2VkV29yZHNHcmFwaCgpO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBzaG93TW9zdFVzZWRXb3Jkc0dyYXBoKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVWaWV3KSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2FsY3VsYXRlV29yZENvdW50TWFwKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZFdvcmRzID0gdGhpcy5nZXRTb3J0ZWRXb3JkcygpO1xyXG4gICAgICAgICAgICBjb25zdCB0b3BXb3JkcyA9IHNvcnRlZFdvcmRzLnNsaWNlKDAsIDEwMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVscyA9IHRvcFdvcmRzLm1hcCgoW3dvcmRdKSA9PiB3b3JkKTtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRvcFdvcmRzLm1hcCgoW18sIGNvdW50XSkgPT4gY291bnQpO1xyXG4gICAgICAgICAgICBjb25zdCBsZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYoKTtcclxuICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBNb3N0VXNlZFdvcmRzVmlldyhsZWFmLCBsYWJlbHMsIGRhdGEsIHRoaXMpO1xyXG4gICAgICAgICAgICBsZWFmLm9wZW4odmlldyk7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IHZpZXc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcblxyXG4gICAgYXN5bmMgY2FsY3VsYXRlV29yZENvdW50TWFwKCkge1xyXG4gICAgICAgIHRoaXMud29yZENvdW50TWFwLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZhdWx0ID0gdGhpcy5hcHAudmF1bHQ7XHJcbiAgICAgICAgY29uc3Qgbm90ZXMgPSB2YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3Qgbm90ZSBvZiBub3Rlcykge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdmF1bHQucmVhZChub3RlKTtcclxuICAgICAgICAgICAgY29uc3Qgd29yZHMgPSBjb250ZW50LnNwbGl0KC9cXHMrLyk7XHJcbiAgICAgICAgICAgIHdvcmRzLmZvckVhY2god29yZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkV29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgJycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRXb3JkLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMud29yZENvdW50TWFwLmdldChub3JtYWxpemVkV29yZCkgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndvcmRDb3VudE1hcC5zZXQobm9ybWFsaXplZFdvcmQsIGNvdW50ICsgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlVmlldykge1xyXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRXb3JkcyA9IHRoaXMuZ2V0U29ydGVkV29yZHMoKTtcclxuICAgICAgICAgICAgY29uc3QgdG9wV29yZHMgPSBzb3J0ZWRXb3Jkcy5zbGljZSgwLCAxMDApO1xyXG4gICAgICAgICAgICBjb25zdCBsYWJlbHMgPSB0b3BXb3Jkcy5tYXAoKFt3b3JkXSkgPT4gd29yZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0b3BXb3Jkcy5tYXAoKFtfLCBjb3VudF0pID0+IGNvdW50KTtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVWaWV3LnVwZGF0ZUNvbnRlbnQobGFiZWxzLCBkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVWaWV3LnNldFRhYlRleHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U29ydGVkV29yZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy53b3JkQ291bnRNYXAuZW50cmllcygpKS5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlRmlsZU9wZW4oZmlsZTogVEZpbGUpIHtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZVdvcmRDb3VudE1hcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZUVkaXRvckNoYW5nZSgpIHtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZVdvcmRDb3VudE1hcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZUFjdGl2ZUxlYWZDaGFuZ2UobGVhZjogV29ya3NwYWNlTGVhZiB8IG51bGwpIHtcclxuICAgICAgICBpZiAobGVhZiAmJiBsZWFmLnZpZXcgaW5zdGFuY2VvZiBNb3N0VXNlZFdvcmRzVmlldykge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVZpZXcgPSBsZWFmLnZpZXc7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlV29yZENvdW50TWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsb3NlTW9zdFVzZWRXb3Jkc0dyYXBoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVZpZXcpIHtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVWaWV3LnVubG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG5cclxuICAgIG9udW5sb2FkKCkge1xyXG4gICAgICAgIHRoaXMud29yZENvdW50TWFwLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5jbG9zZU1vc3RVc2VkV29yZHNHcmFwaCgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBNb3N0VXNlZFdvcmRzVmlldyBleHRlbmRzIFZpZXcge1xyXG4gICAgbGFiZWxzOiBzdHJpbmdbXTtcclxuICAgIGRhdGE6IG51bWJlcltdO1xyXG4gICAgY2hhcnQ6IENoYXJ0IHwgbnVsbCA9IG51bGw7XHJcbiAgICBwbHVnaW46IE1vc3RVc2VkV29yZHNQbHVnaW47XHJcblxyXG4gICAgY29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZiwgbGFiZWxzOiBzdHJpbmdbXSwgZGF0YTogbnVtYmVyW10sIHBsdWdpbjogTW9zdFVzZWRXb3Jkc1BsdWdpbikge1xyXG4gICAgICAgIHN1cGVyKGxlYWYpO1xyXG4gICAgICAgIHRoaXMubGFiZWxzID0gbGFiZWxzO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Vmlld1R5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICdtb3N0LXVzZWQtd29yZHMtdmlldyc7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGlzcGxheVRleHQoKSB7XHJcbiAgICAgICAgcmV0dXJuICdNb3N0IFVzZWQgV29yZHMnO1xyXG4gICAgfVxyXG5cclxuICAgIG9ubG9hZCgpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckNoYXJ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlQ29udGVudChsYWJlbHM6IHN0cmluZ1tdLCBkYXRhOiBudW1iZXJbXSkge1xyXG4gICAgICAgIHRoaXMubGFiZWxzID0gbGFiZWxzO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hhcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhLmxhYmVscyA9IGxhYmVscztcclxuICAgICAgICAgICAgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJ0LnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJDaGFydCgpIHtcclxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBjYW52YXMud2lkdGggPSA0MDA7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDMwMDtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLmFwcGVuZENoaWxkKGNhbnZhcyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGlmIChjdHgpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFydCA9IG5ldyBDaGFydChjdHgsIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdiYXInLFxyXG4gICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsczogdGhpcy5sYWJlbHMsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YXNldHM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnV29yZCBDb3VudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSg3NSwgMTkyLCAxOTIsIDAuMiknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ3JnYmEoNzUsIDE5MiwgMTkyLCAxKScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxXHJcbiAgICAgICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRUYWJUZXh0KCkge1xyXG4gICAgICAgIGNvbnN0IGxlYWZUaXRsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5hY3RpdmVMZWFmPy5nZXRWaWV3U3RhdGUoKS50eXBlO1xyXG4gICAgICAgIGlmIChsZWFmVGl0bGUpIHtcclxuICAgICAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLmFjdGl2ZUxlYWY/LnNldEVwaGVtZXJhbFN0YXRlKHtcclxuICAgICAgICAgICAgICAgIC4uLnRoaXMuYXBwLndvcmtzcGFjZS5hY3RpdmVMZWFmPy5nZXRFcGhlbWVyYWxTdGF0ZSgpLFxyXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdNb3N0IFVzZWQgV29yZHMnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1bmxvYWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hhcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFydC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhcnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci51bmxvYWQoKTtcclxuICAgICAgICBpZiAodGhpcy5wbHVnaW4pIHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uYWN0aXZlVmlldyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4iLCAiLyohXG4gKiBAa3Vya2xlL2NvbG9yIHYwLjMuMlxuICogaHR0cHM6Ly9naXRodWIuY29tL2t1cmtsZS9jb2xvciNyZWFkbWVcbiAqIChjKSAyMDIzIEp1a2thIEt1cmtlbGFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiByb3VuZCh2KSB7XG4gIHJldHVybiB2ICsgMC41IHwgMDtcbn1cbmNvbnN0IGxpbSA9ICh2LCBsLCBoKSA9PiBNYXRoLm1heChNYXRoLm1pbih2LCBoKSwgbCk7XG5mdW5jdGlvbiBwMmIodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyLjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpLCAwLCAxMDApO1xufVxuZnVuY3Rpb24gbjJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIybih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpIC8gMTAwLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIG4ycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDEwMCksIDAsIDEwMCk7XG59XG5cbmNvbnN0IG1hcCQxID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksIEE6IDEwLCBCOiAxMSwgQzogMTIsIEQ6IDEzLCBFOiAxNCwgRjogMTUsIGE6IDEwLCBiOiAxMSwgYzogMTIsIGQ6IDEzLCBlOiAxNCwgZjogMTV9O1xuY29uc3QgaGV4ID0gWy4uLicwMTIzNDU2Nzg5QUJDREVGJ107XG5jb25zdCBoMSA9IGIgPT4gaGV4W2IgJiAweEZdO1xuY29uc3QgaDIgPSBiID0+IGhleFsoYiAmIDB4RjApID4+IDRdICsgaGV4W2IgJiAweEZdO1xuY29uc3QgZXEgPSBiID0+ICgoYiAmIDB4RjApID4+IDQpID09PSAoYiAmIDB4Rik7XG5jb25zdCBpc1Nob3J0ID0gdiA9PiBlcSh2LnIpICYmIGVxKHYuZykgJiYgZXEodi5iKSAmJiBlcSh2LmEpO1xuZnVuY3Rpb24gaGV4UGFyc2Uoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICB2YXIgcmV0O1xuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAobGVuID09PSA0IHx8IGxlbiA9PT0gNSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiAyNTUgJiBtYXAkMVtzdHJbMV1dICogMTcsXG4gICAgICAgIGc6IDI1NSAmIG1hcCQxW3N0clsyXV0gKiAxNyxcbiAgICAgICAgYjogMjU1ICYgbWFwJDFbc3RyWzNdXSAqIDE3LFxuICAgICAgICBhOiBsZW4gPT09IDUgPyBtYXAkMVtzdHJbNF1dICogMTcgOiAyNTVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDcgfHwgbGVuID09PSA5KSB7XG4gICAgICByZXQgPSB7XG4gICAgICAgIHI6IG1hcCQxW3N0clsxXV0gPDwgNCB8IG1hcCQxW3N0clsyXV0sXG4gICAgICAgIGc6IG1hcCQxW3N0clszXV0gPDwgNCB8IG1hcCQxW3N0cls0XV0sXG4gICAgICAgIGI6IG1hcCQxW3N0cls1XV0gPDwgNCB8IG1hcCQxW3N0cls2XV0sXG4gICAgICAgIGE6IGxlbiA9PT0gOSA/IChtYXAkMVtzdHJbN11dIDw8IDQgfCBtYXAkMVtzdHJbOF1dKSA6IDI1NVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGFscGhhID0gKGEsIGYpID0+IGEgPCAyNTUgPyBmKGEpIDogJyc7XG5mdW5jdGlvbiBoZXhTdHJpbmcodikge1xuICB2YXIgZiA9IGlzU2hvcnQodikgPyBoMSA6IGgyO1xuICByZXR1cm4gdlxuICAgID8gJyMnICsgZih2LnIpICsgZih2LmcpICsgZih2LmIpICsgYWxwaGEodi5hLCBmKVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5jb25zdCBIVUVfUkUgPSAvXihoc2xhP3xod2J8aHN2KVxcKFxccyooWy0rLmVcXGRdKykoPzpkZWcpP1tcXHMsXSsoWy0rLmVcXGRdKyklW1xccyxdKyhbLSsuZVxcZF0rKSUoPzpbXFxzLF0rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gaHNsMnJnYm4oaCwgcywgbCkge1xuICBjb25zdCBhID0gcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gMzApICUgMTIpID0+IGwgLSBhICogTWF0aC5tYXgoTWF0aC5taW4oayAtIDMsIDkgLSBrLCAxKSwgLTEpO1xuICByZXR1cm4gW2YoMCksIGYoOCksIGYoNCldO1xufVxuZnVuY3Rpb24gaHN2MnJnYm4oaCwgcywgdikge1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyA2MCkgJSA2KSA9PiB2IC0gdiAqIHMgKiBNYXRoLm1heChNYXRoLm1pbihrLCA0IC0gaywgMSksIDApO1xuICByZXR1cm4gW2YoNSksIGYoMyksIGYoMSldO1xufVxuZnVuY3Rpb24gaHdiMnJnYm4oaCwgdywgYikge1xuICBjb25zdCByZ2IgPSBoc2wycmdibihoLCAxLCAwLjUpO1xuICBsZXQgaTtcbiAgaWYgKHcgKyBiID4gMSkge1xuICAgIGkgPSAxIC8gKHcgKyBiKTtcbiAgICB3ICo9IGk7XG4gICAgYiAqPSBpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICByZ2JbaV0gKj0gMSAtIHcgLSBiO1xuICAgIHJnYltpXSArPSB3O1xuICB9XG4gIHJldHVybiByZ2I7XG59XG5mdW5jdGlvbiBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpIHtcbiAgaWYgKHIgPT09IG1heCkge1xuICAgIHJldHVybiAoKGcgLSBiKSAvIGQpICsgKGcgPCBiID8gNiA6IDApO1xuICB9XG4gIGlmIChnID09PSBtYXgpIHtcbiAgICByZXR1cm4gKGIgLSByKSAvIGQgKyAyO1xuICB9XG4gIHJldHVybiAociAtIGcpIC8gZCArIDQ7XG59XG5mdW5jdGlvbiByZ2IyaHNsKHYpIHtcbiAgY29uc3QgcmFuZ2UgPSAyNTU7XG4gIGNvbnN0IHIgPSB2LnIgLyByYW5nZTtcbiAgY29uc3QgZyA9IHYuZyAvIHJhbmdlO1xuICBjb25zdCBiID0gdi5iIC8gcmFuZ2U7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgbGV0IGgsIHMsIGQ7XG4gIGlmIChtYXggIT09IG1pbikge1xuICAgIGQgPSBtYXggLSBtaW47XG4gICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgIGggPSBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpO1xuICAgIGggPSBoICogNjAgKyAwLjU7XG4gIH1cbiAgcmV0dXJuIFtoIHwgMCwgcyB8fCAwLCBsXTtcbn1cbmZ1bmN0aW9uIGNhbGxuKGYsIGEsIGIsIGMpIHtcbiAgcmV0dXJuIChcbiAgICBBcnJheS5pc0FycmF5KGEpXG4gICAgICA/IGYoYVswXSwgYVsxXSwgYVsyXSlcbiAgICAgIDogZihhLCBiLCBjKVxuICApLm1hcChuMmIpO1xufVxuZnVuY3Rpb24gaHNsMnJnYihoLCBzLCBsKSB7XG4gIHJldHVybiBjYWxsbihoc2wycmdibiwgaCwgcywgbCk7XG59XG5mdW5jdGlvbiBod2IycmdiKGgsIHcsIGIpIHtcbiAgcmV0dXJuIGNhbGxuKGh3YjJyZ2JuLCBoLCB3LCBiKTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2IoaCwgcywgdikge1xuICByZXR1cm4gY2FsbG4oaHN2MnJnYm4sIGgsIHMsIHYpO1xufVxuZnVuY3Rpb24gaHVlKGgpIHtcbiAgcmV0dXJuIChoICUgMzYwICsgMzYwKSAlIDM2MDtcbn1cbmZ1bmN0aW9uIGh1ZVBhcnNlKHN0cikge1xuICBjb25zdCBtID0gSFVFX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCB2O1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bNV0gIT09IHYpIHtcbiAgICBhID0gbVs2XSA/IHAyYigrbVs1XSkgOiBuMmIoK21bNV0pO1xuICB9XG4gIGNvbnN0IGggPSBodWUoK21bMl0pO1xuICBjb25zdCBwMSA9ICttWzNdIC8gMTAwO1xuICBjb25zdCBwMiA9ICttWzRdIC8gMTAwO1xuICBpZiAobVsxXSA9PT0gJ2h3YicpIHtcbiAgICB2ID0gaHdiMnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2UgaWYgKG1bMV0gPT09ICdoc3YnKSB7XG4gICAgdiA9IGhzdjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIHtcbiAgICB2ID0gaHNsMnJnYihoLCBwMSwgcDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcjogdlswXSxcbiAgICBnOiB2WzFdLFxuICAgIGI6IHZbMl0sXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcm90YXRlKHYsIGRlZykge1xuICB2YXIgaCA9IHJnYjJoc2wodik7XG4gIGhbMF0gPSBodWUoaFswXSArIGRlZyk7XG4gIGggPSBoc2wycmdiKGgpO1xuICB2LnIgPSBoWzBdO1xuICB2LmcgPSBoWzFdO1xuICB2LmIgPSBoWzJdO1xufVxuZnVuY3Rpb24gaHNsU3RyaW5nKHYpIHtcbiAgaWYgKCF2KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGEgPSByZ2IyaHNsKHYpO1xuICBjb25zdCBoID0gYVswXTtcbiAgY29uc3QgcyA9IG4ycChhWzFdKTtcbiAgY29uc3QgbCA9IG4ycChhWzJdKTtcbiAgcmV0dXJuIHYuYSA8IDI1NVxuICAgID8gYGhzbGEoJHtofSwgJHtzfSUsICR7bH0lLCAke2Iybih2LmEpfSlgXG4gICAgOiBgaHNsKCR7aH0sICR7c30lLCAke2x9JSlgO1xufVxuXG5jb25zdCBtYXAgPSB7XG4gIHg6ICdkYXJrJyxcbiAgWjogJ2xpZ2h0JyxcbiAgWTogJ3JlJyxcbiAgWDogJ2JsdScsXG4gIFc6ICdncicsXG4gIFY6ICdtZWRpdW0nLFxuICBVOiAnc2xhdGUnLFxuICBBOiAnZWUnLFxuICBUOiAnb2wnLFxuICBTOiAnb3InLFxuICBCOiAncmEnLFxuICBDOiAnbGF0ZWcnLFxuICBEOiAnaWdodHMnLFxuICBSOiAnaW4nLFxuICBROiAndHVycXVvaXMnLFxuICBFOiAnaGknLFxuICBQOiAncm8nLFxuICBPOiAnYWwnLFxuICBOOiAnbGUnLFxuICBNOiAnZGUnLFxuICBMOiAneWVsbG8nLFxuICBGOiAnZW4nLFxuICBLOiAnY2gnLFxuICBHOiAnYXJrcycsXG4gIEg6ICdlYScsXG4gIEk6ICdpZ2h0ZycsXG4gIEo6ICd3aCdcbn07XG5jb25zdCBuYW1lcyQxID0ge1xuICBPaWNlWGU6ICdmMGY4ZmYnLFxuICBhbnRpcXVld0V0ZTogJ2ZhZWJkNycsXG4gIGFxdWE6ICdmZmZmJyxcbiAgYXF1YW1hclJlOiAnN2ZmZmQ0JyxcbiAgYXp1WTogJ2YwZmZmZicsXG4gIGJlaWdlOiAnZjVmNWRjJyxcbiAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgYmxhY2s6ICcwJyxcbiAgYmxhbktlZE9tb25kOiAnZmZlYmNkJyxcbiAgWGU6ICdmZicsXG4gIFhldmlUZXQ6ICc4YTJiZTInLFxuICBiUHduOiAnYTUyYTJhJyxcbiAgYnVybHl3b29kOiAnZGViODg3JyxcbiAgY2FNdFhlOiAnNWY5ZWEwJyxcbiAgS2FydFl1c2U6ICc3ZmZmMDAnLFxuICBLb2NUYXRlOiAnZDI2OTFlJyxcbiAgY1NPOiAnZmY3ZjUwJyxcbiAgY1NuZmxvd2VyWGU6ICc2NDk1ZWQnLFxuICBjU25zaWxrOiAnZmZmOGRjJyxcbiAgY3JpbXNvbjogJ2RjMTQzYycsXG4gIGN5YW46ICdmZmZmJyxcbiAgeFhlOiAnOGInLFxuICB4Y3lhbjogJzhiOGInLFxuICB4Z1RNblBkOiAnYjg4NjBiJyxcbiAgeFdheTogJ2E5YTlhOScsXG4gIHhnWUY6ICc2NDAwJyxcbiAgeGdZeTogJ2E5YTlhOScsXG4gIHhraGFraTogJ2JkYjc2YicsXG4gIHhtYWdGdGE6ICc4YjAwOGInLFxuICB4VGl2ZWdZRjogJzU1NmIyZicsXG4gIHhTYW5nZTogJ2ZmOGMwMCcsXG4gIHhTY0VkOiAnOTkzMmNjJyxcbiAgeFlkOiAnOGIwMDAwJyxcbiAgeHNPbW9uOiAnZTk5NjdhJyxcbiAgeHNIZ1lGOiAnOGZiYzhmJyxcbiAgeFVYZTogJzQ4M2Q4YicsXG4gIHhVV2F5OiAnMmY0ZjRmJyxcbiAgeFVnWXk6ICcyZjRmNGYnLFxuICB4UWU6ICdjZWQxJyxcbiAgeHZpVGV0OiAnOTQwMGQzJyxcbiAgZEFwcFJrOiAnZmYxNDkzJyxcbiAgZEFwc2t5WGU6ICdiZmZmJyxcbiAgZGltV2F5OiAnNjk2OTY5JyxcbiAgZGltZ1l5OiAnNjk2OTY5JyxcbiAgZG9kZ2VyWGU6ICcxZTkwZmYnLFxuICBmaVlicmljazogJ2IyMjIyMicsXG4gIGZsU093RXRlOiAnZmZmYWYwJyxcbiAgZm9Zc3RXQW46ICcyMjhiMjInLFxuICBmdUtzaWE6ICdmZjAwZmYnLFxuICBnYVJzYlNvOiAnZGNkY2RjJyxcbiAgZ2hvc3R3RXRlOiAnZjhmOGZmJyxcbiAgZ1RkOiAnZmZkNzAwJyxcbiAgZ1RNblBkOiAnZGFhNTIwJyxcbiAgV2F5OiAnODA4MDgwJyxcbiAgZ1lGOiAnODAwMCcsXG4gIGdZRkx3OiAnYWRmZjJmJyxcbiAgZ1l5OiAnODA4MDgwJyxcbiAgaG9uZXlNdzogJ2YwZmZmMCcsXG4gIGhvdHBSazogJ2ZmNjliNCcsXG4gIFJkaWFuWWQ6ICdjZDVjNWMnLFxuICBSZGlnbzogJzRiMDA4MicsXG4gIGl2U3k6ICdmZmZmZjAnLFxuICBraGFraTogJ2YwZTY4YycsXG4gIGxhdkZNcjogJ2U2ZTZmYScsXG4gIGxhdkZNclhzaDogJ2ZmZjBmNScsXG4gIGxhd25nWUY6ICc3Y2ZjMDAnLFxuICBObW9uY0VmZm9uOiAnZmZmYWNkJyxcbiAgWlhlOiAnYWRkOGU2JyxcbiAgWmNTTzogJ2YwODA4MCcsXG4gIFpjeWFuOiAnZTBmZmZmJyxcbiAgWmdUTW5QZEx3OiAnZmFmYWQyJyxcbiAgWldheTogJ2QzZDNkMycsXG4gIFpnWUY6ICc5MGVlOTAnLFxuICBaZ1l5OiAnZDNkM2QzJyxcbiAgWnBSazogJ2ZmYjZjMScsXG4gIFpzT21vbjogJ2ZmYTA3YScsXG4gIFpzSGdZRjogJzIwYjJhYScsXG4gIFpza3lYZTogJzg3Y2VmYScsXG4gIFpVV2F5OiAnNzc4ODk5JyxcbiAgWlVnWXk6ICc3Nzg4OTknLFxuICBac3RBbFhlOiAnYjBjNGRlJyxcbiAgWkx3OiAnZmZmZmUwJyxcbiAgbGltZTogJ2ZmMDAnLFxuICBsaW1lZ1lGOiAnMzJjZDMyJyxcbiAgbFJGOiAnZmFmMGU2JyxcbiAgbWFnRnRhOiAnZmYwMGZmJyxcbiAgbWFQb246ICc4MDAwMDAnLFxuICBWYXF1YW1hclJlOiAnNjZjZGFhJyxcbiAgVlhlOiAnY2QnLFxuICBWU2NFZDogJ2JhNTVkMycsXG4gIFZwdXJwTjogJzkzNzBkYicsXG4gIFZzSGdZRjogJzNjYjM3MScsXG4gIFZVWGU6ICc3YjY4ZWUnLFxuICBWc3ByUmdnWUY6ICdmYTlhJyxcbiAgVlFlOiAnNDhkMWNjJyxcbiAgVnZpVGV0WWQ6ICdjNzE1ODUnLFxuICBtaWRuaWdodFhlOiAnMTkxOTcwJyxcbiAgbVJ0Y1lhbTogJ2Y1ZmZmYScsXG4gIG1pc3R5UHNlOiAnZmZlNGUxJyxcbiAgbW9jY2FzUjogJ2ZmZTRiNScsXG4gIG5hdmFqb3dFdGU6ICdmZmRlYWQnLFxuICBuYXZ5OiAnODAnLFxuICBUZGxhY2U6ICdmZGY1ZTYnLFxuICBUaXZlOiAnODA4MDAwJyxcbiAgVGl2ZWRCYjogJzZiOGUyMycsXG4gIFNhbmdlOiAnZmZhNTAwJyxcbiAgU2FuZ2VZZDogJ2ZmNDUwMCcsXG4gIFNjRWQ6ICdkYTcwZDYnLFxuICBwT2VnVE1uUGQ6ICdlZWU4YWEnLFxuICBwT2VnWUY6ICc5OGZiOTgnLFxuICBwT2VRZTogJ2FmZWVlZScsXG4gIHBPZXZpVGV0WWQ6ICdkYjcwOTMnLFxuICBwYXBheWF3RXA6ICdmZmVmZDUnLFxuICBwSEtwdWZmOiAnZmZkYWI5JyxcbiAgcGVydTogJ2NkODUzZicsXG4gIHBSazogJ2ZmYzBjYicsXG4gIHBsdW06ICdkZGEwZGQnLFxuICBwb3dNclhlOiAnYjBlMGU2JyxcbiAgcHVycE46ICc4MDAwODAnLFxuICBZYmVjY2FwdXJwTjogJzY2MzM5OScsXG4gIFlkOiAnZmYwMDAwJyxcbiAgUHN5YnJvd246ICdiYzhmOGYnLFxuICBQeU9YZTogJzQxNjllMScsXG4gIHNhZGROYlB3bjogJzhiNDUxMycsXG4gIHNPbW9uOiAnZmE4MDcyJyxcbiAgc2FuZHliUHduOiAnZjRhNDYwJyxcbiAgc0hnWUY6ICcyZThiNTcnLFxuICBzSHNoZWxsOiAnZmZmNWVlJyxcbiAgc2lGbmE6ICdhMDUyMmQnLFxuICBzaWx2ZXI6ICdjMGMwYzAnLFxuICBza3lYZTogJzg3Y2VlYicsXG4gIFVYZTogJzZhNWFjZCcsXG4gIFVXYXk6ICc3MDgwOTAnLFxuICBVZ1l5OiAnNzA4MDkwJyxcbiAgc25vdzogJ2ZmZmFmYScsXG4gIHNwclJnZ1lGOiAnZmY3ZicsXG4gIHN0QWxYZTogJzQ2ODJiNCcsXG4gIHRhbjogJ2QyYjQ4YycsXG4gIHRlTzogJzgwODAnLFxuICB0RXN0TjogJ2Q4YmZkOCcsXG4gIHRvbWF0bzogJ2ZmNjM0NycsXG4gIFFlOiAnNDBlMGQwJyxcbiAgdmlUZXQ6ICdlZTgyZWUnLFxuICBKSHQ6ICdmNWRlYjMnLFxuICB3RXRlOiAnZmZmZmZmJyxcbiAgd0V0ZXNtb2tlOiAnZjVmNWY1JyxcbiAgTHc6ICdmZmZmMDAnLFxuICBMd2dZRjogJzlhY2QzMidcbn07XG5mdW5jdGlvbiB1bnBhY2soKSB7XG4gIGNvbnN0IHVucGFja2VkID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhuYW1lcyQxKTtcbiAgY29uc3QgdGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuICBsZXQgaSwgaiwgaywgb2ssIG5rO1xuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG9rID0gbmsgPSBrZXlzW2ldO1xuICAgIGZvciAoaiA9IDA7IGogPCB0a2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgayA9IHRrZXlzW2pdO1xuICAgICAgbmsgPSBuay5yZXBsYWNlKGssIG1hcFtrXSk7XG4gICAgfVxuICAgIGsgPSBwYXJzZUludChuYW1lcyQxW29rXSwgMTYpO1xuICAgIHVucGFja2VkW25rXSA9IFtrID4+IDE2ICYgMHhGRiwgayA+PiA4ICYgMHhGRiwgayAmIDB4RkZdO1xuICB9XG4gIHJldHVybiB1bnBhY2tlZDtcbn1cblxubGV0IG5hbWVzO1xuZnVuY3Rpb24gbmFtZVBhcnNlKHN0cikge1xuICBpZiAoIW5hbWVzKSB7XG4gICAgbmFtZXMgPSB1bnBhY2soKTtcbiAgICBuYW1lcy50cmFuc3BhcmVudCA9IFswLCAwLCAwLCAwXTtcbiAgfVxuICBjb25zdCBhID0gbmFtZXNbc3RyLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gYSAmJiB7XG4gICAgcjogYVswXSxcbiAgICBnOiBhWzFdLFxuICAgIGI6IGFbMl0sXG4gICAgYTogYS5sZW5ndGggPT09IDQgPyBhWzNdIDogMjU1XG4gIH07XG59XG5cbmNvbnN0IFJHQl9SRSA9IC9ecmdiYT9cXChcXHMqKFstKy5cXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpPyg/OltcXHMsL10rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gcmdiUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBSR0JfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHIsIGcsIGI7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs3XSAhPT0gcikge1xuICAgIGNvbnN0IHYgPSArbVs3XTtcbiAgICBhID0gbVs4XSA/IHAyYih2KSA6IGxpbSh2ICogMjU1LCAwLCAyNTUpO1xuICB9XG4gIHIgPSArbVsxXTtcbiAgZyA9ICttWzNdO1xuICBiID0gK21bNV07XG4gIHIgPSAyNTUgJiAobVsyXSA/IHAyYihyKSA6IGxpbShyLCAwLCAyNTUpKTtcbiAgZyA9IDI1NSAmIChtWzRdID8gcDJiKGcpIDogbGltKGcsIDAsIDI1NSkpO1xuICBiID0gMjU1ICYgKG1bNl0gPyBwMmIoYikgOiBsaW0oYiwgMCwgMjU1KSk7XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcmdiU3RyaW5nKHYpIHtcbiAgcmV0dXJuIHYgJiYgKFxuICAgIHYuYSA8IDI1NVxuICAgICAgPyBgcmdiYSgke3Yucn0sICR7di5nfSwgJHt2LmJ9LCAke2Iybih2LmEpfSlgXG4gICAgICA6IGByZ2IoJHt2LnJ9LCAke3YuZ30sICR7di5ifSlgXG4gICk7XG59XG5cbmNvbnN0IHRvID0gdiA9PiB2IDw9IDAuMDAzMTMwOCA/IHYgKiAxMi45MiA6IE1hdGgucG93KHYsIDEuMCAvIDIuNCkgKiAxLjA1NSAtIDAuMDU1O1xuY29uc3QgZnJvbSA9IHYgPT4gdiA8PSAwLjA0MDQ1ID8gdiAvIDEyLjkyIDogTWF0aC5wb3coKHYgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbmZ1bmN0aW9uIGludGVycG9sYXRlKHJnYjEsIHJnYjIsIHQpIHtcbiAgY29uc3QgciA9IGZyb20oYjJuKHJnYjEucikpO1xuICBjb25zdCBnID0gZnJvbShiMm4ocmdiMS5nKSk7XG4gIGNvbnN0IGIgPSBmcm9tKGIybihyZ2IxLmIpKTtcbiAgcmV0dXJuIHtcbiAgICByOiBuMmIodG8ociArIHQgKiAoZnJvbShiMm4ocmdiMi5yKSkgLSByKSkpLFxuICAgIGc6IG4yYih0byhnICsgdCAqIChmcm9tKGIybihyZ2IyLmcpKSAtIGcpKSksXG4gICAgYjogbjJiKHRvKGIgKyB0ICogKGZyb20oYjJuKHJnYjIuYikpIC0gYikpKSxcbiAgICBhOiByZ2IxLmEgKyB0ICogKHJnYjIuYSAtIHJnYjEuYSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW9kSFNMKHYsIGksIHJhdGlvKSB7XG4gIGlmICh2KSB7XG4gICAgbGV0IHRtcCA9IHJnYjJoc2wodik7XG4gICAgdG1wW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG1wW2ldICsgdG1wW2ldICogcmF0aW8sIGkgPT09IDAgPyAzNjAgOiAxKSk7XG4gICAgdG1wID0gaHNsMnJnYih0bXApO1xuICAgIHYuciA9IHRtcFswXTtcbiAgICB2LmcgPSB0bXBbMV07XG4gICAgdi5iID0gdG1wWzJdO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZSh2LCBwcm90bykge1xuICByZXR1cm4gdiA/IE9iamVjdC5hc3NpZ24ocHJvdG8gfHwge30sIHYpIDogdjtcbn1cbmZ1bmN0aW9uIGZyb21PYmplY3QoaW5wdXQpIHtcbiAgdmFyIHYgPSB7cjogMCwgZzogMCwgYjogMCwgYTogMjU1fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICB2ID0ge3I6IGlucHV0WzBdLCBnOiBpbnB1dFsxXSwgYjogaW5wdXRbMl0sIGE6IDI1NX07XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMykge1xuICAgICAgICB2LmEgPSBuMmIoaW5wdXRbM10pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gY2xvbmUoaW5wdXQsIHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAxfSk7XG4gICAgdi5hID0gbjJiKHYuYSk7XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBmdW5jdGlvblBhcnNlKHN0cikge1xuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJ3InKSB7XG4gICAgcmV0dXJuIHJnYlBhcnNlKHN0cik7XG4gIH1cbiAgcmV0dXJuIGh1ZVBhcnNlKHN0cik7XG59XG5jbGFzcyBDb2xvciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgICBsZXQgdjtcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHYgPSBmcm9tT2JqZWN0KGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gaGV4UGFyc2UoaW5wdXQpIHx8IG5hbWVQYXJzZShpbnB1dCkgfHwgZnVuY3Rpb25QYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRoaXMuX3JnYiA9IHY7XG4gICAgdGhpcy5fdmFsaWQgPSAhIXY7XG4gIH1cbiAgZ2V0IHZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZDtcbiAgfVxuICBnZXQgcmdiKCkge1xuICAgIHZhciB2ID0gY2xvbmUodGhpcy5fcmdiKTtcbiAgICBpZiAodikge1xuICAgICAgdi5hID0gYjJuKHYuYSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIHNldCByZ2Iob2JqKSB7XG4gICAgdGhpcy5fcmdiID0gZnJvbU9iamVjdChvYmopO1xuICB9XG4gIHJnYlN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyByZ2JTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBoZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaGV4U3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaHNsU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhzbFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIG1peChjb2xvciwgd2VpZ2h0KSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb25zdCBjMSA9IHRoaXMucmdiO1xuICAgICAgY29uc3QgYzIgPSBjb2xvci5yZ2I7XG4gICAgICBsZXQgdzI7XG4gICAgICBjb25zdCBwID0gd2VpZ2h0ID09PSB3MiA/IDAuNSA6IHdlaWdodDtcbiAgICAgIGNvbnN0IHcgPSAyICogcCAtIDE7XG4gICAgICBjb25zdCBhID0gYzEuYSAtIGMyLmE7XG4gICAgICBjb25zdCB3MSA9ICgodyAqIGEgPT09IC0xID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcbiAgICAgIHcyID0gMSAtIHcxO1xuICAgICAgYzEuciA9IDB4RkYgJiB3MSAqIGMxLnIgKyB3MiAqIGMyLnIgKyAwLjU7XG4gICAgICBjMS5nID0gMHhGRiAmIHcxICogYzEuZyArIHcyICogYzIuZyArIDAuNTtcbiAgICAgIGMxLmIgPSAweEZGICYgdzEgKiBjMS5iICsgdzIgKiBjMi5iICsgMC41O1xuICAgICAgYzEuYSA9IHAgKiBjMS5hICsgKDEgLSBwKSAqIGMyLmE7XG4gICAgICB0aGlzLnJnYiA9IGMxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnRlcnBvbGF0ZShjb2xvciwgdCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5fcmdiID0gaW50ZXJwb2xhdGUodGhpcy5fcmdiLCBjb2xvci5fcmdiLCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnJnYik7XG4gIH1cbiAgYWxwaGEoYSkge1xuICAgIHRoaXMuX3JnYi5hID0gbjJiKGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyZXIocmF0aW8pIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmdiLmEgKj0gMSAtIHJhdGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyZXlzY2FsZSgpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgY29uc3QgdmFsID0gcm91bmQocmdiLnIgKiAwLjMgKyByZ2IuZyAqIDAuNTkgKyByZ2IuYiAqIDAuMTEpO1xuICAgIHJnYi5yID0gcmdiLmcgPSByZ2IuYiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvcGFxdWVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgKyByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBuZWdhdGUoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMuX3JnYjtcbiAgICB2LnIgPSAyNTUgLSB2LnI7XG4gICAgdi5nID0gMjU1IC0gdi5nO1xuICAgIHYuYiA9IDI1NSAtIHYuYjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaWdodGVuKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMiwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRhcmtlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCByYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzYXR1cmF0ZShyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm90YXRlKGRlZykge1xuICAgIHJvdGF0ZSh0aGlzLl9yZ2IsIGRlZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhfZXNtKGlucHV0KSB7XG4gIHJldHVybiBuZXcgQ29sb3IoaW5wdXQpO1xufVxuXG5leHBvcnQgeyBDb2xvciwgYjJuLCBiMnAsIGluZGV4X2VzbSBhcyBkZWZhdWx0LCBoZXhQYXJzZSwgaGV4U3RyaW5nLCBoc2wycmdiLCBoc2xTdHJpbmcsIGhzdjJyZ2IsIGh1ZVBhcnNlLCBod2IycmdiLCBsaW0sIG4yYiwgbjJwLCBuYW1lUGFyc2UsIHAyYiwgcmdiMmhzbCwgcmdiUGFyc2UsIHJnYlN0cmluZywgcm90YXRlLCByb3VuZCB9O1xuIiwgIi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzXG4gKi9cblxuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0FjdGl2ZURhdGFQb2ludCwgQ2hhcnRFdmVudH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG4vKipcbiAqIEFuIGVtcHR5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBmb3Igb3B0aW9uYWwgY2FsbGJhY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge1xuICAvKiBub29wICovXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHVuaXF1ZSBpZCwgc2VxdWVudGlhbGx5IGdlbmVyYXRlZCBmcm9tIGEgZ2xvYmFsIHZhcmlhYmxlLlxuICovXG5leHBvcnQgY29uc3QgdWlkID0gKCgpID0+IHtcbiAgbGV0IGlkID0gMDtcbiAgcmV0dXJuICgpID0+IGlkKys7XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIG5laXRoZXIgbnVsbCBub3IgdW5kZWZpbmVkLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsT3JVbmRlZih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bGwgfCB1bmRlZmluZWQge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSAoaW5jbHVkaW5nIHR5cGVkIGFycmF5cyksIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5PFQgPSB1bmtub3duPih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFRbXSB7XG4gIGlmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh0eXBlLnNsaWNlKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zbGljZSgtNikgPT09ICdBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCAoZXhjbHVkaW5nIG51bGwpLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBBbnlPYmplY3Qge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIHJldHVybnMgZmFsc2VcbiAqIEBwYXJhbSB2YWx1ZSAgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXJGaW5pdGUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBudW1iZXIge1xuICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGlzRmluaXRlKCt2YWx1ZSk7XG59XG5leHBvcnQge1xuICBpc051bWJlckZpbml0ZSBhcyBpc0Zpbml0ZSxcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGZpbml0ZSwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBkZWZpbmVkLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyBub3QgZmluaXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluaXRlT3JEZWZhdWx0KHZhbHVlOiB1bmtub3duLCBkZWZhdWx0VmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGRlZmluZWQsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVPckRlZmF1bHQ8VD4odmFsdWU6IFQgfCB1bmRlZmluZWQsIGRlZmF1bHRWYWx1ZTogVCkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufVxuXG5leHBvcnQgY29uc3QgdG9QZXJjZW50YWdlID0gKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIGRpbWVuc2lvbjogbnVtYmVyKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwXG4gICAgOiArdmFsdWUgLyBkaW1lbnNpb247XG5cbmV4cG9ydCBjb25zdCB0b0RpbWVuc2lvbiA9ICh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nLCBkaW1lbnNpb246IG51bWJlcikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIGRpbWVuc2lvblxuICAgIDogK3ZhbHVlO1xuXG4vKipcbiAqIENhbGxzIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gYGFyZ3NgIGluIHRoZSBzY29wZSBkZWZpbmVkIGJ5IGB0aGlzQXJnYCBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIHJldHVybmVkIGJ5IGBmbmAuIElmIGBmbmAgaXMgbm90IGEgZnVuY3Rpb24sIHRoaXMgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLlxuICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCBgZm5gIHNob3VsZCBiZSBjYWxsZWQuXG4gKiBAcGFyYW0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGxiYWNrPFQgZXh0ZW5kcyAodGhpczogVEEsIC4uLnJlc3RBcmdzOiB1bmtub3duW10pID0+IFIsIFRBLCBSPihcbiAgZm46IFQgfCB1bmRlZmluZWQsXG4gIGFyZ3M6IHVua25vd25bXSxcbiAgdGhpc0FyZz86IFRBXG4pOiBSIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogTm90ZShTQikgZm9yIHBlcmZvcm1hbmNlIHNha2UsIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBsb29wYWJsZSB0eXBlXG4gKiBpcyB1bmtub3duIG9yIGluIG5vbmUgaW50ZW5zaXZlIGNvZGUgKG5vdCBjYWxsZWQgb2Z0ZW4gYW5kIHNtYWxsIGxvb3BhYmxlKS4gRWxzZVxuICogaXQncyBwcmVmZXJhYmxlIHRvIHVzZSBhIHJlZ3VsYXIgZm9yKCkgbG9vcCBhbmQgc2F2ZSBleHRyYSBmdW5jdGlvbiBjYWxscy5cbiAqIEBwYXJhbSBsb29wYWJsZSAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgaXRlcmF0ZWQuXG4gKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpdGVtLlxuICogQHBhcmFtIFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG4gKiBAcGFyYW0gW3JldmVyc2VdIC0gSWYgdHJ1ZSwgaXRlcmF0ZXMgYmFja3dhcmQgb24gdGhlIGxvb3BhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBSZWNvcmQ8c3RyaW5nLCBUPixcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogc3RyaW5nKSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCwgVEE+KFxuICBsb29wYWJsZTogVFtdLFxuICBmbjogKHRoaXM6IFRBLCB2OiBULCBpOiBudW1iZXIpID0+IHZvaWQsXG4gIHRoaXNBcmc/OiBUQSxcbiAgcmV2ZXJzZT86IGJvb2xlYW5cbik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBUW10gfCBSZWNvcmQ8c3RyaW5nLCBUPixcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogYW55KSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgbGVuOiBudW1iZXIsIGtleXM6IHN0cmluZ1tdO1xuICBpZiAoaXNBcnJheShsb29wYWJsZSkpIHtcbiAgICBsZW4gPSBsb29wYWJsZS5sZW5ndGg7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxvb3BhYmxlKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhsb29wYWJsZSk7XG4gICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2tleXNbaV1dLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIGEwIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBhMSAtIFRoZSBhcnJheSB0byBjb21wYXJlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2VsZW1lbnRzRXF1YWwoYTA6IEFjdGl2ZURhdGFQb2ludFtdLCBhMTogQWN0aXZlRGF0YVBvaW50W10pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2MDogQWN0aXZlRGF0YVBvaW50LCB2MTogQWN0aXZlRGF0YVBvaW50O1xuXG4gIGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHYwID0gYTBbaV07XG4gICAgdjEgPSBhMVtpXTtcblxuICAgIGlmICh2MC5kYXRhc2V0SW5kZXggIT09IHYxLmRhdGFzZXRJbmRleCB8fCB2MC5pbmRleCAhPT0gdjEuaW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIGBzb3VyY2VgIHdpdGhvdXQga2VlcGluZyByZWZlcmVuY2VzIG9uIG9iamVjdHMgYW5kIGFycmF5cy5cbiAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZTxUPihzb3VyY2U6IFQpOiBUIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKGNsb25lKSBhcyB1bmtub3duIGFzIFQ7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgY29uc3Qga2xlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrID0gMDtcblxuICAgIGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICB0YXJnZXRba2V5c1trXV0gPSBjbG9uZShzb3VyY2Vba2V5c1trXV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleTogc3RyaW5nKSB7XG4gIHJldHVybiBbJ19fcHJvdG9fXycsICdwcm90b3R5cGUnLCAnY29uc3RydWN0b3InXS5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG1lcmdlciB3aGVuIENoYXJ0LmhlbHBlcnMubWVyZ2UgaXMgY2FsbGVkIHdpdGhvdXQgbWVyZ2VyIG9wdGlvbi5cbiAqIE5vdGUoU0IpOiBhbHNvIHVzZWQgYnkgbWVyZ2VDb25maWcgYW5kIG1lcmdlU2NhbGVDb25maWcgYXMgZmFsbGJhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lcmdlcihrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0LCBvcHRpb25zOiBBbnlPYmplY3QpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgbWVyZ2UodHZhbCwgc3ZhbCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzdmFsKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lcmdlT3B0aW9ucyB7XG4gIG1lcmdlcj86IChrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0LCBvcHRpb25zPzogQW55T2JqZWN0KSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIG1lcmdlZCBpbnRvLlxuICogQHBhcmFtIHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxuICogQHBhcmFtIFtvcHRpb25zXSAtIE1lcmdpbmcgb3B0aW9uczpcbiAqIEBwYXJhbSBbb3B0aW9ucy5tZXJnZXJdIC0gVGhlIG1lcmdlIG1ldGhvZCAoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcbiAqIEByZXR1cm5zIFRoZSBgdGFyZ2V0YCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogW10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogUzEsIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBbUzFdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxLCBTMj4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzJdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxICYgUzI7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyLCBTMz4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzIsIFMzXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMSAmIFMyICYgUzM7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyLCBTMywgUzQ+KFxuICB0YXJnZXQ6IFQsXG4gIHNvdXJjZTogW1MxLCBTMiwgUzMsIFM0XSxcbiAgb3B0aW9ucz86IE1lcmdlT3B0aW9uc1xuKTogVCAmIFMxICYgUzIgJiBTMyAmIFM0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IEFueU9iamVjdDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBBbnlPYmplY3Qge1xuICBjb25zdCBzb3VyY2VzID0gaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG4gIGNvbnN0IGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcblxuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0IGFzIEFueU9iamVjdDtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBtZXJnZXIgPSBvcHRpb25zLm1lcmdlciB8fCBfbWVyZ2VyO1xuICBsZXQgY3VycmVudDogQW55T2JqZWN0O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VycmVudCA9IHNvdXJjZXNbaV07XG4gICAgaWYgKCFpc09iamVjdChjdXJyZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGN1cnJlbnQpO1xuICAgIGZvciAobGV0IGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIG1lcmdlcihrZXlzW2tdLCB0YXJnZXQsIGN1cnJlbnQsIG9wdGlvbnMgYXMgQW55T2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCAqb25seSogaWYgbm90IGRlZmluZWQgaW4gdGFyZ2V0LlxuICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cbiAqIEBwYXJhbSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cbiAqIEByZXR1cm5zIFRoZSBgdGFyZ2V0YCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQ+KHRhcmdldDogVCwgc291cmNlOiBbXSk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFMxKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBbUzFdKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMl0pOiBUICYgUzEgJiBTMjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxLCBTMiwgUzM+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTM10pOiBUICYgUzEgJiBTMiAmIFMzO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyLCBTMywgUzQ+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTMywgUzRdKTogVCAmIFMxICYgUzIgJiBTMyAmIFM0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdKTogQW55T2JqZWN0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdKTogQW55T2JqZWN0IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICByZXR1cm4gbWVyZ2U8VD4odGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IF9tZXJnZXJJZn0pO1xufVxuXG4vKipcbiAqIE1lcmdlcyBzb3VyY2Vba2V5XSBpbiB0YXJnZXRba2V5XSBvbmx5IGlmIHRhcmdldFtrZXldIGlzIHVuZGVmaW5lZC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VySWYoa2V5OiBzdHJpbmcsIHRhcmdldDogQW55T2JqZWN0LCBzb3VyY2U6IEFueU9iamVjdCkge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlSWYodHZhbCwgc3ZhbCk7XG4gIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lKHN2YWwpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZXByZWNhdGVkKHNjb3BlOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duLCBwcmV2aW91czogc3RyaW5nLCBjdXJyZW50OiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oc2NvcGUgKyAnOiBcIicgKyBwcmV2aW91cyArXG4gICAgICAnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcbiAgfVxufVxuXG4vLyByZXNvbHZlT2JqZWN0S2V5IHJlc29sdmVyIGNhY2hlXG5jb25zdCBrZXlSZXNvbHZlcnMgPSB7XG4gIC8vIENoYXJ0LmhlbHBlcnMuY29yZSByZXNvbHZlT2JqZWN0S2V5IHNob3VsZCByZXNvbHZlIGVtcHR5IGtleSB0byByb290IG9iamVjdFxuICAnJzogdiA9PiB2LFxuICAvLyBkZWZhdWx0IHJlc29sdmVyc1xuICB4OiBvID0+IG8ueCxcbiAgeTogbyA9PiBvLnlcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zcGxpdEtleShrZXk6IHN0cmluZykge1xuICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICBjb25zdCBrZXlzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgdG1wID0gJyc7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIHRtcCArPSBwYXJ0O1xuICAgIGlmICh0bXAuZW5kc1dpdGgoJ1xcXFwnKSkge1xuICAgICAgdG1wID0gdG1wLnNsaWNlKDAsIC0xKSArICcuJztcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cy5wdXNoKHRtcCk7XG4gICAgICB0bXAgPSAnJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9nZXRLZXlSZXNvbHZlcihrZXk6IHN0cmluZykge1xuICBjb25zdCBrZXlzID0gX3NwbGl0S2V5KGtleSk7XG4gIHJldHVybiBvYmogPT4ge1xuICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICBpZiAoayA9PT0gJycpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6XG4gICAgICAgIC8vIENoYXJ0LmhlbHBlcnMuY29yZSByZXNvbHZlT2JqZWN0S2V5IHNob3VsZCBicmVhayBhdCBlbXB0eSBrZXlcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvYmogPSBvYmogJiYgb2JqW2tdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU9iamVjdEtleShvYmo6IEFueU9iamVjdCwga2V5OiBzdHJpbmcpOiBhbnkge1xuICBjb25zdCByZXNvbHZlciA9IGtleVJlc29sdmVyc1trZXldIHx8IChrZXlSZXNvbHZlcnNba2V5XSA9IF9nZXRLZXlSZXNvbHZlcihrZXkpKTtcbiAgcmV0dXJuIHJlc29sdmVyKG9iaik7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cblxuZXhwb3J0IGNvbnN0IGRlZmluZWQgPSAodmFsdWU6IHVua25vd24pID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzExMjg4NTUvY29tcGFyaW5nLWVjbWE2LXNldHMtZm9yLWVxdWFsaXR5IzMxMTI5Mzg0XG5leHBvcnQgY29uc3Qgc2V0c0VxdWFsID0gPFQ+KGE6IFNldDxUPiwgYjogU2V0PFQ+KSA9PiB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgaXRlbSBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gZSAtIFRoZSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0NsaWNrRXZlbnQoZTogQ2hhcnRFdmVudCkge1xuICByZXR1cm4gZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ2NvbnRleHRtZW51Jztcbn1cbiIsICJpbXBvcnQgdHlwZSB7UG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQge2lzRmluaXRlIGFzIGlzRmluaXRlTnVtYmVyfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMubWF0aFxuICogQG5hbWVzcGFjZVxuICovXG5cbmV4cG9ydCBjb25zdCBQSSA9IE1hdGguUEk7XG5leHBvcnQgY29uc3QgVEFVID0gMiAqIFBJO1xuZXhwb3J0IGNvbnN0IFBJVEFVID0gVEFVICsgUEk7XG5leHBvcnQgY29uc3QgSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5leHBvcnQgY29uc3QgUkFEX1BFUl9ERUcgPSBQSSAvIDE4MDtcbmV4cG9ydCBjb25zdCBIQUxGX1BJID0gUEkgLyAyO1xuZXhwb3J0IGNvbnN0IFFVQVJURVJfUEkgPSBQSSAvIDQ7XG5leHBvcnQgY29uc3QgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XG5cbmV4cG9ydCBjb25zdCBsb2cxMCA9IE1hdGgubG9nMTA7XG5leHBvcnQgY29uc3Qgc2lnbiA9IE1hdGguc2lnbjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFsbW9zdEVxdWFscyh4OiBudW1iZXIsIHk6IG51bWJlciwgZXBzaWxvbjogbnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBuaWNlIG51bWJlciBhbGdvcml0aG0gdXNlZCBpbiBkZXRlcm1pbmluZyB3aGVyZSBheGlzIGxhYmVscyB3aWxsIGdvXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuaWNlTnVtKHJhbmdlOiBudW1iZXIpIHtcbiAgY29uc3Qgcm91bmRlZFJhbmdlID0gTWF0aC5yb3VuZChyYW5nZSk7XG4gIHJhbmdlID0gYWxtb3N0RXF1YWxzKHJhbmdlLCByb3VuZGVkUmFuZ2UsIHJhbmdlIC8gMTAwMCkgPyByb3VuZGVkUmFuZ2UgOiByYW5nZTtcbiAgY29uc3QgbmljZVJhbmdlID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAocmFuZ2UpKSk7XG4gIGNvbnN0IGZyYWN0aW9uID0gcmFuZ2UgLyBuaWNlUmFuZ2U7XG4gIGNvbnN0IG5pY2VGcmFjdGlvbiA9IGZyYWN0aW9uIDw9IDEgPyAxIDogZnJhY3Rpb24gPD0gMiA/IDIgOiBmcmFjdGlvbiA8PSA1ID8gNSA6IDEwO1xuICByZXR1cm4gbmljZUZyYWN0aW9uICogbmljZVJhbmdlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgZmFjdG9ycyBzb3J0ZWQgZnJvbSAxIHRvIHNxcnQodmFsdWUpXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ZhY3Rvcml6ZSh2YWx1ZTogbnVtYmVyKSB7XG4gIGNvbnN0IHJlc3VsdDogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgc3FydCA9IE1hdGguc3FydCh2YWx1ZSk7XG4gIGxldCBpOiBudW1iZXI7XG5cbiAgZm9yIChpID0gMTsgaSA8IHNxcnQ7IGkrKykge1xuICAgIGlmICh2YWx1ZSAlIGkgPT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUgLyBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNxcnQgPT09IChzcXJ0IHwgMCkpIHsgLy8gaWYgdmFsdWUgaXMgYSBzcXVhcmUgbnVtYmVyXG4gICAgcmVzdWx0LnB1c2goc3FydCk7XG4gIH1cblxuICByZXN1bHQuc29ydCgoYSwgYikgPT4gYSAtIGIpLnBvcCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobjogdW5rbm93bik6IG4gaXMgbnVtYmVyIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4gYXMgc3RyaW5nKSkgJiYgaXNGaW5pdGUobiBhcyBudW1iZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxtb3N0V2hvbGUoeDogbnVtYmVyLCBlcHNpbG9uOiBudW1iZXIpIHtcbiAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG4gIHJldHVybiAoKHJvdW5kZWQgLSBlcHNpbG9uKSA8PSB4KSAmJiAoKHJvdW5kZWQgKyBlcHNpbG9uKSA+PSB4KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NldE1pbkFuZE1heEJ5S2V5KFxuICBhcnJheTogUmVjb3JkPHN0cmluZywgbnVtYmVyPltdLFxuICB0YXJnZXQ6IHsgbWluOiBudW1iZXIsIG1heDogbnVtYmVyIH0sXG4gIHByb3BlcnR5OiBzdHJpbmdcbikge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHZhbHVlOiBudW1iZXI7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIHZhbHVlID0gYXJyYXlbaV1bcHJvcGVydHldO1xuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICB0YXJnZXQubWluID0gTWF0aC5taW4odGFyZ2V0Lm1pbiwgdmFsdWUpO1xuICAgICAgdGFyZ2V0Lm1heCA9IE1hdGgubWF4KHRhcmdldC5tYXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzOiBudW1iZXIpIHtcbiAgcmV0dXJuIGRlZ3JlZXMgKiAoUEkgLyAxODApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnM6IG51bWJlcikge1xuICByZXR1cm4gcmFkaWFucyAqICgxODAgLyBQSSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gKiBpLmUuIHRoZSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBOdW1iZXIuXG4gKiBAcGFyYW0geCAtIEEgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVjaW1hbFBsYWNlcyh4OiBudW1iZXIpIHtcbiAgaWYgKCFpc0Zpbml0ZU51bWJlcih4KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZSA9IDE7XG4gIGxldCBwID0gMDtcbiAgd2hpbGUgKE1hdGgucm91bmQoeCAqIGUpIC8gZSAhPT0geCkge1xuICAgIGUgKj0gMTA7XG4gICAgcCsrO1xuICB9XG4gIHJldHVybiBwO1xufVxuXG4vLyBHZXRzIHRoZSBhbmdsZSBmcm9tIHZlcnRpY2FsIHVwcmlnaHQgdG8gdGhlIHBvaW50IGFib3V0IGEgY2VudHJlLlxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuZ2xlRnJvbVBvaW50KFxuICBjZW50cmVQb2ludDogUG9pbnQsXG4gIGFuZ2xlUG9pbnQ6IFBvaW50XG4pIHtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVlDZW50ZXIgPSBhbmdsZVBvaW50LnkgLSBjZW50cmVQb2ludC55O1xuICBjb25zdCByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIgPSBNYXRoLnNxcnQoZGlzdGFuY2VGcm9tWENlbnRlciAqIGRpc3RhbmNlRnJvbVhDZW50ZXIgKyBkaXN0YW5jZUZyb21ZQ2VudGVyICogZGlzdGFuY2VGcm9tWUNlbnRlcik7XG5cbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcblxuICBpZiAoYW5nbGUgPCAoLTAuNSAqIFBJKSkge1xuICAgIGFuZ2xlICs9IFRBVTsgLy8gbWFrZSBzdXJlIHRoZSByZXR1cm5lZCBhbmdsZSBpcyBpbiB0aGUgcmFuZ2Ugb2YgKC1QSS8yLCAzUEkvMl1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYW5nbGUsXG4gICAgZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHB0MTogUG9pbnQsIHB0MjogUG9pbnQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcbn1cblxuLyoqXG4gKiBTaG9ydGVzdCBkaXN0YW5jZSBiZXR3ZWVuIGFuZ2xlcywgaW4gZWl0aGVyIGRpcmVjdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYW5nbGVEaWZmKGE6IG51bWJlciwgYjogbnVtYmVyKSB7XG4gIHJldHVybiAoYSAtIGIgKyBQSVRBVSkgJSBUQVUgLSBQSTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYW5nbGUgdG8gYmUgYmV0d2VlbiAwIGFuZCAyKlBJXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX25vcm1hbGl6ZUFuZ2xlKGE6IG51bWJlcikge1xuICByZXR1cm4gKGEgJSBUQVUgKyBUQVUpICUgVEFVO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYW5nbGVCZXR3ZWVuKGFuZ2xlOiBudW1iZXIsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBzYW1lQW5nbGVJc0Z1bGxDaXJjbGU/OiBib29sZWFuKSB7XG4gIGNvbnN0IGEgPSBfbm9ybWFsaXplQW5nbGUoYW5nbGUpO1xuICBjb25zdCBzID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgY29uc3QgZSA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICBjb25zdCBhbmdsZVRvU3RhcnQgPSBfbm9ybWFsaXplQW5nbGUocyAtIGEpO1xuICBjb25zdCBhbmdsZVRvRW5kID0gX25vcm1hbGl6ZUFuZ2xlKGUgLSBhKTtcbiAgY29uc3Qgc3RhcnRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBzKTtcbiAgY29uc3QgZW5kVG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gZSk7XG4gIHJldHVybiBhID09PSBzIHx8IGEgPT09IGUgfHwgKHNhbWVBbmdsZUlzRnVsbENpcmNsZSAmJiBzID09PSBlKVxuICAgIHx8IChhbmdsZVRvU3RhcnQgPiBhbmdsZVRvRW5kICYmIHN0YXJ0VG9BbmdsZSA8IGVuZFRvQW5nbGUpO1xufVxuXG4vKipcbiAqIExpbWl0IGB2YWx1ZWAgYmV0d2VlbiBgbWluYCBhbmQgYG1heGBcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9saW1pdFZhbHVlKHZhbHVlOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ludDE2UmFuZ2UodmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gX2xpbWl0VmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIHN0YXJ0XG4gKiBAcGFyYW0gZW5kXG4gKiBAcGFyYW0gW2Vwc2lsb25dXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzQmV0d2Vlbih2YWx1ZTogbnVtYmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgZXBzaWxvbiA9IDFlLTYpIHtcbiAgcmV0dXJuIHZhbHVlID49IE1hdGgubWluKHN0YXJ0LCBlbmQpIC0gZXBzaWxvbiAmJiB2YWx1ZSA8PSBNYXRoLm1heChzdGFydCwgZW5kKSArIGVwc2lsb247XG59XG4iLCAiaW1wb3J0IHtfY2FwaXRhbGl6ZX0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIGNtcFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9sb29rdXAoXG4gIHRhYmxlOiBudW1iZXJbXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbik6IHtsbzogbnVtYmVyLCBoaTogbnVtYmVyfTtcbmV4cG9ydCBmdW5jdGlvbiBfbG9va3VwPFQ+KFxuICB0YWJsZTogVFtdLFxuICB2YWx1ZTogbnVtYmVyLFxuICBjbXA6ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pOiB7bG86IG51bWJlciwgaGk6IG51bWJlcn07XG5leHBvcnQgZnVuY3Rpb24gX2xvb2t1cChcbiAgdGFibGU6IHVua25vd25bXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbikge1xuICBjbXAgPSBjbXAgfHwgKChpbmRleCkgPT4gdGFibGVbaW5kZXhdIDwgdmFsdWUpO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgbG8gPSAwO1xuICBsZXQgbWlkOiBudW1iZXI7XG5cbiAgd2hpbGUgKGhpIC0gbG8gPiAxKSB7XG4gICAgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgaWYgKGNtcChtaWQpKSB7XG4gICAgICBsbyA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtsbywgaGl9O1xufVxuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcGFyYW0gbGFzdCAtIGxvb2t1cCBsYXN0IGluZGV4XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX2xvb2t1cEJ5S2V5ID0gKFxuICB0YWJsZTogUmVjb3JkPHN0cmluZywgbnVtYmVyPltdLFxuICBrZXk6IHN0cmluZyxcbiAgdmFsdWU6IG51bWJlcixcbiAgbGFzdD86IGJvb2xlYW5cbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGxhc3RcbiAgICA/IGluZGV4ID0+IHtcbiAgICAgIGNvbnN0IHRpID0gdGFibGVbaW5kZXhdW2tleV07XG4gICAgICByZXR1cm4gdGkgPCB2YWx1ZSB8fCB0aSA9PT0gdmFsdWUgJiYgdGFibGVbaW5kZXggKyAxXVtrZXldID09PSB2YWx1ZTtcbiAgICB9XG4gICAgOiBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA8IHZhbHVlKTtcblxuLyoqXG4gKiBSZXZlcnNlIGJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3Jsb29rdXBCeUtleSA9IChcbiAgdGFibGU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAga2V5OiBzdHJpbmcsXG4gIHZhbHVlOiBudW1iZXJcbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldID49IHZhbHVlKTtcblxuLyoqXG4gKiBSZXR1cm4gc3Vic2V0IG9mIGB2YWx1ZXNgIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIGluY2x1c2l2ZS5cbiAqIFZhbHVlcyBhcmUgYXNzdW1lZCB0byBiZSBpbiBzb3J0ZWQgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWVzIC0gc29ydGVkIGFycmF5IG9mIHZhbHVlc1xuICogQHBhcmFtIG1pbiAtIG1pbiB2YWx1ZVxuICogQHBhcmFtIG1heCAtIG1heCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ZpbHRlckJldHdlZW4odmFsdWVzOiBudW1iZXJbXSwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KSB7XG4gICAgZW5kLS07XG4gIH1cblxuICByZXR1cm4gc3RhcnQgPiAwIHx8IGVuZCA8IHZhbHVlcy5sZW5ndGhcbiAgICA/IHZhbHVlcy5zbGljZShzdGFydCwgZW5kKVxuICAgIDogdmFsdWVzO1xufVxuXG5jb25zdCBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSBhcyBjb25zdDtcblxuZXhwb3J0IGludGVyZmFjZSBBcnJheUxpc3RlbmVyPFQ+IHtcbiAgX29uRGF0YVB1c2g/KC4uLml0ZW06IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFQb3A/KCk6IHZvaWQ7XG4gIF9vbkRhdGFTaGlmdD8oKTogdm9pZDtcbiAgX29uRGF0YVNwbGljZT8oaW5kZXg6IG51bWJlciwgZGVsZXRlQ291bnQ6IG51bWJlciwgLi4uaXRlbXM6IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFVbnNoaWZ0PyguLi5pdGVtOiBUW10pOiB2b2lkO1xufVxuXG4vKipcbiAqIEhvb2tzIHRoZSBhcnJheSBtZXRob2RzIHRoYXQgYWRkIG9yIHJlbW92ZSB2YWx1ZXMgKCdwdXNoJywgcG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsXG4gKiAndW5zaGlmdCcpIGFuZCBub3RpZnkgdGhlIGxpc3RlbmVyIEFGVEVSIHRoZSBhcnJheSBoYXMgYmVlbiBhbHRlcmVkLiBMaXN0ZW5lcnMgYXJlXG4gKiBjYWxsZWQgb24gdGhlICdfb25EYXRhKicgY2FsbGJhY2tzIChlLmcuIF9vbkRhdGFQdXNoLCBldGMuKSB3aXRoIHNhbWUgYXJndW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHM8VD4oYXJyYXk6IFRbXSwgbGlzdGVuZXI6IEFycmF5TGlzdGVuZXI8VD4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBpZiAoYXJyYXkuX2NoYXJ0anMpIHtcbiAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB7XG4gICAgICBsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cbiAgICB9XG4gIH0pO1xuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdfb25EYXRhJyArIF9jYXBpdGFsaXplKGtleSk7XG4gICAgY29uc3QgYmFzZSA9IGFycmF5W2tleV07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJhc2UuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAgICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLmZvckVhY2goKG9iamVjdCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBhcnJheSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW51cCBleHRyYSBhdHRhY2hlZCBwcm9wZXJ0aWVzIChzdWNoIGFzXG4gKiB0aGUgX2NoYXJ0anMgc3R1YiBhbmQgb3ZlcnJpZGRlbiBtZXRob2RzKSBpZiBhcnJheSBkb2Vzbid0IGhhdmUgYW55IG1vcmUgbGlzdGVuZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50czxUPihhcnJheTogVFtdLCBsaXN0ZW5lcjogQXJyYXlMaXN0ZW5lcjxUPik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuICBpZiAoIXN0dWIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcbiAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuXG4gIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlbGV0ZSBhcnJheVtrZXldO1xuICB9KTtcblxuICBkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5cbi8qKlxuICogQHBhcmFtIGl0ZW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYXJyYXlVbmlxdWU8VD4oaXRlbXM6IFRbXSkge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0PFQ+KGl0ZW1zKTtcblxuICBpZiAoc2V0LnNpemUgPT09IGl0ZW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG4iLCAiaW1wb3J0IHR5cGUge0NoYXJ0TWV0YSwgUG9pbnRFbGVtZW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmltcG9ydCB7X2xpbWl0VmFsdWV9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2xvb2t1cEJ5S2V5fSBmcm9tICcuL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmb250U3RyaW5nKHBpeGVsU2l6ZTogbnVtYmVyLCBmb250U3R5bGU6IHN0cmluZywgZm9udEZhbWlseTogc3RyaW5nKSB7XG4gIHJldHVybiBmb250U3R5bGUgKyAnICcgKyBwaXhlbFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG59XG5cbi8qKlxuKiBSZXF1ZXN0IGFuaW1hdGlvbiBwb2x5ZmlsbFxuKi9cbmV4cG9ydCBjb25zdCByZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG59KCkpO1xuXG4vKipcbiAqIFRocm90dGxlcyBjYWxsaW5nIGBmbmAgb25jZSBwZXIgYW5pbWF0aW9uIGZyYW1lXG4gKiBMYXRlc3QgYXJndW1lbnRzIGFyZSB1c2VkIG9uIHRoZSBhY3R1YWwgY2FsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGVkPFRBcmdzIGV4dGVuZHMgQXJyYXk8YW55Pj4oXG4gIGZuOiAoLi4uYXJnczogVEFyZ3MpID0+IHZvaWQsXG4gIHRoaXNBcmc6IGFueSxcbikge1xuICBsZXQgYXJnc1RvVXNlID0gW10gYXMgVEFyZ3M7XG4gIGxldCB0aWNraW5nID0gZmFsc2U7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3M6IFRBcmdzKSB7XG4gICAgLy8gU2F2ZSB0aGUgYXJncyBmb3IgdXNlIGxhdGVyXG4gICAgYXJnc1RvVXNlID0gYXJncztcbiAgICBpZiAoIXRpY2tpbmcpIHtcbiAgICAgIHRpY2tpbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgICB0aWNraW5nID0gZmFsc2U7XG4gICAgICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3NUb1VzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRGVib3VuY2VzIGNhbGxpbmcgYGZuYCBmb3IgYGRlbGF5YCBtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2U8VEFyZ3MgZXh0ZW5kcyBBcnJheTxhbnk+PihmbjogKC4uLmFyZ3M6IFRBcmdzKSA9PiB2b2lkLCBkZWxheTogbnVtYmVyKSB7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJnczogVEFyZ3MpIHtcbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gZGVsYXk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgJ3N0YXJ0JyB0byAnbGVmdCcsICdlbmQnIHRvICdyaWdodCcgYW5kIG90aGVycyB0byAnY2VudGVyJ1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF90b0xlZnRSaWdodENlbnRlciA9IChhbGlnbjogJ3N0YXJ0JyB8ICdlbmQnIHwgJ2NlbnRlcicpID0+IGFsaWduID09PSAnc3RhcnQnID8gJ2xlZnQnIDogYWxpZ24gPT09ICdlbmQnID8gJ3JpZ2h0JyA6ICdjZW50ZXInO1xuXG4vKipcbiAqIFJldHVybnMgYHN0YXJ0YCwgYGVuZGAgb3IgYChzdGFydCArIGVuZCkgLyAyYCBkZXBlbmRpbmcgb24gYGFsaWduYC4gRGVmYXVsdHMgdG8gYGNlbnRlcmBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBfYWxpZ25TdGFydEVuZCA9IChhbGlnbjogJ3N0YXJ0JyB8ICdlbmQnIHwgJ2NlbnRlcicsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogYWxpZ24gPT09ICdlbmQnID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XG5cbi8qKlxuICogUmV0dXJucyBgbGVmdGAsIGByaWdodGAgb3IgYChsZWZ0ICsgcmlnaHQpIC8gMmAgZGVwZW5kaW5nIG9uIGBhbGlnbmAuIERlZmF1bHRzIHRvIGBsZWZ0YFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF90ZXh0WCA9IChhbGlnbjogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInLCBsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIHJ0bDogYm9vbGVhbikgPT4ge1xuICBjb25zdCBjaGVjayA9IHJ0bCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIHJldHVybiBhbGlnbiA9PT0gY2hlY2sgPyByaWdodCA6IGFsaWduID09PSAnY2VudGVyJyA/IChsZWZ0ICsgcmlnaHQpIC8gMiA6IGxlZnQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBzdGFydCBhbmQgY291bnQgb2YgdmlzaWJsZSBwb2ludHMuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YTogQ2hhcnRNZXRhPCdsaW5lJyB8ICdzY2F0dGVyJz4sIHBvaW50czogUG9pbnRFbGVtZW50W10sIGFuaW1hdGlvbnNEaXNhYmxlZDogYm9vbGVhbikge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcblxuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQgPSBwb2ludENvdW50O1xuXG4gIGlmIChtZXRhLl9zb3J0ZWQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCBfcGFyc2VkfSA9IG1ldGE7XG4gICAgY29uc3QgYXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuXG4gICAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoTWF0aC5taW4oXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byB0eXBlIF9wYXJzZWRcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGF4aXMsIG1pbikubG8sXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byBmaXggdHlwZXMgb24gX2xvb2t1cEJ5S2V5XG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IHBvaW50Q291bnQgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtaW4pKS5sbyksXG4gICAgICAwLCBwb2ludENvdW50IC0gMSk7XG4gICAgfVxuICAgIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgICBjb3VudCA9IF9saW1pdFZhbHVlKE1hdGgubWF4KFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBpU2NhbGUuYXhpcywgbWF4LCB0cnVlKS5oaSArIDEsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byBmaXggdHlwZXMgb24gX2xvb2t1cEJ5S2V5XG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IDAgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtYXgpLCB0cnVlKS5oaSArIDEpLFxuICAgICAgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNjYWxlIHJhbmdlcyBoYXZlIGNoYW5nZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkge1xuICBjb25zdCB7eFNjYWxlLCB5U2NhbGUsIF9zY2FsZVJhbmdlc30gPSBtZXRhO1xuICBjb25zdCBuZXdSYW5nZXMgPSB7XG4gICAgeG1pbjogeFNjYWxlLm1pbixcbiAgICB4bWF4OiB4U2NhbGUubWF4LFxuICAgIHltaW46IHlTY2FsZS5taW4sXG4gICAgeW1heDogeVNjYWxlLm1heFxuICB9O1xuICBpZiAoIV9zY2FsZVJhbmdlcykge1xuICAgIG1ldGEuX3NjYWxlUmFuZ2VzID0gbmV3UmFuZ2VzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGNoYW5nZWQgPSBfc2NhbGVSYW5nZXMueG1pbiAhPT0geFNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy54bWF4ICE9PSB4U2NhbGUubWF4XG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltaW4gIT09IHlTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueW1heCAhPT0geVNjYWxlLm1heDtcblxuICBPYmplY3QuYXNzaWduKF9zY2FsZVJhbmdlcywgbmV3UmFuZ2VzKTtcbiAgcmV0dXJuIGNoYW5nZWQ7XG59XG4iLCAiaW1wb3J0IHtQSSwgVEFVLCBIQUxGX1BJfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5cbmNvbnN0IGF0RWRnZSA9ICh0OiBudW1iZXIpID0+IHQgPT09IDAgfHwgdCA9PT0gMTtcbmNvbnN0IGVsYXN0aWNJbiA9ICh0OiBudW1iZXIsIHM6IG51bWJlciwgcDogbnVtYmVyKSA9PiAtKE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApKTtcbmNvbnN0IGVsYXN0aWNPdXQgPSAodDogbnVtYmVyLCBzOiBudW1iZXIsIHA6IG51bWJlcikgPT4gTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkgKyAxO1xuXG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBlYXNpbmcgZXF1YXRpb25zLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmVhc2luZy5lZmZlY3RzXG4gKiBAc2VlIGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcvXG4gKi9cbmNvbnN0IGVmZmVjdHMgPSB7XG4gIGxpbmVhcjogKHQ6IG51bWJlcikgPT4gdCxcblxuICBlYXNlSW5RdWFkOiAodDogbnVtYmVyKSA9PiB0ICogdCxcblxuICBlYXNlT3V0UXVhZDogKHQ6IG51bWJlcikgPT4gLXQgKiAodCAtIDIpLFxuXG4gIGVhc2VJbk91dFF1YWQ6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0XG4gICAgOiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpLFxuXG4gIGVhc2VJbkN1YmljOiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQsXG5cbiAgZWFzZU91dEN1YmljOiAodDogbnVtYmVyKSA9PiAodCAtPSAxKSAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRDdWJpYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuXG4gIGVhc2VJblF1YXJ0OiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWFydDogKHQ6IG51bWJlcikgPT4gLSgodCAtPSAxKSAqIHQgKiB0ICogdCAtIDEpLFxuXG4gIGVhc2VJbk91dFF1YXJ0OiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG5cbiAgZWFzZUluUXVpbnQ6ICh0OiBudW1iZXIpID0+IHQgKiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWludDogKHQ6IG51bWJlcikgPT4gKHQgLT0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRRdWludDogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcblxuICBlYXNlSW5TaW5lOiAodDogbnVtYmVyKSA9PiAtTWF0aC5jb3ModCAqIEhBTEZfUEkpICsgMSxcblxuICBlYXNlT3V0U2luZTogKHQ6IG51bWJlcikgPT4gTWF0aC5zaW4odCAqIEhBTEZfUEkpLFxuXG4gIGVhc2VJbk91dFNpbmU6ICh0OiBudW1iZXIpID0+IC0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuXG4gIGVhc2VJbkV4cG86ICh0OiBudW1iZXIpID0+ICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuXG4gIGVhc2VPdXRFeHBvOiAodDogbnVtYmVyKSA9PiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcblxuICBlYXNlSW5PdXRFeHBvOiAodDogbnVtYmVyKSA9PiBhdEVkZ2UodCkgPyB0IDogdCA8IDAuNVxuICAgID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSlcbiAgICA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpICsgMiksXG5cbiAgZWFzZUluQ2lyYzogKHQ6IG51bWJlcikgPT4gKHQgPj0gMSkgPyB0IDogLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpLFxuXG4gIGVhc2VPdXRDaXJjOiAodDogbnVtYmVyKSA9PiBNYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG5cbiAgZWFzZUluT3V0Q2lyYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpXG4gICAgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSksXG5cbiAgZWFzZUluRWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNJbih0LCAwLjA3NSwgMC4zKSxcblxuICBlYXNlT3V0RWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG5cbiAgZWFzZUluT3V0RWxhc3RpYyh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBzID0gMC4xMTI1O1xuICAgIGNvbnN0IHAgPSAwLjQ1O1xuICAgIHJldHVybiBhdEVkZ2UodCkgPyB0IDpcbiAgICAgIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKiBlbGFzdGljSW4odCAqIDIsIHMsIHApXG4gICAgICAgIDogMC41ICsgMC41ICogZWxhc3RpY091dCh0ICogMiAtIDEsIHMsIHApO1xuICB9LFxuXG4gIGVhc2VJbkJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH0sXG5cbiAgZWFzZU91dEJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuICh0IC09IDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbiAgfSxcblxuICBlYXNlSW5PdXRCYWNrKHQ6IG51bWJlcikge1xuICAgIGxldCBzID0gMS43MDE1ODtcbiAgICBpZiAoKHQgLz0gMC41KSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuICAgIH1cbiAgICByZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuICB9LFxuXG4gIGVhc2VJbkJvdW5jZTogKHQ6IG51bWJlcikgPT4gMSAtIGVmZmVjdHMuZWFzZU91dEJvdW5jZSgxIC0gdCksXG5cbiAgZWFzZU91dEJvdW5jZSh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBtID0gNy41NjI1O1xuICAgIGNvbnN0IGQgPSAyLjc1O1xuICAgIGlmICh0IDwgKDEgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiB0ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAoMiAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgxLjUgLyBkKSkgKiB0ICsgMC43NTtcbiAgICB9XG4gICAgaWYgKHQgPCAoMi41IC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDIuMjUgLyBkKSkgKiB0ICsgMC45Mzc1O1xuICAgIH1cbiAgICByZXR1cm4gbSAqICh0IC09ICgyLjYyNSAvIGQpKSAqIHQgKyAwLjk4NDM3NTtcbiAgfSxcblxuICBlYXNlSW5PdXRCb3VuY2U6ICh0OiBudW1iZXIpID0+ICh0IDwgMC41KVxuICAgID8gZWZmZWN0cy5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41XG4gICAgOiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCB0eXBlIEVhc2luZ0Z1bmN0aW9uID0ga2V5b2YgdHlwZW9mIGVmZmVjdHNcblxuZXhwb3J0IGRlZmF1bHQgZWZmZWN0cztcbiIsICJpbXBvcnQge0NvbG9yfSBmcm9tICdAa3Vya2xlL2NvbG9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBDYW52YXNQYXR0ZXJuIHwgQ2FudmFzR3JhZGllbnQge1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHR5cGUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIHJldHVybiB0eXBlID09PSAnW29iamVjdCBDYW52YXNQYXR0ZXJuXScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlOiBDYW52YXNHcmFkaWVudCk6IENhbnZhc0dyYWRpZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlOiBDYW52YXNQYXR0ZXJuKTogQ2FudmFzUGF0dGVybjtcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcihcbiAgdmFsdWU6XG4gIHwgc3RyaW5nXG4gIHwgeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyOyBhOiBudW1iZXIgfVxuICB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXVxuICB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdXG4pOiBDb2xvcjtcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkgPyB2YWx1ZSA6IG5ldyBDb2xvcih2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlOiBDYW52YXNHcmFkaWVudCk6IENhbnZhc0dyYWRpZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IENhbnZhc1BhdHRlcm4pOiBDYW52YXNQYXR0ZXJuO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IHN0cmluZyk6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IG5ldyBDb2xvcih2YWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5oZXhTdHJpbmcoKTtcbn1cbiIsICJjb25zdCBudW1iZXJzID0gWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJywgJ3RlbnNpb24nXTtcbmNvbnN0IGNvbG9ycyA9IFsnY29sb3InLCAnYm9yZGVyQ29sb3InLCAnYmFja2dyb3VuZENvbG9yJ107XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUFuaW1hdGlvbnNEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbicsIHtcbiAgICBkZWxheTogdW5kZWZpbmVkLFxuICAgIGR1cmF0aW9uOiAxMDAwLFxuICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgZm46IHVuZGVmaW5lZCxcbiAgICBmcm9tOiB1bmRlZmluZWQsXG4gICAgbG9vcDogdW5kZWZpbmVkLFxuICAgIHRvOiB1bmRlZmluZWQsXG4gICAgdHlwZTogdW5kZWZpbmVkLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9uJywge1xuICAgIF9mYWxsYmFjazogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnb25Qcm9ncmVzcycgJiYgbmFtZSAhPT0gJ29uQ29tcGxldGUnICYmIG5hbWUgIT09ICdmbicsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLnNldCgnYW5pbWF0aW9ucycsIHtcbiAgICBjb2xvcnM6IHtcbiAgICAgIHR5cGU6ICdjb2xvcicsXG4gICAgICBwcm9wZXJ0aWVzOiBjb2xvcnNcbiAgICB9LFxuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogbnVtYmVyc1xuICAgIH0sXG4gIH0pO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb25zJywge1xuICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbicsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLnNldCgndHJhbnNpdGlvbnMnLCB7XG4gICAgYWN0aXZlOiB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDQwMFxuICAgICAgfVxuICAgIH0sXG4gICAgcmVzaXplOiB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3c6IHtcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgZnJvbTogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9LFxuICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGR1cmF0aW9uOiAwIC8vIHNob3cgaW1tZWRpYXRlbHlcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9LFxuICAgIGhpZGU6IHtcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgdG86ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJsZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICAgIGZuOiB2ID0+IHYgfCAwIC8vIGZvciBrZWVwaW5nIHRoZSBkYXRhc2V0IHZpc2libGUgYWxsIHRoZSB3YXkgdGhyb3VnaCB0aGUgYW5pbWF0aW9uXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gYXBwbHlMYXlvdXRzRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgZGVmYXVsdHMuc2V0KCdsYXlvdXQnLCB7XG4gICAgYXV0b1BhZGRpbmc6IHRydWUsXG4gICAgcGFkZGluZzoge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfVxuICB9KTtcbn1cbiIsICJcbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBJbnRsLk51bWJlckZvcm1hdD4oKTtcblxuZnVuY3Rpb24gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZTogc3RyaW5nLCBvcHRpb25zPzogSW50bC5OdW1iZXJGb3JtYXRPcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBjYWNoZUtleSA9IGxvY2FsZSArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICBsZXQgZm9ybWF0dGVyID0gaW50bENhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghZm9ybWF0dGVyKSB7XG4gICAgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgaW50bENhY2hlLnNldChjYWNoZUtleSwgZm9ybWF0dGVyKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bTogbnVtYmVyLCBsb2NhbGU6IHN0cmluZywgb3B0aW9ucz86IEludGwuTnVtYmVyRm9ybWF0T3B0aW9ucykge1xuICByZXR1cm4gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KG51bSk7XG59XG4iLCAiaW1wb3J0IHtpc0FycmF5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuaW1wb3J0IHtsb2cxMH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIE5hbWVzcGFjZSB0byBob2xkIGZvcm1hdHRlcnMgZm9yIGRpZmZlcmVudCB0eXBlcyBvZiB0aWNrc1xuICogQG5hbWVzcGFjZSBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzXG4gKi9cbmNvbnN0IGZvcm1hdHRlcnMgPSB7XG4gIC8qKlxuICAgKiBGb3JtYXR0ZXIgZm9yIHZhbHVlIGxhYmVsc1xuICAgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMudmFsdWVzXG4gICAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gZGlzcGxheVxuICAgKiBAcmV0dXJuIHtzdHJpbmd8c3RyaW5nW119IHRoZSBsYWJlbCB0byBkaXNwbGF5XG4gICAqL1xuICB2YWx1ZXModmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyAvKiogQHR5cGUge3N0cmluZ1tdfSAqLyAodmFsdWUpIDogJycgKyB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciBudW1lcmljIHRpY2tzXG4gICAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAqIEBwYXJhbSB0aWNrVmFsdWUge251bWJlcn0gdGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyIGluIHRoZSB0aWNrcyBhcnJheVxuICAgKiBAcGFyYW0gdGlja3Mge29iamVjdFtdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXJcbiAgICovXG4gIG51bWVyaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnOyAvLyBuZXZlciBzaG93IGRlY2ltYWwgcGxhY2VzIGZvciAwXG4gICAgfVxuXG4gICAgY29uc3QgbG9jYWxlID0gdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZTtcbiAgICBsZXQgbm90YXRpb247XG4gICAgbGV0IGRlbHRhID0gdGlja1ZhbHVlOyAvLyBUaGlzIGlzIHVzZWQgd2hlbiB0aGVyZSBhcmUgbGVzcyB0aGFuIDIgdGlja3MgYXMgdGhlIHRpY2sgaW50ZXJ2YWwuXG5cbiAgICBpZiAodGlja3MubGVuZ3RoID4gMSkge1xuICAgICAgLy8gYWxsIHRpY2tzIGFyZSBzbWFsbCBvciB0aGVyZSBodWdlIG51bWJlcnM7IHVzZSBzY2llbnRpZmljIG5vdGF0aW9uXG4gICAgICBjb25zdCBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0udmFsdWUpLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSkpO1xuICAgICAgaWYgKG1heFRpY2sgPCAxZS00IHx8IG1heFRpY2sgPiAxZSsxNSkge1xuICAgICAgICBub3RhdGlvbiA9ICdzY2llbnRpZmljJztcbiAgICAgIH1cblxuICAgICAgZGVsdGEgPSBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dEZWx0YSA9IGxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG5cbiAgICAvLyBXaGVuIGRhdGFzZXRzIGhhdmUgdmFsdWVzIGFwcHJvYWNoaW5nIE51bWJlci5NQVhfVkFMVUUsIHRoZSB0aWNrIGNhbGN1bGF0aW9ucyBtaWdodCByZXN1bHQgaW5cbiAgICAvLyBpbmZpbml0eSBhbmQgZXZlbnR1YWxseSBOYU4uIFBhc3NpbmcgTmFOIGZvciBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgb3IgbWF4aW11bUZyYWN0aW9uRGlnaXRzXG4gICAgLy8gd2lsbCBtYWtlIHRoZSBudW1iZXIgZm9ybWF0dGVyIHRocm93LiBTbyBpbnN0ZWFkIHdlIGNoZWNrIGZvciBpc05hTiBhbmQgdXNlIGEgZmFsbGJhY2sgdmFsdWUuXG4gICAgLy9cbiAgICAvLyB0b0ZpeGVkIGhhcyBhIG1heCBvZiAyMCBkZWNpbWFsIHBsYWNlc1xuICAgIGNvbnN0IG51bURlY2ltYWwgPSBpc05hTihsb2dEZWx0YSkgPyAxIDogTWF0aC5tYXgoTWF0aC5taW4oLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKSwgMjApLCAwKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7bm90YXRpb24sIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbCwgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsfTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuXG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih0aWNrVmFsdWUsIGxvY2FsZSwgb3B0aW9ucyk7XG4gIH0sXG5cblxuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciBsb2dhcml0aG1pYyB0aWNrc1xuICAgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWNcbiAgICogQHBhcmFtIHRpY2tWYWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXIgaW4gdGhlIHRpY2tzIGFycmF5XG4gICAqIEBwYXJhbSB0aWNrcyB7b2JqZWN0W119IHRoZSBsaXN0IG9mIHRpY2tzIGJlaW5nIGNvbnZlcnRlZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuICAgKi9cbiAgbG9nYXJpdGhtaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCByZW1haW4gPSB0aWNrc1tpbmRleF0uc2lnbmlmaWNhbmQgfHwgKHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsdWUpKSkpKTtcbiAgICBpZiAoWzEsIDIsIDMsIDUsIDEwLCAxNV0uaW5jbHVkZXMocmVtYWluKSB8fCBpbmRleCA+IDAuOCAqIHRpY2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMubnVtZXJpYy5jYWxsKHRoaXMsIHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbn07XG5cblxuZnVuY3Rpb24gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcykge1xuICAvLyBGaWd1cmUgb3V0IGhvdyBtYW55IGRpZ2l0cyB0byBzaG93XG4gIC8vIFRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBmaXJzdCB0d28gdGlja3MgbWlnaHQgYmUgc21hbGxlciB0aGFuIG5vcm1hbCBzcGFjaW5nXG4gIGxldCBkZWx0YSA9IHRpY2tzLmxlbmd0aCA+IDMgPyB0aWNrc1syXS52YWx1ZSAtIHRpY2tzWzFdLnZhbHVlIDogdGlja3NbMV0udmFsdWUgLSB0aWNrc1swXS52YWx1ZTtcblxuICAvLyBJZiB3ZSBoYXZlIGEgbnVtYmVyIGxpa2UgMi41IGFzIHRoZSBkZWx0YSwgZmlndXJlIG91dCBob3cgbWFueSBkZWNpbWFsIHBsYWNlcyB3ZSBuZWVkXG4gIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMSAmJiB0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuICAgIC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxuXG4vKipcbiAqIE5hbWVzcGFjZSB0byBob2xkIHN0YXRpYyB0aWNrIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtmb3JtYXR0ZXJzfTtcbiIsICJpbXBvcnQgVGlja3MgZnJvbSAnLi9jb3JlLnRpY2tzLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U2NhbGVEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ3NjYWxlJywge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgb2Zmc2V0OiBmYWxzZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICBiZWdpbkF0WmVybzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXG4gICAgICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG4gICAgICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKi9cbiAgICBib3VuZHM6ICd0aWNrcycsXG5cbiAgICBjbGlwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb24gZ3JhY2UgYWRkZWQgdG8gbWF4IGFuZCByZWR1Y2VkIGZyb20gbWluIGRhdGEgdmFsdWUuXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICovXG4gICAgZ3JhY2U6IDAsXG5cbiAgICAvLyBncmlkIGxpbmUgc2V0dGluZ3NcbiAgICBncmlkOiB7XG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuICAgICAgZHJhd1RpY2tzOiB0cnVlLFxuICAgICAgdGlja0xlbmd0aDogOCxcbiAgICAgIHRpY2tXaWR0aDogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMubGluZVdpZHRoLFxuICAgICAgdGlja0NvbG9yOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5jb2xvcixcbiAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgfSxcblxuICAgIGJvcmRlcjoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGRhc2g6IFtdLFxuICAgICAgZGFzaE9mZnNldDogMC4wLFxuICAgICAgd2lkdGg6IDFcbiAgICB9LFxuXG4gICAgLy8gc2NhbGUgdGl0bGVcbiAgICB0aXRsZToge1xuICAgICAgLy8gZGlzcGxheSBwcm9wZXJ0eVxuICAgICAgZGlzcGxheTogZmFsc2UsXG5cbiAgICAgIC8vIGFjdHVhbCBsYWJlbFxuICAgICAgdGV4dDogJycsXG5cbiAgICAgIC8vIHRvcC9ib3R0b20gcGFkZGluZ1xuICAgICAgcGFkZGluZzoge1xuICAgICAgICB0b3A6IDQsXG4gICAgICAgIGJvdHRvbTogNFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBsYWJlbCBzZXR0aW5nc1xuICAgIHRpY2tzOiB7XG4gICAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICAgIG1pcnJvcjogZmFsc2UsXG4gICAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgICB0ZXh0U3Ryb2tlQ29sb3I6ICcnLFxuICAgICAgcGFkZGluZzogMyxcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgICAgLy8gV2UgcGFzcyB0aHJvdWdoIGFycmF5cyB0byBiZSByZW5kZXJlZCBhcyBtdWx0aWxpbmUgbGFiZWxzLCB3ZSBjb252ZXJ0IE90aGVycyB0byBzdHJpbmdzIGhlcmUuXG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG4gICAgICBtaW5vcjoge30sXG4gICAgICBtYWpvcjoge30sXG4gICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICBjcm9zc0FsaWduOiAnbmVhcicsXG5cbiAgICAgIHNob3dMYWJlbEJhY2tkcm9wOiBmYWxzZSxcbiAgICAgIGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpJyxcbiAgICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgICB9XG4gIH0pO1xuXG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aWNrcycsICdjb2xvcicsICcnLCAnY29sb3InKTtcbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ib3JkZXInLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aXRsZScsICdjb2xvcicsICcnLCAnY29sb3InKTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUnLCB7XG4gICAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ2JlZm9yZScpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2FmdGVyJykgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyAmJiBuYW1lICE9PSAncGFyc2VyJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICd0aWNrQm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2Rhc2gnLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGVzJywge1xuICAgIF9mYWxsYmFjazogJ3NjYWxlJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlLnRpY2tzJywge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycsXG4gIH0pO1xufVxuIiwgImltcG9ydCB7Z2V0SG92ZXJDb2xvcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbG9yLmpzJztcbmltcG9ydCB7aXNPYmplY3QsIG1lcmdlLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHthcHBseUFuaW1hdGlvbnNEZWZhdWx0c30gZnJvbSAnLi9jb3JlLmFuaW1hdGlvbnMuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHthcHBseUxheW91dHNEZWZhdWx0c30gZnJvbSAnLi9jb3JlLmxheW91dHMuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHthcHBseVNjYWxlRGVmYXVsdHN9IGZyb20gJy4vY29yZS5zY2FsZS5kZWZhdWx0cy5qcyc7XG5cbmV4cG9ydCBjb25zdCBvdmVycmlkZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZXhwb3J0IGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTY29wZShub2RlLCBrZXkpIHtcbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSAwLCBuID0ga2V5cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCBrID0ga2V5c1tpXTtcbiAgICBub2RlID0gbm9kZVtrXSB8fCAobm9kZVtrXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBzZXQocm9vdCwgc2NvcGUsIHZhbHVlcykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtZXJnZShnZXRTY29wZShyb290LCBzY29wZSksIHZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlKGdldFNjb3BlKHJvb3QsICcnKSwgc2NvcGUpO1xufVxuXG4vKipcbiAqIFBsZWFzZSB1c2UgdGhlIG1vZHVsZSdzIGRlZmF1bHQgZXhwb3J0IHdoaWNoIHByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBOb3RlOiBjbGFzcyBpcyBleHBvcnRlZCBmb3IgdHlwZWRvY1xuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdHMge1xuICBjb25zdHJ1Y3RvcihfZGVzY3JpcHRvcnMsIF9hcHBsaWVycykge1xuICAgIHRoaXMuYW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgIHRoaXMuY29sb3IgPSAnIzY2Nic7XG4gICAgdGhpcy5kYXRhc2V0cyA9IHt9O1xuICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IChjb250ZXh0KSA9PiBjb250ZXh0LmNoYXJ0LnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XG4gICAgdGhpcy5ldmVudHMgPSBbXG4gICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgICdtb3VzZW91dCcsXG4gICAgICAnY2xpY2snLFxuICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgJ3RvdWNobW92ZSdcbiAgICBdO1xuICAgIHRoaXMuZm9udCA9IHtcbiAgICAgIGZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuICAgICAgc2l6ZTogMTIsXG4gICAgICBzdHlsZTogJ25vcm1hbCcsXG4gICAgICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgICB3ZWlnaHQ6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuaG92ZXIgPSB7fTtcbiAgICB0aGlzLmhvdmVyQmFja2dyb3VuZENvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcik7XG4gICAgdGhpcy5ob3ZlckJvcmRlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKTtcbiAgICB0aGlzLmhvdmVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuY29sb3IpO1xuICAgIHRoaXMuaW5kZXhBeGlzID0gJ3gnO1xuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSB7XG4gICAgICBtb2RlOiAnbmVhcmVzdCcsXG4gICAgICBpbnRlcnNlY3Q6IHRydWUsXG4gICAgICBpbmNsdWRlSW52aXNpYmxlOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5tYWludGFpbkFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLm9uSG92ZXIgPSBudWxsO1xuICAgIHRoaXMub25DbGljayA9IG51bGw7XG4gICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLnNob3dMaW5lID0gdHJ1ZTtcbiAgICB0aGlzLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdHJ1ZTtcblxuICAgIHRoaXMuZGVzY3JpYmUoX2Rlc2NyaXB0b3JzKTtcbiAgICB0aGlzLmFwcGx5KF9hcHBsaWVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzY29wZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc11cblx0ICovXG4gIHNldChzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldCh0aGlzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGVcblx0ICovXG4gIGdldChzY29wZSkge1xuICAgIHJldHVybiBnZXRTY29wZSh0aGlzLCBzY29wZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzY29wZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc11cblx0ICovXG4gIGRlc2NyaWJlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KGRlc2NyaXB0b3JzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIG92ZXJyaWRlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KG92ZXJyaWRlcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cblxuICAvKipcblx0ICogUm91dGVzIHRoZSBuYW1lZCBkZWZhdWx0cyB0byBmYWxsYmFjayB0byBhbm90aGVyIHNjb3BlL25hbWUuXG5cdCAqIFRoaXMgcm91dGluZyBpcyB1c2VmdWwgd2hlbiB0aG9zZSB0YXJnZXQgdmFsdWVzLCBsaWtlIGRlZmF1bHRzLmNvbG9yLCBhcmUgY2hhbmdlZCBydW50aW1lLlxuXHQgKiBJZiB0aGUgdmFsdWVzIHdvdWxkIGJlIGNvcGllZCwgdGhlIHJ1bnRpbWUgY2hhbmdlIHdvdWxkIG5vdCB0YWtlIGVmZmVjdC4gQnkgcm91dGluZywgdGhlXG5cdCAqIGZhbGxiYWNrIGlzIGV2YWx1YXRlZCBhdCBlYWNoIGFjY2Vzcywgc28gaXRzIGFsd2F5cyB1cCB0byBkYXRlLlxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiBcdGRlZmF1bHRzLnJvdXRlKCdlbGVtZW50cy5hcmMnLCAnYmFja2dyb3VuZENvbG9yJywgJycsICdjb2xvcicpXG5cdCAqICAgLSByZWFkcyB0aGUgYmFja2dyb3VuZENvbG9yIGZyb20gZGVmYXVsdHMuY29sb3Igd2hlbiB1bmRlZmluZWQgbG9jYWxseVxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGUgU2NvcGUgdGhpcyByb3V0ZSBhcHBsaWVzIHRvLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lIHRoYXQgc2hvdWxkIGJlIHJvdXRlZCB0byBkaWZmZXJlbnQgbmFtZXNwYWNlIHdoZW4gbm90IGRlZmluZWQgaGVyZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFNjb3BlIFRoZSBuYW1lc3BhY2Ugd2hlcmUgdGhvc2UgcHJvcGVydGllcyBzaG91bGQgYmUgcm91dGVkIHRvLlxuXHQgKiBFbXB0eSBzdHJpbmcgKCcnKSBpcyB0aGUgcm9vdCBvZiBkZWZhdWx0cy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldE5hbWUgVGhlIHRhcmdldCBuYW1lIGluIHRoZSB0YXJnZXQgc2NvcGUgdGhlIHByb3BlcnR5IHNob3VsZCBiZSByb3V0ZWQgdG8uXG5cdCAqL1xuICByb3V0ZShzY29wZSwgbmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpIHtcbiAgICBjb25zdCBzY29wZU9iamVjdCA9IGdldFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZU9iamVjdCA9IGdldFNjb3BlKHRoaXMsIHRhcmdldFNjb3BlKTtcbiAgICBjb25zdCBwcml2YXRlTmFtZSA9ICdfJyArIG5hbWU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzY29wZU9iamVjdCwge1xuICAgICAgLy8gQSBwcml2YXRlIHByb3BlcnR5IGlzIGRlZmluZWQgdG8gaG9sZCB0aGUgYWN0dWFsIHZhbHVlLCB3aGVuIHRoaXMgcHJvcGVydHkgaXMgc2V0IGluIGl0cyBzY29wZSAoc2V0IGluIHRoZSBzZXR0ZXIpXG4gICAgICBbcHJpdmF0ZU5hbWVdOiB7XG4gICAgICAgIHZhbHVlOiBzY29wZU9iamVjdFtuYW1lXSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICAvLyBUaGUgYWN0dWFsIHByb3BlcnR5IGlzIGRlZmluZWQgYXMgZ2V0dGVyL3NldHRlciBzbyB3ZSBjYW4gZG8gdGhlIHJvdXRpbmcgd2hlbiB2YWx1ZSBpcyBub3QgbG9jYWxseSBzZXQuXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGxvY2FsID0gdGhpc1twcml2YXRlTmFtZV07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0U2NvcGVPYmplY3RbdGFyZ2V0TmFtZV07XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KGxvY2FsKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgbG9jYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQobG9jYWwsIHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXNbcHJpdmF0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFwcGx5KGFwcGxpZXJzKSB7XG4gICAgYXBwbGllcnMuZm9yRWFjaCgoYXBwbHkpID0+IGFwcGx5KHRoaXMpKTtcbiAgfVxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgRGVmYXVsdHMoe1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZXZlbnRzJyxcbiAgaG92ZXI6IHtcbiAgICBfZmFsbGJhY2s6ICdpbnRlcmFjdGlvbidcbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH1cbn0sIFthcHBseUFuaW1hdGlvbnNEZWZhdWx0cywgYXBwbHlMYXlvdXRzRGVmYXVsdHMsIGFwcGx5U2NhbGVEZWZhdWx0c10pO1xuIiwgImltcG9ydCB0eXBlIHtcbiAgQ2hhcnQsXG4gIFBvaW50LFxuICBGb250U3BlYyxcbiAgQ2FudmFzRm9udFNwZWMsXG4gIFBvaW50U3R5bGUsXG4gIFJlbmRlclRleHRPcHRzLFxuICBCYWNrZHJvcE9wdGlvbnNcbn0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1xuICBUUkJMLFxuICBTcGxpbmVQb2ludCxcbiAgUm91bmRlZFJlY3QsXG4gIFRSQkxDb3JuZXJzXG59IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzTnVsbE9yVW5kZWZ9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7UEksIFRBVSwgSEFMRl9QSSwgUVVBUlRFUl9QSSwgVFdPX1RISVJEU19QSSwgUkFEX1BFUl9ERUd9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZm9udCBvYmplY3QgaW50byBhIENTUyBmb250IHN0cmluZy5cbiAqIEBwYXJhbSBmb250IC0gQSBmb250IG9iamVjdC5cbiAqIEByZXR1cm4gVGhlIENTUyBmb250IHN0cmluZy4gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Gb250U3RyaW5nKGZvbnQ6IEZvbnRTcGVjKSB7XG4gIGlmICghZm9udCB8fCBpc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaXNOdWxsT3JVbmRlZihmb250LmZhbWlseSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJylcblx0XHQrIChmb250LndlaWdodCA/IGZvbnQud2VpZ2h0ICsgJyAnIDogJycpXG5cdFx0KyBmb250LnNpemUgKyAncHggJ1xuXHRcdCsgZm9udC5mYW1pbHk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9tZWFzdXJlVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gIGdjOiBzdHJpbmdbXSxcbiAgbG9uZ2VzdDogbnVtYmVyLFxuICBzdHJpbmc6IHN0cmluZ1xuKSB7XG4gIGxldCB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG4gIGlmICghdGV4dFdpZHRoKSB7XG4gICAgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG4gICAgZ2MucHVzaChzdHJpbmcpO1xuICB9XG4gIGlmICh0ZXh0V2lkdGggPiBsb25nZXN0KSB7XG4gICAgbG9uZ2VzdCA9IHRleHRXaWR0aDtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cblxudHlwZSBUaGluZyA9IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGxcbnR5cGUgVGhpbmdzID0gKFRoaW5nIHwgVGhpbmdbXSlbXVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gX2xvbmdlc3RUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZm9udDogc3RyaW5nLFxuICBhcnJheU9mVGhpbmdzOiBUaGluZ3MsXG4gIGNhY2hlPzoge2RhdGE/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCBnYXJiYWdlQ29sbGVjdD86IHN0cmluZ1tdLCBmb250Pzogc3RyaW5nfVxuKSB7XG4gIGNhY2hlID0gY2FjaGUgfHwge307XG4gIGxldCBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XG4gIGxldCBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG5cbiAgaWYgKGNhY2hlLmZvbnQgIT09IGZvbnQpIHtcbiAgICBkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xuICAgIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcbiAgICBjYWNoZS5mb250ID0gZm9udDtcbiAgfVxuXG4gIGN0eC5zYXZlKCk7XG5cbiAgY3R4LmZvbnQgPSBmb250O1xuICBsZXQgbG9uZ2VzdCA9IDA7XG4gIGNvbnN0IGlsZW4gPSBhcnJheU9mVGhpbmdzLmxlbmd0aDtcbiAgbGV0IGk6IG51bWJlciwgajogbnVtYmVyLCBqbGVuOiBudW1iZXIsIHRoaW5nOiBUaGluZyB8IFRoaW5nW10sIG5lc3RlZFRoaW5nOiBUaGluZyB8IFRoaW5nW107XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB0aGluZyA9IGFycmF5T2ZUaGluZ3NbaV07XG5cbiAgICAvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICBpZiAodGhpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGluZyAhPT0gbnVsbCAmJiAhaXNBcnJheSh0aGluZykpIHtcbiAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0aGluZykpIHtcbiAgICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5IGxldHMgbWVhc3VyZSBlYWNoIGVsZW1lbnRcbiAgICAgIC8vIHRvIGRvIG1heWJlIHNpbXBsaWZ5IHRoaXMgZnVuY3Rpb24gYSBiaXQgc28gd2UgY2FuIGRvIHRoaXMgbW9yZSByZWN1cnNpdmVseT9cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSB0aGluZy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgbmVzdGVkVGhpbmcgPSB0aGluZ1tqXTtcbiAgICAgICAgLy8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgICAgIGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KG5lc3RlZFRoaW5nKSkge1xuICAgICAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3R4LnJlc3RvcmUoKTtcblxuICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gIGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyBpKyspIHtcbiAgICAgIGRlbGV0ZSBkYXRhW2djW2ldXTtcbiAgICB9XG4gICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlIHRvIGF2b2lkIGFudGktYWxpYXNpbmcgYmx1clxuICogQHBhcmFtIGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuICogQHBhcmFtIHBpeGVsIC0gQSBwaXhlbCB2YWx1ZS5cbiAqIEBwYXJhbSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudC5cbiAqIEByZXR1cm5zIFRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hbGlnblBpeGVsKGNoYXJ0OiBDaGFydCwgcGl4ZWw6IG51bWJlciwgd2lkdGg6IG51bWJlcikge1xuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG4gIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoICE9PSAwID8gTWF0aC5tYXgod2lkdGggLyAyLCAwLjUpIDogMDtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcbn1cblxuLyoqXG4gKiBDbGVhcnMgdGhlIGVudGlyZSBjYW52YXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBjdHg/OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgY3R4ID0gY3R4IHx8IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gIGN0eC5zYXZlKCk7XG4gIC8vIGNhbnZhcy53aWR0aCBhbmQgY2FudmFzLmhlaWdodCBkbyBub3QgY29uc2lkZXIgdGhlIGNhbnZhcyB0cmFuc2Zvcm0sXG4gIC8vIHdoaWxlIGNsZWFyUmVjdCBkb2VzXG4gIGN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJhd1BvaW50T3B0aW9ucyB7XG4gIHBvaW50U3R5bGU6IFBvaW50U3R5bGU7XG4gIHJvdGF0aW9uPzogbnVtYmVyO1xuICByYWRpdXM6IG51bWJlcjtcbiAgYm9yZGVyV2lkdGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdQb2ludChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIG9wdGlvbnM6IERyYXdQb2ludE9wdGlvbnMsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyXG4pIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICBkcmF3UG9pbnRMZWdlbmQoY3R4LCBvcHRpb25zLCB4LCB5LCBudWxsKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBkcmF3UG9pbnRMZWdlbmQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBvcHRpb25zOiBEcmF3UG9pbnRPcHRpb25zLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgdzogbnVtYmVyXG4pIHtcbiAgbGV0IHR5cGU6IHN0cmluZywgeE9mZnNldDogbnVtYmVyLCB5T2Zmc2V0OiBudW1iZXIsIHNpemU6IG51bWJlciwgY29ybmVyUmFkaXVzOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIHhPZmZzZXRXOiBudW1iZXIsIHlPZmZzZXRXOiBudW1iZXI7XG4gIGNvbnN0IHN0eWxlID0gb3B0aW9ucy5wb2ludFN0eWxlO1xuICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb247XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzO1xuICBsZXQgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG5cbiAgaWYgKHN0eWxlICYmIHR5cGVvZiBzdHlsZSA9PT0gJ29iamVjdCcpIHtcbiAgICB0eXBlID0gc3R5bGUudG9TdHJpbmcoKTtcbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4LnJvdGF0ZShyYWQpO1xuICAgICAgY3R4LmRyYXdJbWFnZShzdHlsZSwgLXN0eWxlLndpZHRoIC8gMiwgLXN0eWxlLmhlaWdodCAvIDIsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICBzd2l0Y2ggKHN0eWxlKSB7XG4gIC8vIERlZmF1bHQgaW5jbHVkZXMgY2lyY2xlXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh3KSB7XG4gICAgICAgIGN0eC5lbGxpcHNlKHgsIHksIHcgLyAyLCByYWRpdXMsIDAsIDAsIFRBVSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgVEFVKTtcbiAgICAgIH1cbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICAgIHdpZHRoID0gdyA/IHcgLyAyIDogcmFkaXVzO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHdpZHRoLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiB3aWR0aCwgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogd2lkdGgsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JlY3RSb3VuZGVkJzpcbiAgICAvLyBOT1RFOiB0aGUgcm91bmRlZCByZWN0IGltcGxlbWVudGF0aW9uIGNoYW5nZWQgdG8gdXNlIGBhcmNgIGluc3RlYWQgb2ZcbiAgICAvLyBgcXVhZHJhdGljQ3VydmVUb2Agc2luY2UgaXQgZ2VuZXJhdGVzIGJldHRlciByZXN1bHRzIHdoZW4gcmVjdCBpc1xuICAgIC8vIGFsbW9zdCBhIGNpcmNsZS4gMC41MTYgKGluc3RlYWQgb2YgMC41KSBwcm9kdWNlcyByZXN1bHRzIHdpdGggdmlzdWFsbHlcbiAgICAvLyBjbG9zZXIgcHJvcG9ydGlvbiB0byB0aGUgcHJldmlvdXMgaW1wbCBhbmQgaXQgaXMgaW5zY3JpYmVkIGluIHRoZVxuICAgIC8vIGNpcmNsZSB3aXRoIGByYWRpdXNgLiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIGZvbGxvd2luZyBQUnM6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU1OTdcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTg1OFxuICAgICAgY29ybmVyUmFkaXVzID0gcmFkaXVzICogMC41MTY7XG4gICAgICBzaXplID0gcmFkaXVzIC0gY29ybmVyUmFkaXVzO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiAodyA/IHcgLyAyIC0gY29ybmVyUmFkaXVzIDogc2l6ZSk7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqICh3ID8gdyAvIDIgLSBjb3JuZXJSYWRpdXMgOiBzaXplKTtcbiAgICAgIGN0eC5hcmMoeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBQSSwgcmFkIC0gSEFMRl9QSSk7XG4gICAgICBjdHguYXJjKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gSEFMRl9QSSwgcmFkKTtcbiAgICAgIGN0eC5hcmMoeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQsIHJhZCArIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCArIEhBTEZfUEksIHJhZCArIFBJKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JlY3QnOlxuICAgICAgaWYgKCFyb3RhdGlvbikge1xuICAgICAgICBzaXplID0gTWF0aC5TUVJUMV8yICogcmFkaXVzO1xuICAgICAgICB3aWR0aCA9IHcgPyB3IC8gMiA6IHNpemU7XG4gICAgICAgIGN0eC5yZWN0KHggLSB3aWR0aCwgeSAtIHNpemUsIDIgKiB3aWR0aCwgMiAqIHNpemUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlICdyZWN0Um90JzpcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Nyb3NzUm90JzpcbiAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlICdjcm9zcyc6XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzdGFyJzpcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGluZSc6XG4gICAgICB4T2Zmc2V0ID0gdyA/IHcgLyAyIDogTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGFzaCc6XG4gICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZhbHNlOlxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBjdHguZmlsbCgpO1xuICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIGFyZWEgLSBUaGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gbWFyZ2luIC0gYWxsb3dlZCBtYXJnaW5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNQb2ludEluQXJlYShcbiAgcG9pbnQ6IFBvaW50LFxuICBhcmVhOiBUUkJMLFxuICBtYXJnaW4/OiBudW1iZXJcbikge1xuICBtYXJnaW4gPSBtYXJnaW4gfHwgMC41OyAvLyBtYXJnaW4gLSBkZWZhdWx0IGlzIHRvIG1hdGNoIHJvdW5kZWQgZGVjaW1hbHNcblxuICByZXR1cm4gIWFyZWEgfHwgKHBvaW50ICYmIHBvaW50LnggPiBhcmVhLmxlZnQgLSBtYXJnaW4gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBtYXJnaW4gJiZcblx0XHRwb2ludC55ID4gYXJlYS50b3AgLSBtYXJnaW4gJiYgcG9pbnQueSA8IGFyZWEuYm90dG9tICsgbWFyZ2luKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBBcmVhKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBhcmVhOiBUUkJMKSB7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnJlY3QoYXJlYS5sZWZ0LCBhcmVhLnRvcCwgYXJlYS5yaWdodCAtIGFyZWEubGVmdCwgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmNsaXBBcmVhKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zdGVwcGVkTGluZVRvKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgcHJldmlvdXM6IFBvaW50LFxuICB0YXJnZXQ6IFBvaW50LFxuICBmbGlwPzogYm9vbGVhbixcbiAgbW9kZT86IHN0cmluZ1xuKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGlmIChtb2RlID09PSAnbWlkZGxlJykge1xuICAgIGNvbnN0IG1pZHBvaW50ID0gKHByZXZpb3VzLnggKyB0YXJnZXQueCkgLyAyLjA7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgcHJldmlvdXMueSk7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgdGFyZ2V0LnkpO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09ICdhZnRlcicgIT09ICEhZmxpcCkge1xuICAgIGN0eC5saW5lVG8ocHJldmlvdXMueCwgdGFyZ2V0LnkpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lVG8odGFyZ2V0LngsIHByZXZpb3VzLnkpO1xuICB9XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JlemllckN1cnZlVG8oXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBwcmV2aW91czogU3BsaW5lUG9pbnQsXG4gIHRhcmdldDogU3BsaW5lUG9pbnQsXG4gIGZsaXA/OiBib29sZWFuXG4pIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXggOiBwcmV2aW91cy5jcDJ4LFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF5IDogcHJldmlvdXMuY3AyeSxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnggOiB0YXJnZXQuY3AxeCxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnkgOiB0YXJnZXQuY3AxeSxcbiAgICB0YXJnZXQueCxcbiAgICB0YXJnZXQueSk7XG59XG5cbmZ1bmN0aW9uIHNldFJlbmRlck9wdHMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG9wdHM6IFJlbmRlclRleHRPcHRzKSB7XG4gIGlmIChvcHRzLnRyYW5zbGF0aW9uKSB7XG4gICAgY3R4LnRyYW5zbGF0ZShvcHRzLnRyYW5zbGF0aW9uWzBdLCBvcHRzLnRyYW5zbGF0aW9uWzFdKTtcbiAgfVxuXG4gIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnJvdGF0aW9uKSkge1xuICAgIGN0eC5yb3RhdGUob3B0cy5yb3RhdGlvbik7XG4gIH1cblxuICBpZiAob3B0cy5jb2xvcikge1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yO1xuICB9XG5cbiAgaWYgKG9wdHMudGV4dEFsaWduKSB7XG4gICAgY3R4LnRleHRBbGlnbiA9IG9wdHMudGV4dEFsaWduO1xuICB9XG5cbiAgaWYgKG9wdHMudGV4dEJhc2VsaW5lKSB7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IG9wdHMudGV4dEJhc2VsaW5lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlY29yYXRlVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICBsaW5lOiBzdHJpbmcsXG4gIG9wdHM6IFJlbmRlclRleHRPcHRzXG4pIHtcbiAgaWYgKG9wdHMuc3RyaWtldGhyb3VnaCB8fCBvcHRzLnVuZGVybGluZSkge1xuICAgIC8qKlxuICAgICAqIE5vdyB0aGF0IElFMTEgc3VwcG9ydCBoYXMgYmVlbiBkcm9wcGVkLCB3ZSBjYW4gdXNlIG1vcmVcbiAgICAgKiBvZiB0aGUgVGV4dE1ldHJpY3Mgb2JqZWN0LiBUaGUgYWN0dWFsIGJvdW5kaW5nIGJveGVzXG4gICAgICogYXJlIHVuZmxhZ2dlZCBpbiBDaHJvbWUsIEZpcmVmb3gsIEVkZ2UsIGFuZCBTYWZhcmkgc28gdGhleVxuICAgICAqIGNhbiBiZSBzYWZlbHkgdXNlZC5cbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHRNZXRyaWNzI0Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICAgICAqL1xuICAgIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQobGluZSk7XG4gICAgY29uc3QgbGVmdCA9IHggLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdDtcbiAgICBjb25zdCByaWdodCA9IHggKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQ7XG4gICAgY29uc3QgdG9wID0geSAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgY29uc3QgYm90dG9tID0geSArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xuICAgIGNvbnN0IHlEZWNvcmF0aW9uID0gb3B0cy5zdHJpa2V0aHJvdWdoID8gKHRvcCArIGJvdHRvbSkgLyAyIDogYm90dG9tO1xuXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuZGVjb3JhdGlvbldpZHRoIHx8IDI7XG4gICAgY3R4Lm1vdmVUbyhsZWZ0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LmxpbmVUbyhyaWdodCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3QmFja2Ryb3AoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG9wdHM6IEJhY2tkcm9wT3B0aW9ucykge1xuICBjb25zdCBvbGRDb2xvciA9IGN0eC5maWxsU3R5bGU7XG5cbiAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuY29sb3IgYXMgc3RyaW5nO1xuICBjdHguZmlsbFJlY3Qob3B0cy5sZWZ0LCBvcHRzLnRvcCwgb3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuICBjdHguZmlsbFN0eWxlID0gb2xkQ29sb3I7XG59XG5cbi8qKlxuICogUmVuZGVyIHRleHQgb250byB0aGUgY2FudmFzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgdGV4dDogc3RyaW5nIHwgc3RyaW5nW10sXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICBmb250OiBDYW52YXNGb250U3BlYyxcbiAgb3B0czogUmVuZGVyVGV4dE9wdHMgPSB7fVxuKSB7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheSh0ZXh0KSA/IHRleHQgOiBbdGV4dF07XG4gIGNvbnN0IHN0cm9rZSA9IG9wdHMuc3Ryb2tlV2lkdGggPiAwICYmIG9wdHMuc3Ryb2tlQ29sb3IgIT09ICcnO1xuICBsZXQgaTogbnVtYmVyLCBsaW5lOiBzdHJpbmc7XG5cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcbiAgc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgIGlmIChvcHRzLmJhY2tkcm9wKSB7XG4gICAgICBkcmF3QmFja2Ryb3AoY3R4LCBvcHRzLmJhY2tkcm9wKTtcbiAgICB9XG5cbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBpZiAob3B0cy5zdHJva2VDb2xvcikge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRzLnN0cm9rZUNvbG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5zdHJva2VXaWR0aCkpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zdHJva2VUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIH1cblxuICAgIGN0eC5maWxsVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKTtcblxuICAgIHkgKz0gTnVtYmVyKGZvbnQubGluZUhlaWdodCk7XG4gIH1cblxuICBjdHgucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEFkZCBhIHBhdGggb2YgYSByZWN0YW5nbGUgd2l0aCByb3VuZGVkIGNvcm5lcnMgdG8gdGhlIGN1cnJlbnQgc3ViLXBhdGhcbiAqIEBwYXJhbSBjdHggLSBDb250ZXh0XG4gKiBAcGFyYW0gcmVjdCAtIEJvdW5kaW5nIHJlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFJvdW5kZWRSZWN0UGF0aChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHJlY3Q6IFJvdW5kZWRSZWN0ICYgeyByYWRpdXM6IFRSQkxDb3JuZXJzIH1cbikge1xuICBjb25zdCB7eCwgeSwgdywgaCwgcmFkaXVzfSA9IHJlY3Q7XG5cbiAgLy8gdG9wIGxlZnQgYXJjXG4gIGN0eC5hcmMoeCArIHJhZGl1cy50b3BMZWZ0LCB5ICsgcmFkaXVzLnRvcExlZnQsIHJhZGl1cy50b3BMZWZ0LCAxLjUgKiBQSSwgUEksIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSB0b3AgbGVmdCB0byBib3R0b20gbGVmdFxuICBjdHgubGluZVRvKHgsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQpO1xuXG4gIC8vIGJvdHRvbSBsZWZ0IGFyY1xuICBjdHguYXJjKHggKyByYWRpdXMuYm90dG9tTGVmdCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCwgcmFkaXVzLmJvdHRvbUxlZnQsIFBJLCBIQUxGX1BJLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gYm90dG9tIGxlZnQgdG8gYm90dG9tIHJpZ2h0XG4gIGN0eC5saW5lVG8oeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoKTtcblxuICAvLyBib3R0b20gcmlnaHQgYXJjXG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCByYWRpdXMuYm90dG9tUmlnaHQsIEhBTEZfUEksIDAsIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSBib3R0b20gcmlnaHQgdG8gdG9wIHJpZ2h0XG4gIGN0eC5saW5lVG8oeCArIHcsIHkgKyByYWRpdXMudG9wUmlnaHQpO1xuXG4gIC8vIHRvcCByaWdodCBhcmNcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy50b3BSaWdodCwgeSArIHJhZGl1cy50b3BSaWdodCwgcmFkaXVzLnRvcFJpZ2h0LCAwLCAtSEFMRl9QSSwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIHRvcCByaWdodCB0byB0b3AgbGVmdFxuICBjdHgubGluZVRvKHggKyByYWRpdXMudG9wTGVmdCwgeSk7XG59XG4iLCAiaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2NvcmUvY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzT2JqZWN0LCB0b0RpbWVuc2lvbiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9Gb250U3RyaW5nfSBmcm9tICcuL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydEFyZWEsIEZvbnRTcGVjLCBQb2ludH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1RSQkwsIFRSQkxDb3JuZXJzfSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuXG5jb25zdCBMSU5FX0hFSUdIVCA9IC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvO1xuY29uc3QgRk9OVF9TVFlMRSA9IC9eKG5vcm1hbHxpdGFsaWN8aW5pdGlhbHxpbmhlcml0fHVuc2V0fChvYmxpcXVlKCAtP1swLTldP1swLTldZGVnKT8pKSQvO1xuXG4vKipcbiAqIEBhbGlhcyBDaGFydC5oZWxwZXJzLm9wdGlvbnNcbiAqIEBuYW1lc3BhY2VcbiAqL1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbGluZSBoZWlnaHQgYHZhbHVlYCBpbiBwaXhlbHMgZm9yIGEgc3BlY2lmaWMgZm9udCBgc2l6ZWAuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbGluZUhlaWdodCB0byBwYXJzZSAoZWcuIDEuNiwgJzE0cHgnLCAnNzUlJywgJzEuNmVtJykuXG4gKiBAcGFyYW0gc2l6ZSAtIFRoZSBmb250IHNpemUgKGluIHBpeGVscykgdXNlZCB0byByZXNvbHZlIHJlbGF0aXZlIGB2YWx1ZWAuXG4gKiBAcmV0dXJucyBUaGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGluIHBpeGVscyAoc2l6ZSAqIDEuMiBpZiB2YWx1ZSBpcyBpbnZhbGlkKS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2xpbmUtaGVpZ2h0XG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTGluZUhlaWdodCh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nLCBzaXplOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBtYXRjaGVzID0gKCcnICsgdmFsdWUpLm1hdGNoKExJTkVfSEVJR0hUKTtcbiAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXNbMV0gPT09ICdub3JtYWwnKSB7XG4gICAgcmV0dXJuIHNpemUgKiAxLjI7XG4gIH1cblxuICB2YWx1ZSA9ICttYXRjaGVzWzJdO1xuXG4gIHN3aXRjaCAobWF0Y2hlc1szXSkge1xuICAgIGNhc2UgJ3B4JzpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjYXNlICclJzpcbiAgICAgIHZhbHVlIC89IDEwMDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBzaXplICogdmFsdWU7XG59XG5cbmNvbnN0IG51bWJlck9yWmVybyA9ICh2OiB1bmtub3duKSA9PiArdiB8fCAwO1xuXG4vKipcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIHByb3BzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wczxLIGV4dGVuZHMgc3RyaW5nPih2YWx1ZTogbnVtYmVyIHwgUmVjb3JkPEssIG51bWJlcj4sIHByb3BzOiBLW10pOiBSZWNvcmQ8SywgbnVtYmVyPjtcbmV4cG9ydCBmdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wczxLIGV4dGVuZHMgc3RyaW5nLCBUIGV4dGVuZHMgc3RyaW5nPih2YWx1ZTogbnVtYmVyIHwgUmVjb3JkPEsgJiBULCBudW1iZXI+LCBwcm9wczogUmVjb3JkPFQsIEs+KTogUmVjb3JkPFQsIG51bWJlcj47XG5leHBvcnQgZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWU6IG51bWJlciB8IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sIHByb3BzOiBzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNvbnN0IG9ialByb3BzID0gaXNPYmplY3QocHJvcHMpO1xuICBjb25zdCBrZXlzID0gb2JqUHJvcHMgPyBPYmplY3Qua2V5cyhwcm9wcykgOiBwcm9wcztcbiAgY29uc3QgcmVhZCA9IGlzT2JqZWN0KHZhbHVlKVxuICAgID8gb2JqUHJvcHNcbiAgICAgID8gcHJvcCA9PiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZVtwcm9wXSwgdmFsdWVbcHJvcHNbcHJvcF1dKVxuICAgICAgOiBwcm9wID0+IHZhbHVlW3Byb3BdXG4gICAgOiAoKSA9PiB2YWx1ZTtcblxuICBmb3IgKGNvbnN0IHByb3Agb2Yga2V5cykge1xuICAgIHJldFtwcm9wXSA9IG51bWJlck9yWmVybyhyZWFkKHByb3ApKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgVFJCTCBvYmplY3QuXG4gKiBAcGFyYW0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb21wb25lbnQsXG4gKiAgZWxzZSwgaWYgYW4gb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG4gKiAgeCAvIHkgYXJlIHNob3J0aGFuZHMgZm9yIHNhbWUgdmFsdWUgZm9yIGxlZnQvcmlnaHQgYW5kIHRvcC9ib3R0b20uXG4gKiBAcmV0dXJucyBUaGUgcGFkZGluZyB2YWx1ZXMgKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdClcbiAqIEBzaW5jZSAzLjAuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UUkJMKHZhbHVlOiBudW1iZXIgfCBUUkJMIHwgUG9pbnQpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCB7dG9wOiAneScsIHJpZ2h0OiAneCcsIGJvdHRvbTogJ3knLCBsZWZ0OiAneCd9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIFRSQkwgY29ybmVycyBvYmplY3QgKHNpbWlsYXIgd2l0aCBjc3MgYm9yZGVyLXJhZGl1cykuXG4gKiBAcGFyYW0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb3JuZXIgY29tcG9uZW50cyxcbiAqICBlbHNlLCBpZiBhbiBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cbiAqIEByZXR1cm5zIFRoZSBUUkJMIGNvcm5lciB2YWx1ZXMgKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodClcbiAqIEBzaW5jZSAzLjAuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UUkJMQ29ybmVycyh2YWx1ZTogbnVtYmVyIHwgVFJCTENvcm5lcnMpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ3RvcExlZnQnLCAndG9wUmlnaHQnLCAnYm90dG9tTGVmdCcsICdib3R0b21SaWdodCddKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIHBhZGRpbmcgb2JqZWN0IHdpdGggcHJlLWNvbXB1dGVkIHdpZHRoL2hlaWdodC5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcbiAqICBlbHNlLCBpZiBhbiBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cbiAqICB4IC8geSBhcmUgc2hvcnRoYW5kcyBmb3Igc2FtZSB2YWx1ZSBmb3IgbGVmdC9yaWdodCBhbmQgdG9wL2JvdHRvbS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KVxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1BhZGRpbmcodmFsdWU/OiBudW1iZXIgfCBUUkJMKTogQ2hhcnRBcmVhIHtcbiAgY29uc3Qgb2JqID0gdG9UUkJMKHZhbHVlKSBhcyBDaGFydEFyZWE7XG5cbiAgb2JqLndpZHRoID0gb2JqLmxlZnQgKyBvYmoucmlnaHQ7XG4gIG9iai5oZWlnaHQgPSBvYmoudG9wICsgb2JqLmJvdHRvbTtcblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIFBhcnNlcyBmb250IG9wdGlvbnMgYW5kIHJldHVybnMgdGhlIGZvbnQgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBIG9iamVjdCB0aGF0IGNvbnRhaW5zIGZvbnQgb3B0aW9ucyB0byBiZSBwYXJzZWQuXG4gKiBAcGFyYW0gZmFsbGJhY2sgLSBBIG9iamVjdCB0aGF0IGNvbnRhaW5zIGZhbGxiYWNrIGZvbnQgb3B0aW9ucy5cbiAqIEByZXR1cm4gVGhlIGZvbnQgb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9Gb250KG9wdGlvbnM6IFBhcnRpYWw8Rm9udFNwZWM+LCBmYWxsYmFjaz86IFBhcnRpYWw8Rm9udFNwZWM+KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmYWxsYmFjayA9IGZhbGxiYWNrIHx8IGRlZmF1bHRzLmZvbnQgYXMgRm9udFNwZWM7XG5cbiAgbGV0IHNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnNpemUsIGZhbGxiYWNrLnNpemUpO1xuXG4gIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzaXplID0gcGFyc2VJbnQoc2l6ZSwgMTApO1xuICB9XG4gIGxldCBzdHlsZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc3R5bGUsIGZhbGxiYWNrLnN0eWxlKTtcbiAgaWYgKHN0eWxlICYmICEoJycgKyBzdHlsZSkubWF0Y2goRk9OVF9TVFlMRSkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgZm9udCBzdHlsZSBzcGVjaWZpZWQ6IFwiJyArIHN0eWxlICsgJ1wiJyk7XG4gICAgc3R5bGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBmb250ID0ge1xuICAgIGZhbWlseTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mYW1pbHksIGZhbGxiYWNrLmZhbWlseSksXG4gICAgbGluZUhlaWdodDogdG9MaW5lSGVpZ2h0KHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubGluZUhlaWdodCwgZmFsbGJhY2subGluZUhlaWdodCksIHNpemUpLFxuICAgIHNpemUsXG4gICAgc3R5bGUsXG4gICAgd2VpZ2h0OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLndlaWdodCwgZmFsbGJhY2sud2VpZ2h0KSxcbiAgICBzdHJpbmc6ICcnXG4gIH07XG5cbiAgZm9udC5zdHJpbmcgPSB0b0ZvbnRTdHJpbmcoZm9udCk7XG4gIHJldHVybiBmb250O1xufVxuXG4vKipcbiAqIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gYGlucHV0c2Agc2VxdWVudGlhbGx5IGFuZCByZXR1cm5zIHRoZSBmaXJzdCBkZWZpbmVkIHZhbHVlLlxuICogQHBhcmFtIGlucHV0cyAtIEFuIGFycmF5IG9mIHZhbHVlcywgZmFsbGluZyBiYWNrIHRvIHRoZSBsYXN0IHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQgLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCB0aGUgdmFsdWVcbiAqIGlzIGNhbGxlZCB3aXRoIGBjb250ZXh0YCBhcyBmaXJzdCBhcmd1bWVudCBhbmQgdGhlIHJlc3VsdCBiZWNvbWVzIHRoZSBuZXcgaW5wdXQuXG4gKiBAcGFyYW0gaW5kZXggLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlIHZhbHVlXG4gKiBhdCBgaW5kZXhgIGJlY29tZSB0aGUgbmV3IGlucHV0LlxuICogQHBhcmFtIGluZm8gLSBvYmplY3QgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGFib3V0IHJlc29sdXRpb24gaW5cbiAqIEBwYXJhbSBpbmZvLmNhY2hlYWJsZSAtIFdpbGwgYmUgc2V0IHRvIGBmYWxzZWAgaWYgb3B0aW9uIGlzIG5vdCBjYWNoZWFibGUuXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmUoaW5wdXRzOiBBcnJheTx1bmtub3duPiwgY29udGV4dD86IG9iamVjdCwgaW5kZXg/OiBudW1iZXIsIGluZm8/OiB7IGNhY2hlYWJsZTogYm9vbGVhbiB9KSB7XG4gIGxldCBjYWNoZWFibGUgPSB0cnVlO1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHZhbHVlOiB1bmtub3duO1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBpbnB1dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSBpbnB1dHNbaV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZShjb250ZXh0KTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVtpbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbmZvICYmICFjYWNoZWFibGUpIHtcbiAgICAgICAgaW5mby5jYWNoZWFibGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gbWlubWF4XG4gKiBAcGFyYW0gZ3JhY2VcbiAqIEBwYXJhbSBiZWdpbkF0WmVyb1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hZGRHcmFjZShtaW5tYXg6IHsgbWluOiBudW1iZXI7IG1heDogbnVtYmVyOyB9LCBncmFjZTogbnVtYmVyIHwgc3RyaW5nLCBiZWdpbkF0WmVybzogYm9vbGVhbikge1xuICBjb25zdCB7bWluLCBtYXh9ID0gbWlubWF4O1xuICBjb25zdCBjaGFuZ2UgPSB0b0RpbWVuc2lvbihncmFjZSwgKG1heCAtIG1pbikgLyAyKTtcbiAgY29uc3Qga2VlcFplcm8gPSAodmFsdWU6IG51bWJlciwgYWRkOiBudW1iZXIpID0+IGJlZ2luQXRaZXJvICYmIHZhbHVlID09PSAwID8gMCA6IHZhbHVlICsgYWRkO1xuICByZXR1cm4ge1xuICAgIG1pbjoga2VlcFplcm8obWluLCAtTWF0aC5hYnMoY2hhbmdlKSksXG4gICAgbWF4OiBrZWVwWmVybyhtYXgsIGNoYW5nZSlcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjb250ZXh0IGluaGVyaXRpbmcgcGFyZW50Q29udGV4dFxuICogQHBhcmFtIHBhcmVudENvbnRleHRcbiAqIEBwYXJhbSBjb250ZXh0XG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dDxUIGV4dGVuZHMgb2JqZWN0PihwYXJlbnRDb250ZXh0OiBudWxsLCBjb250ZXh0OiBUKTogVDtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0PFQgZXh0ZW5kcyBvYmplY3QsIFAgZXh0ZW5kcyBUPihwYXJlbnRDb250ZXh0OiBQLCBjb250ZXh0OiBUKTogUCAmIFQ7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dChwYXJlbnRDb250ZXh0OiBvYmplY3QsIGNvbnRleHQ6IG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHBhcmVudENvbnRleHQpLCBjb250ZXh0KTtcbn1cbiIsICIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbmltcG9ydCB0eXBlIHtBbnlPYmplY3R9IGZyb20gJy4uL3R5cGVzL2Jhc2ljLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydE1ldGF9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtcbiAgUmVzb2x2ZXJPYmplY3RLZXksXG4gIFJlc29sdmVyQ2FjaGUsXG4gIFJlc29sdmVyUHJveHksXG4gIERlc2NyaXB0b3JEZWZhdWx0cyxcbiAgRGVzY3JpcHRvcixcbiAgQ29udGV4dENhY2hlLFxuICBDb250ZXh0UHJveHlcbn0gZnJvbSAnLi9oZWxwZXJzLmNvbmZpZy50eXBlcy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCByZXNvbHZlT2JqZWN0S2V5LCBfY2FwaXRhbGl6ZX0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG5leHBvcnQgKiBmcm9tICcuL2hlbHBlcnMuY29uZmlnLnR5cGVzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgUHJveHkgZm9yIHJlc29sdmluZyByYXcgdmFsdWVzIGZvciBvcHRpb25zLlxuICogQHBhcmFtIHNjb3BlcyAtIFRoZSBvcHRpb24gc2NvcGVzIHRvIGxvb2sgZm9yIHZhbHVlcywgaW4gcmVzb2x1dGlvbiBvcmRlclxuICogQHBhcmFtIHByZWZpeGVzIC0gVGhlIHByZWZpeGVzIGZvciB2YWx1ZXMsIGluIHJlc29sdXRpb24gb3JkZXIuXG4gKiBAcGFyYW0gcm9vdFNjb3BlcyAtIFRoZSByb290IG9wdGlvbiBzY29wZXNcbiAqIEBwYXJhbSBmYWxsYmFjayAtIFBhcmVudCBzY29wZXMgZmFsbGJhY2tcbiAqIEBwYXJhbSBnZXRUYXJnZXQgLSBjYWxsYmFjayBmb3IgZ2V0dGluZyB0aGUgdGFyZ2V0IGZvciBjaGFuZ2VkIHZhbHVlc1xuICogQHJldHVybnMgUHJveHlcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlUmVzb2x2ZXI8XG4gIFQgZXh0ZW5kcyBBbnlPYmplY3RbXSA9IEFueU9iamVjdFtdLFxuICBSIGV4dGVuZHMgQW55T2JqZWN0W10gPSBUXG4+KFxuICBzY29wZXM6IFQsXG4gIHByZWZpeGVzID0gWycnXSxcbiAgcm9vdFNjb3Blcz86IFIsXG4gIGZhbGxiYWNrPzogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGdldFRhcmdldCA9ICgpID0+IHNjb3Blc1swXVxuKSB7XG4gIGNvbnN0IGZpbmFsUm9vdFNjb3BlcyA9IHJvb3RTY29wZXMgfHwgc2NvcGVzO1xuICBpZiAodHlwZW9mIGZhbGxiYWNrID09PSAndW5kZWZpbmVkJykge1xuICAgIGZhbGxiYWNrID0gX3Jlc29sdmUoJ19mYWxsYmFjaycsIHNjb3Blcyk7XG4gIH1cbiAgY29uc3QgY2FjaGU6IFJlc29sdmVyQ2FjaGU8VCwgUj4gPSB7XG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdPYmplY3QnLFxuICAgIF9jYWNoZWFibGU6IHRydWUsXG4gICAgX3Njb3Blczogc2NvcGVzLFxuICAgIF9yb290U2NvcGVzOiBmaW5hbFJvb3RTY29wZXMsXG4gICAgX2ZhbGxiYWNrOiBmYWxsYmFjayxcbiAgICBfZ2V0VGFyZ2V0OiBnZXRUYXJnZXQsXG4gICAgb3ZlcnJpZGU6IChzY29wZTogQW55T2JqZWN0KSA9PiBfY3JlYXRlUmVzb2x2ZXIoW3Njb3BlLCAuLi5zY29wZXNdLCBwcmVmaXhlcywgZmluYWxSb290U2NvcGVzLCBmYWxsYmFjayksXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBkZWxldGUgb3BlcmF0b3IuXG4gICAgICovXG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wOiBzdHJpbmcpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07IC8vIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzOyAvLyByZW1vdmUgY2FjaGVkIGtleXNcbiAgICAgIGRlbGV0ZSBzY29wZXNbMF1bcHJvcF07IC8vIHJlbW92ZSBmcm9tIHRvcCBsZXZlbCBzY29wZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgZ2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgZ2V0KHRhcmdldCwgcHJvcDogc3RyaW5nKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aFByZWZpeGVzKHByb3AsIHByZWZpeGVzLCBzY29wZXMsIHRhcmdldCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuXG4gICAgICogQWxzbyB1c2VkIGJ5IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0Ll9zY29wZXNbMF0sIHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZi5cbiAgICAgKi9cbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHNjb3Blc1swXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGluIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGhhcyh0YXJnZXQsIHByb3A6IHN0cmluZykge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkuaW5jbHVkZXMocHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgYW5kIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMuXG4gICAgICovXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHNldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIHNldCh0YXJnZXQsIHByb3A6IHN0cmluZywgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0YXJnZXQuX3N0b3JhZ2UgfHwgKHRhcmdldC5fc3RvcmFnZSA9IGdldFRhcmdldCgpKTtcbiAgICAgIHRhcmdldFtwcm9wXSA9IHN0b3JhZ2VbcHJvcF0gPSB2YWx1ZTsgLy8gc2V0IHRvIHRvcCBsZXZlbCBzY29wZSArIGNhY2hlXG4gICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzOyAvLyByZW1vdmUgY2FjaGVkIGtleXNcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSkgYXMgUmVzb2x2ZXJQcm94eTxULCBSPjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIFByb3h5IGZvciByZXNvbHZpbmcgb3B0aW9uIHZhbHVlcyB3aXRoIGNvbnRleHQuXG4gKiBAcGFyYW0gcHJveHkgLSBUaGUgUHJveHkgcmV0dXJuZWQgYnkgYF9jcmVhdGVSZXNvbHZlcmBcbiAqIEBwYXJhbSBjb250ZXh0IC0gQ29udGV4dCBvYmplY3QgZm9yIHNjcmlwdGFibGUvaW5kZXhhYmxlIG9wdGlvbnNcbiAqIEBwYXJhbSBzdWJQcm94eSAtIFRoZSBwcm94eSBwcm92aWRlZCBmb3Igc2NyaXB0YWJsZSBvcHRpb25zXG4gKiBAcGFyYW0gZGVzY3JpcHRvckRlZmF1bHRzIC0gRGVmYXVsdHMgZm9yIGRlc2NyaXB0b3JzXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2F0dGFjaENvbnRleHQ8XG4gIFQgZXh0ZW5kcyBBbnlPYmplY3RbXSA9IEFueU9iamVjdFtdLFxuICBSIGV4dGVuZHMgQW55T2JqZWN0W10gPSBUXG4+KFxuICBwcm94eTogUmVzb2x2ZXJQcm94eTxULCBSPixcbiAgY29udGV4dDogQW55T2JqZWN0LFxuICBzdWJQcm94eT86IFJlc29sdmVyUHJveHk8VCwgUj4sXG4gIGRlc2NyaXB0b3JEZWZhdWx0cz86IERlc2NyaXB0b3JEZWZhdWx0c1xuKSB7XG4gIGNvbnN0IGNhY2hlOiBDb250ZXh0Q2FjaGU8VCwgUj4gPSB7XG4gICAgX2NhY2hlYWJsZTogZmFsc2UsXG4gICAgX3Byb3h5OiBwcm94eSxcbiAgICBfY29udGV4dDogY29udGV4dCxcbiAgICBfc3ViUHJveHk6IHN1YlByb3h5LFxuICAgIF9zdGFjazogbmV3IFNldCgpLFxuICAgIF9kZXNjcmlwdG9yczogX2Rlc2NyaXB0b3JzKHByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIHNldENvbnRleHQ6IChjdHg6IEFueU9iamVjdCkgPT4gX2F0dGFjaENvbnRleHQocHJveHksIGN0eCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgb3ZlcnJpZGU6IChzY29wZTogQW55T2JqZWN0KSA9PiBfYXR0YWNoQ29udGV4dChwcm94eS5vdmVycmlkZShzY29wZSksIGNvbnRleHQsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBkZWxldGUgb3BlcmF0b3IuXG4gICAgICovXG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgZGVsZXRlIHByb3h5W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBwcm94eVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgZ2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgZ2V0KHRhcmdldCwgcHJvcDogc3RyaW5nLCByZWNlaXZlcikge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLlxuICAgICAqIEFsc28gdXNlZCBieSBPYmplY3QuaGFzT3duUHJvcGVydHkuXG4gICAgICovXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIHRhcmdldC5fZGVzY3JpcHRvcnMuYWxsS2V5c1xuICAgICAgICA/IFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKSA/IHtlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9IDogdW5kZWZpbmVkXG4gICAgICAgIDogUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJveHksIHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZi5cbiAgICAgKi9cbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHByb3h5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgaW4gb3BlcmF0b3IuXG4gICAgICovXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyBhbmQgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scy5cbiAgICAgKi9cbiAgICBvd25LZXlzKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhwcm94eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3Igc2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIHByb3h5W3Byb3BdID0gdmFsdWU7IC8vIHNldCB0byBwcm94eVxuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gY2FjaGVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSkgYXMgQ29udGV4dFByb3h5PFQsIFI+O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVzY3JpcHRvcnMoXG4gIHByb3h5OiBSZXNvbHZlckNhY2hlLFxuICBkZWZhdWx0czogRGVzY3JpcHRvckRlZmF1bHRzID0ge3NjcmlwdGFibGU6IHRydWUsIGluZGV4YWJsZTogdHJ1ZX1cbik6IERlc2NyaXB0b3Ige1xuICBjb25zdCB7X3NjcmlwdGFibGUgPSBkZWZhdWx0cy5zY3JpcHRhYmxlLCBfaW5kZXhhYmxlID0gZGVmYXVsdHMuaW5kZXhhYmxlLCBfYWxsS2V5cyA9IGRlZmF1bHRzLmFsbEtleXN9ID0gcHJveHk7XG4gIHJldHVybiB7XG4gICAgYWxsS2V5czogX2FsbEtleXMsXG4gICAgc2NyaXB0YWJsZTogX3NjcmlwdGFibGUsXG4gICAgaW5kZXhhYmxlOiBfaW5kZXhhYmxlLFxuICAgIGlzU2NyaXB0YWJsZTogaXNGdW5jdGlvbihfc2NyaXB0YWJsZSkgPyBfc2NyaXB0YWJsZSA6ICgpID0+IF9zY3JpcHRhYmxlLFxuICAgIGlzSW5kZXhhYmxlOiBpc0Z1bmN0aW9uKF9pbmRleGFibGUpID8gX2luZGV4YWJsZSA6ICgpID0+IF9pbmRleGFibGVcbiAgfTtcbn1cblxuY29uc3QgcmVhZEtleSA9IChwcmVmaXg6IHN0cmluZywgbmFtZTogc3RyaW5nKSA9PiBwcmVmaXggPyBwcmVmaXggKyBfY2FwaXRhbGl6ZShuYW1lKSA6IG5hbWU7XG5jb25zdCBuZWVkc1N1YlJlc29sdmVyID0gKHByb3A6IHN0cmluZywgdmFsdWU6IHVua25vd24pID0+IGlzT2JqZWN0KHZhbHVlKSAmJiBwcm9wICE9PSAnYWRhcHRlcnMnICYmXG4gIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBudWxsIHx8IHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xuXG5mdW5jdGlvbiBfY2FjaGVkKFxuICB0YXJnZXQ6IEFueU9iamVjdCxcbiAgcHJvcDogc3RyaW5nLFxuICByZXNvbHZlOiAoKSA9PiB1bmtub3duXG4pIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHByb3ApKSB7XG4gICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gcmVzb2x2ZSgpO1xuICAvLyBjYWNoZSB0aGUgcmVzb2x2ZWQgdmFsdWVcbiAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoQ29udGV4dChcbiAgdGFyZ2V0OiBDb250ZXh0Q2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgcmVjZWl2ZXI6IEFueU9iamVjdFxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07IC8vIHJlc29sdmUgZnJvbSBwcm94eVxuXG4gIC8vIHJlc29sdmUgd2l0aCBjb250ZXh0XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSAmJiBkZXNjcmlwdG9ycy5pc1NjcmlwdGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcik7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBkZXNjcmlwdG9ycy5pc0luZGV4YWJsZSk7XG4gIH1cbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgLy8gaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFuIG9iamVjdCwgY3JlYXRlIGEgc3ViIHJlc29sdmVyIGZvciBpdFxuICAgIHZhbHVlID0gX2F0dGFjaENvbnRleHQodmFsdWUsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVNjcmlwdGFibGUoXG4gIHByb3A6IHN0cmluZyxcbiAgZ2V0VmFsdWU6IChjdHg6IEFueU9iamVjdCwgc3ViOiBBbnlPYmplY3QpID0+IHVua25vd24sXG4gIHRhcmdldDogQ29udGV4dENhY2hlLFxuICByZWNlaXZlcjogQW55T2JqZWN0XG4pIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX3N0YWNrfSA9IHRhcmdldDtcbiAgaWYgKF9zdGFjay5oYXMocHJvcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xuICB9XG4gIF9zdGFjay5hZGQocHJvcCk7XG4gIGxldCB2YWx1ZSA9IGdldFZhbHVlKF9jb250ZXh0LCBfc3ViUHJveHkgfHwgcmVjZWl2ZXIpO1xuICBfc3RhY2suZGVsZXRlKHByb3ApO1xuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICAvLyBXaGVuIHNjcmlwdGFibGUgb3B0aW9uIHJldHVybnMgYW4gb2JqZWN0LCBjcmVhdGUgYSByZXNvbHZlciBvbiB0aGF0LlxuICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVBcnJheShcbiAgcHJvcDogc3RyaW5nLFxuICB2YWx1ZTogdW5rbm93bltdLFxuICB0YXJnZXQ6IENvbnRleHRDYWNoZSxcbiAgaXNJbmRleGFibGU6IChrZXk6IHN0cmluZykgPT4gYm9vbGVhblxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuXG4gIGlmICh0eXBlb2YgX2NvbnRleHQuaW5kZXggIT09ICd1bmRlZmluZWQnICYmIGlzSW5kZXhhYmxlKHByb3ApKSB7XG4gICAgcmV0dXJuIHZhbHVlW19jb250ZXh0LmluZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZVswXSkpIHtcbiAgICAvLyBBcnJheSBvZiBvYmplY3RzLCByZXR1cm4gYXJyYXkgb3IgcmVzb2x2ZXJzXG4gICAgY29uc3QgYXJyID0gdmFsdWU7XG4gICAgY29uc3Qgc2NvcGVzID0gX3Byb3h5Ll9zY29wZXMuZmlsdGVyKHMgPT4gcyAhPT0gYXJyKTtcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xuICAgICAgdmFsdWUucHVzaChfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZhbGxiYWNrKFxuICBmYWxsYmFjazogUmVzb2x2ZXJPYmplY3RLZXkgfCAoKHByb3A6IFJlc29sdmVyT2JqZWN0S2V5LCB2YWx1ZTogdW5rbm93bikgPT4gUmVzb2x2ZXJPYmplY3RLZXkpLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICByZXR1cm4gaXNGdW5jdGlvbihmYWxsYmFjaykgPyBmYWxsYmFjayhwcm9wLCB2YWx1ZSkgOiBmYWxsYmFjaztcbn1cblxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5OiBSZXNvbHZlck9iamVjdEtleSwgcGFyZW50OiBBbnlPYmplY3QpID0+IGtleSA9PT0gdHJ1ZSA/IHBhcmVudFxuICA6IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gcmVzb2x2ZU9iamVjdEtleShwYXJlbnQsIGtleSkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGFkZFNjb3BlcyhcbiAgc2V0OiBTZXQ8QW55T2JqZWN0PixcbiAgcGFyZW50U2NvcGVzOiBBbnlPYmplY3RbXSxcbiAga2V5OiBSZXNvbHZlck9iamVjdEtleSxcbiAgcGFyZW50RmFsbGJhY2s6IFJlc29sdmVyT2JqZWN0S2V5LFxuICB2YWx1ZTogdW5rbm93blxuKSB7XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcykge1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgc2V0LmFkZChzY29wZSk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhzY29wZS5fZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBmYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYgZmFsbGJhY2sgIT09IGtleSAmJiBmYWxsYmFjayAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgICAgLy8gV2hlbiB3ZSByZWFjaCB0aGUgZGVzY3JpcHRvciB0aGF0IGRlZmluZXMgYSBuZXcgX2ZhbGxiYWNrLCByZXR1cm4gdGhhdC5cbiAgICAgICAgLy8gVGhlIGZhbGxiYWNrIHdpbGwgcmVzdW1lIHRvIHRoYXQgbmV3IHNjb3BlLlxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY29wZSA9PT0gZmFsc2UgJiYgdHlwZW9mIHBhcmVudEZhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiBrZXkgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBgZmFsc2VgIHJlc3VsdHMgdG8gYGZhbHNlYCwgd2hlbiBmYWxsaW5nIGJhY2sgdG8gZGlmZmVyZW50IGtleS5cbiAgICAgIC8vIEZvciBleGFtcGxlIGBpbnRlcmFjdGlvbmAgZnJvbSBgaG92ZXJgIG9yIGBwbHVnaW5zLnRvb2x0aXBgIGFuZCBgYW5pbWF0aW9uYCBmcm9tIGBhbmltYXRpb25zYFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ViUmVzb2x2ZXIoXG4gIHBhcmVudFNjb3BlczogQW55T2JqZWN0W10sXG4gIHJlc29sdmVyOiBSZXNvbHZlckNhY2hlLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCByb290U2NvcGVzID0gcmVzb2x2ZXIuX3Jvb3RTY29wZXM7XG4gIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHJlc29sdmVyLl9mYWxsYmFjaywgcHJvcCwgdmFsdWUpO1xuICBjb25zdCBhbGxTY29wZXMgPSBbLi4ucGFyZW50U2NvcGVzLCAuLi5yb290U2NvcGVzXTtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxBbnlPYmplY3Q+KCk7XG4gIHNldC5hZGQodmFsdWUpO1xuICBsZXQga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgcHJvcCwgZmFsbGJhY2sgfHwgcHJvcCwgdmFsdWUpO1xuICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVSZXNvbHZlcihBcnJheS5mcm9tKHNldCksIFsnJ10sIHJvb3RTY29wZXMsIGZhbGxiYWNrLFxuICAgICgpID0+IHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCBhcyBzdHJpbmcsIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGFkZFNjb3Blc0Zyb21LZXkoXG4gIHNldDogU2V0PEFueU9iamVjdD4sXG4gIGFsbFNjb3BlczogQW55T2JqZWN0W10sXG4gIGtleTogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGZhbGxiYWNrOiBSZXNvbHZlck9iamVjdEtleSxcbiAgaXRlbTogdW5rbm93blxuKSB7XG4gIHdoaWxlIChrZXkpIHtcbiAgICBrZXkgPSBhZGRTY29wZXMoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2ssIGl0ZW0pO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChcbiAgcmVzb2x2ZXI6IFJlc29sdmVyQ2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5fZ2V0VGFyZ2V0KCk7XG4gIGlmICghKHByb3AgaW4gcGFyZW50KSkge1xuICAgIHBhcmVudFtwcm9wXSA9IHt9O1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHBhcmVudFtwcm9wXTtcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAvLyBGb3IgYXJyYXkgb2Ygb2JqZWN0cywgdGhlIG9iamVjdCBpcyB1c2VkIHRvIHN0b3JlIHVwZGF0ZWQgdmFsdWVzXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0YXJnZXQgfHwge307XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aFByZWZpeGVzKFxuICBwcm9wOiBzdHJpbmcsXG4gIHByZWZpeGVzOiBzdHJpbmdbXSxcbiAgc2NvcGVzOiBBbnlPYmplY3RbXSxcbiAgcHJveHk6IFJlc29sdmVyUHJveHlcbikge1xuICBsZXQgdmFsdWU6IHVua25vd247XG4gIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZShyZWFkS2V5KHByZWZpeCwgcHJvcCksIHNjb3Blcyk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKVxuICAgICAgICA/IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgcHJveHksIHByb3AsIHZhbHVlKVxuICAgICAgICA6IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZShrZXk6IHN0cmluZywgc2NvcGVzOiBBbnlPYmplY3RbXSkge1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGlmICghc2NvcGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNjb3BlW2tleV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0OiBSZXNvbHZlckNhY2hlKSB7XG4gIGxldCBrZXlzID0gdGFyZ2V0Ll9rZXlzO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gdGFyZ2V0Ll9rZXlzID0gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHRhcmdldC5fc2NvcGVzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHNjb3BlczogQW55T2JqZWN0W10pIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NvcGUpLmZpbHRlcihrID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSkpIHtcbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZShcbiAgbWV0YTogQ2hhcnRNZXRhPCdsaW5lJyB8ICdzY2F0dGVyJz4sXG4gIGRhdGE6IEFueU9iamVjdFtdLFxuICBzdGFydDogbnVtYmVyLFxuICBjb3VudDogbnVtYmVyXG4pIHtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7a2V5ID0gJ3InfSA9IHRoaXMuX3BhcnNpbmc7XG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheTx7cjogdW5rbm93bn0+KGNvdW50KTtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBpdGVtOiBBbnlPYmplY3Q7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgIHI6IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIGtleSksIGluZGV4KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbiIsICJpbXBvcnQge2FsbW9zdEVxdWFscywgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBzaWdufSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19pc1BvaW50SW5BcmVhfSBmcm9tICcuL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydEFyZWF9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtTcGxpbmVQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcblxuY29uc3QgRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuXG50eXBlIE9wdGlvbmFsU3BsaW5lUG9pbnQgPSBTcGxpbmVQb2ludCB8IGZhbHNlXG5jb25zdCBnZXRQb2ludCA9IChwb2ludHM6IFNwbGluZVBvaW50W10sIGk6IG51bWJlcik6IE9wdGlvbmFsU3BsaW5lUG9pbnQgPT4gaSA8IHBvaW50cy5sZW5ndGggJiYgIXBvaW50c1tpXS5za2lwICYmIHBvaW50c1tpXTtcbmNvbnN0IGdldFZhbHVlQXhpcyA9IChpbmRleEF4aXM6ICd4JyB8ICd5JykgPT4gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpbmVDdXJ2ZShcbiAgZmlyc3RQb2ludDogU3BsaW5lUG9pbnQsXG4gIG1pZGRsZVBvaW50OiBTcGxpbmVQb2ludCxcbiAgYWZ0ZXJQb2ludDogU3BsaW5lUG9pbnQsXG4gIHQ6IG51bWJlclxuKToge1xuICAgIHByZXZpb3VzOiBTcGxpbmVQb2ludFxuICAgIG5leHQ6IFNwbGluZVBvaW50XG4gIH0ge1xuICAvLyBQcm9wcyB0byBSb2IgU3BlbmNlciBhdCBzY2FsZWQgaW5ub3ZhdGlvbiBmb3IgaGlzIHBvc3Qgb24gc3BsaW5pbmcgYmV0d2VlbiBwb2ludHNcbiAgLy8gaHR0cDovL3NjYWxlZGlubm92YXRpb24uY29tL2FuYWx5dGljcy9zcGxpbmVzL2Fib3V0U3BsaW5lcy5odG1sXG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBtdXN0IGFsc28gcmVzcGVjdCBcInNraXBwZWRcIiBwb2ludHNcblxuICBjb25zdCBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcbiAgY29uc3QgY3VycmVudCA9IG1pZGRsZVBvaW50O1xuICBjb25zdCBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xuICBjb25zdCBkMDEgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoY3VycmVudCwgcHJldmlvdXMpO1xuICBjb25zdCBkMTIgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMobmV4dCwgY3VycmVudCk7XG5cbiAgbGV0IHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuICBsZXQgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG5cbiAgLy8gSWYgYWxsIHBvaW50cyBhcmUgdGhlIHNhbWUsIHMwMSAmIHMwMiB3aWxsIGJlIGluZlxuICBzMDEgPSBpc05hTihzMDEpID8gMCA6IHMwMTtcbiAgczEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XG5cbiAgY29uc3QgZmEgPSB0ICogczAxOyAvLyBzY2FsaW5nIGZhY3RvciBmb3IgdHJpYW5nbGUgVGFcbiAgY29uc3QgZmIgPSB0ICogczEyO1xuXG4gIHJldHVybiB7XG4gICAgcHJldmlvdXM6IHtcbiAgICAgIHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9LFxuICAgIG5leHQ6IHtcbiAgICAgIHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQWRqdXN0IHRhbmdlbnRzIHRvIGVuc3VyZSBtb25vdG9uaWMgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtb25vdG9uZUFkanVzdChwb2ludHM6IFNwbGluZVBvaW50W10sIGRlbHRhSzogbnVtYmVyW10sIG1LOiBudW1iZXJbXSkge1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBhbHBoYUs6IG51bWJlciwgYmV0YUs6IG51bWJlciwgdGF1SzogbnVtYmVyLCBzcXVhcmVkTWFnbml0dWRlOiBudW1iZXIsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50IHx8ICFwb2ludEFmdGVyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoYWxtb3N0RXF1YWxzKGRlbHRhS1tpXSwgMCwgRVBTSUxPTikpIHtcbiAgICAgIG1LW2ldID0gbUtbaSArIDFdID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGFscGhhSyA9IG1LW2ldIC8gZGVsdGFLW2ldO1xuICAgIGJldGFLID0gbUtbaSArIDFdIC8gZGVsdGFLW2ldO1xuICAgIHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuICAgIGlmIChzcXVhcmVkTWFnbml0dWRlIDw9IDkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuICAgIG1LW2ldID0gYWxwaGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgICBtS1tpICsgMV0gPSBiZXRhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ub3RvbmVDb21wdXRlKHBvaW50czogU3BsaW5lUG9pbnRbXSwgbUs6IG51bWJlcltdLCBpbmRleEF4aXM6ICd4JyB8ICd5JyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGRlbHRhOiBudW1iZXIsIHBvaW50QmVmb3JlOiBPcHRpb25hbFNwbGluZVBvaW50LCBwb2ludEN1cnJlbnQ6IE9wdGlvbmFsU3BsaW5lUG9pbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGlQaXhlbCA9IHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgIGNvbnN0IHZQaXhlbCA9IHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdO1xuICAgIGlmIChwb2ludEJlZm9yZSkge1xuICAgICAgZGVsdGEgPSAoaVBpeGVsIC0gcG9pbnRCZWZvcmVbaW5kZXhBeGlzXSkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke2luZGV4QXhpc31gXSA9IGlQaXhlbCAtIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCAtIGRlbHRhICogbUtbaV07XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBkZWx0YSA9IChwb2ludEFmdGVyW2luZGV4QXhpc10gLSBpUGl4ZWwpIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgKyBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgKyBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyBCw6l6aWVyIGNvbnRyb2wgcG9pbnRzIGluIGEgc2ltaWxhciB3YXkgdGhhbiB8c3BsaW5lQ3VydmV8LFxuICogYnV0IHByZXNlcnZlcyBtb25vdG9uaWNpdHkgb2YgdGhlIHByb3ZpZGVkIGRhdGEgYW5kIGVuc3VyZXMgbm8gbG9jYWwgZXh0cmVtdW1zIGFyZSBhZGRlZFxuICogYmV0d2VlbiB0aGUgZGF0YXNldCBkaXNjcmV0ZSBwb2ludHMgZHVlIHRvIHRoZSBpbnRlcnBvbGF0aW9uLlxuICogU2VlIDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9ub3RvbmVfY3ViaWNfaW50ZXJwb2xhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHM6IFNwbGluZVBvaW50W10sIGluZGV4QXhpczogJ3gnIHwgJ3knID0gJ3gnKSB7XG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCBkZWx0YUs6IG51bWJlcltdID0gQXJyYXkocG9pbnRzTGVuKS5maWxsKDApO1xuICBjb25zdCBtSzogbnVtYmVyW10gPSBBcnJheShwb2ludHNMZW4pO1xuXG4gIC8vIENhbGN1bGF0ZSBzbG9wZXMgKGRlbHRhSykgYW5kIGluaXRpYWxpemUgdGFuZ2VudHMgKG1LKVxuICBsZXQgaSwgcG9pbnRCZWZvcmU6IE9wdGlvbmFsU3BsaW5lUG9pbnQsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgY29uc3Qgc2xvcGVEZWx0YSA9IHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuXG4gICAgICAvLyBJbiB0aGUgY2FzZSBvZiB0d28gcG9pbnRzIHRoYXQgYXBwZWFyIGF0IHRoZSBzYW1lIHggcGl4ZWwsIHNsb3BlRGVsdGFYIGlzIDBcbiAgICAgIGRlbHRhS1tpXSA9IHNsb3BlRGVsdGEgIT09IDAgPyAocG9pbnRBZnRlclt2YWx1ZUF4aXNdIC0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc10pIC8gc2xvcGVEZWx0YSA6IDA7XG4gICAgfVxuICAgIG1LW2ldID0gIXBvaW50QmVmb3JlID8gZGVsdGFLW2ldXG4gICAgICA6ICFwb2ludEFmdGVyID8gZGVsdGFLW2kgLSAxXVxuICAgICAgICA6IChzaWduKGRlbHRhS1tpIC0gMV0pICE9PSBzaWduKGRlbHRhS1tpXSkpID8gMFxuICAgICAgICAgIDogKGRlbHRhS1tpIC0gMV0gKyBkZWx0YUtbaV0pIC8gMjtcbiAgfVxuXG4gIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSyk7XG5cbiAgbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyk7XG59XG5cbmZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdDogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xufVxuXG5mdW5jdGlvbiBjYXBCZXppZXJQb2ludHMocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBhcmVhOiBDaGFydEFyZWEpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBpbkFyZWEsIGluQXJlYVByZXY7XG4gIGxldCBpbkFyZWFOZXh0ID0gX2lzUG9pbnRJbkFyZWEocG9pbnRzWzBdLCBhcmVhKTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbkFyZWFQcmV2ID0gaW5BcmVhO1xuICAgIGluQXJlYSA9IGluQXJlYU5leHQ7XG4gICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcbiAgICBpZiAoIWluQXJlYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgIGlmIChpbkFyZWFQcmV2KSB7XG4gICAgICBwb2ludC5jcDF4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDF5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICAgIGlmIChpbkFyZWFOZXh0KSB7XG4gICAgICBwb2ludC5jcDJ4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDJ5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKFxuICBwb2ludHM6IFNwbGluZVBvaW50W10sXG4gIG9wdGlvbnMsXG4gIGFyZWE6IENoYXJ0QXJlYSxcbiAgbG9vcDogYm9vbGVhbixcbiAgaW5kZXhBeGlzOiAneCcgfCAneSdcbikge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHBvaW50OiBTcGxpbmVQb2ludCwgY29udHJvbFBvaW50czogUmV0dXJuVHlwZTx0eXBlb2Ygc3BsaW5lQ3VydmU+O1xuXG4gIC8vIE9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgYXJlIGRyYXduIGluIGNhc2UgdGhlIHNwYW5HYXBzIG9wdGlvbiBpcyB1c2VkXG4gIGlmIChvcHRpb25zLnNwYW5HYXBzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLmZpbHRlcigocHQpID0+ICFwdC5za2lwKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJldiA9IGxvb3AgPyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIDogcG9pbnRzWzBdO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnRyb2xQb2ludHMgPSBzcGxpbmVDdXJ2ZShcbiAgICAgICAgcHJldixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHBvaW50c1tNYXRoLm1pbihpICsgMSwgaWxlbiAtIChsb29wID8gMCA6IDEpKSAlIGlsZW5dLFxuICAgICAgICBvcHRpb25zLnRlbnNpb25cbiAgICAgICk7XG4gICAgICBwb2ludC5jcDF4ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xuICAgICAgcG9pbnQuY3AxeSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcbiAgICAgIHBvaW50LmNwMnggPSBjb250cm9sUG9pbnRzLm5leHQueDtcbiAgICAgIHBvaW50LmNwMnkgPSBjb250cm9sUG9pbnRzLm5leHQueTtcbiAgICAgIHByZXYgPSBwb2ludDtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5jYXBCZXppZXJQb2ludHMpIHtcbiAgICBjYXBCZXppZXJQb2ludHMocG9pbnRzLCBhcmVhKTtcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtDaGFydEFyZWEsIFNjYWxlfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSBDaGFydCBmcm9tICcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRFdmVudH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHtJTkZJTklUWX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIE5vdGU6IHR5cGVkZWZzIGFyZSBhdXRvLWV4cG9ydGVkLCBzbyB1c2UgYSBtYWRlLXVwIGBkb21gIG5hbWVzcGFjZSB3aGVyZVxuICogbmVjZXNzYXJ5IHRvIGF2b2lkIGR1cGxpY2F0ZXMgd2l0aCBgZXhwb3J0ICogZnJvbSAnLi9oZWxwZXJzYDsgc2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQ2MDExXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gZG9tLkNoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICovXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0RvbVN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRQYXJlbnROb2RlKGRvbU5vZGU6IEhUTUxDYW52YXNFbGVtZW50KTogSFRNTENhbnZhc0VsZW1lbnQge1xuICBsZXQgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcbiAgICBwYXJlbnQgPSAocGFyZW50IGFzIFNoYWRvd1Jvb3QpLmhvc3Q7XG4gIH1cbiAgcmV0dXJuIHBhcmVudCBhcyBIVE1MQ2FudmFzRWxlbWVudDtcbn1cblxuLyoqXG4gKiBjb252ZXJ0IG1heC13aWR0aC9tYXgtaGVpZ2h0IHZhbHVlcyB0aGF0IG1heSBiZSBwZXJjZW50YWdlcyBpbnRvIGEgbnVtYmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBub2RlOiBIVE1MRWxlbWVudCwgcGFyZW50UHJvcGVydHk6IHN0cmluZykge1xuICBsZXQgdmFsdWVJblBpeGVsczogbnVtYmVyO1xuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHBhcnNlSW50KHN0eWxlVmFsdWUsIDEwKTtcblxuICAgIGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgIC8vIHBlcmNlbnRhZ2UgKiBzaXplIGluIGRpbWVuc2lvblxuICAgICAgdmFsdWVJblBpeGVscyA9ICh2YWx1ZUluUGl4ZWxzIC8gMTAwKSAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlSW5QaXhlbHM7XG59XG5cbmNvbnN0IGdldENvbXB1dGVkU3R5bGUgPSAoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBDU1NTdHlsZURlY2xhcmF0aW9uID0+XG4gIGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBwcm9wZXJ0eTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xufVxuXG5jb25zdCBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlczogQ1NTU3R5bGVEZWNsYXJhdGlvbiwgc3R5bGU6IHN0cmluZywgc3VmZml4Pzogc3RyaW5nKTogQ2hhcnRBcmVhIHtcbiAgY29uc3QgcmVzdWx0ID0ge30gYXMgQ2hhcnRBcmVhO1xuICBzdWZmaXggPSBzdWZmaXggPyAnLScgKyBzdWZmaXggOiAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbaV07XG4gICAgcmVzdWx0W3Bvc10gPSBwYXJzZUZsb2F0KHN0eWxlc1tzdHlsZSArICctJyArIHBvcyArIHN1ZmZpeF0pIHx8IDA7XG4gIH1cbiAgcmVzdWx0LndpZHRoID0gcmVzdWx0LmxlZnQgKyByZXN1bHQucmlnaHQ7XG4gIHJlc3VsdC5oZWlnaHQgPSByZXN1bHQudG9wICsgcmVzdWx0LmJvdHRvbTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgdXNlT2Zmc2V0UG9zID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCB0YXJnZXQ6IEhUTUxFbGVtZW50IHwgRXZlbnRUYXJnZXQpID0+XG4gICh4ID4gMCB8fCB5ID4gMCkgJiYgKCF0YXJnZXQgfHwgISh0YXJnZXQgYXMgSFRNTEVsZW1lbnQpLnNoYWRvd1Jvb3QpO1xuXG4vKipcbiAqIEBwYXJhbSBlXG4gKiBAcGFyYW0gY2FudmFzXG4gKiBAcmV0dXJucyBDYW52YXMgcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FudmFzUG9zaXRpb24oXG4gIGU6IEV2ZW50IHwgVG91Y2hFdmVudCB8IE1vdXNlRXZlbnQsXG4gIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnRcbik6IHtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIGJveDogYm9vbGVhbjtcbiAgfSB7XG4gIGNvbnN0IHRvdWNoZXMgPSAoZSBhcyBUb3VjaEV2ZW50KS50b3VjaGVzO1xuICBjb25zdCBzb3VyY2UgPSAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA/IHRvdWNoZXNbMF0gOiBlKSBhcyBNb3VzZUV2ZW50O1xuICBjb25zdCB7b2Zmc2V0WCwgb2Zmc2V0WX0gPSBzb3VyY2UgYXMgTW91c2VFdmVudDtcbiAgbGV0IGJveCA9IGZhbHNlO1xuICBsZXQgeCwgeTtcbiAgaWYgKHVzZU9mZnNldFBvcyhvZmZzZXRYLCBvZmZzZXRZLCBlLnRhcmdldCkpIHtcbiAgICB4ID0gb2Zmc2V0WDtcbiAgICB5ID0gb2Zmc2V0WTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHggPSBzb3VyY2UuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICB5ID0gc291cmNlLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICBib3ggPSB0cnVlO1xuICB9XG4gIHJldHVybiB7eCwgeSwgYm94fTtcbn1cblxuLyoqXG4gKiBHZXRzIGFuIGV2ZW50J3MgeCwgeSBjb29yZGluYXRlcywgcmVsYXRpdmUgdG8gdGhlIGNoYXJ0IGFyZWFcbiAqIEBwYXJhbSBldmVudFxuICogQHBhcmFtIGNoYXJ0XG4gKiBAcmV0dXJucyB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBldmVudFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKFxuICBldmVudDogRXZlbnQgfCBDaGFydEV2ZW50IHwgVG91Y2hFdmVudCB8IE1vdXNlRXZlbnQsXG4gIGNoYXJ0OiBDaGFydFxuKTogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHtcbiAgaWYgKCduYXRpdmUnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgY29uc3Qge2NhbnZhcywgY3VycmVudERldmljZVBpeGVsUmF0aW99ID0gY2hhcnQ7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBib3JkZXJCb3ggPSBzdHlsZS5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgY29uc3Qge3gsIHksIGJveH0gPSBnZXRDYW52YXNQb3NpdGlvbihldmVudCwgY2FudmFzKTtcbiAgY29uc3QgeE9mZnNldCA9IHBhZGRpbmdzLmxlZnQgKyAoYm94ICYmIGJvcmRlcnMubGVmdCk7XG4gIGNvbnN0IHlPZmZzZXQgPSBwYWRkaW5ncy50b3AgKyAoYm94ICYmIGJvcmRlcnMudG9wKTtcblxuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY2hhcnQ7XG4gIGlmIChib3JkZXJCb3gpIHtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZCgoeCAtIHhPZmZzZXQpIC8gd2lkdGggKiBjYW52YXMud2lkdGggLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyksXG4gICAgeTogTWF0aC5yb3VuZCgoeSAtIHlPZmZzZXQpIC8gaGVpZ2h0ICogY2FudmFzLmhlaWdodCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250YWluZXJTaXplKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogUGFydGlhbDxTY2FsZT4ge1xuICBsZXQgbWF4V2lkdGg6IG51bWJlciwgbWF4SGVpZ2h0OiBudW1iZXI7XG5cbiAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICB3aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIGhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIHRoaXMgaXMgdGhlIGJvcmRlciBib3ggb2YgdGhlIGNvbnRhaW5lclxuICAgICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICBjb25zdCBjb250YWluZXJCb3JkZXIgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdwYWRkaW5nJyk7XG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGggLSBjb250YWluZXJQYWRkaW5nLndpZHRoIC0gY29udGFpbmVyQm9yZGVyLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLSBjb250YWluZXJQYWRkaW5nLmhlaWdodCAtIGNvbnRhaW5lckJvcmRlci5oZWlnaHQ7XG4gICAgICBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4V2lkdGgsIGNvbnRhaW5lciwgJ2NsaWVudFdpZHRoJyk7XG4gICAgICBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heEhlaWdodCwgY29udGFpbmVyLCAnY2xpZW50SGVpZ2h0Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG1heFdpZHRoOiBtYXhXaWR0aCB8fCBJTkZJTklUWSxcbiAgICBtYXhIZWlnaHQ6IG1heEhlaWdodCB8fCBJTkZJTklUWVxuICB9O1xufVxuXG5jb25zdCByb3VuZDEgPSAodjogbnVtYmVyKSA9PiBNYXRoLnJvdW5kKHYgKiAxMCkgLyAxMDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXhpbXVtU2l6ZShcbiAgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCxcbiAgYmJXaWR0aD86IG51bWJlcixcbiAgYmJIZWlnaHQ/OiBudW1iZXIsXG4gIGFzcGVjdFJhdGlvPzogbnVtYmVyXG4pOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH0ge1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgbWFyZ2lucyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ21hcmdpbicpO1xuICBjb25zdCBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoc3R5bGUubWF4V2lkdGgsIGNhbnZhcywgJ2NsaWVudFdpZHRoJykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoc3R5bGUubWF4SGVpZ2h0LCBjYW52YXMsICdjbGllbnRIZWlnaHQnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgY29udGFpbmVyU2l6ZSA9IGdldENvbnRhaW5lclNpemUoY2FudmFzLCBiYldpZHRoLCBiYkhlaWdodCk7XG4gIGxldCB7d2lkdGgsIGhlaWdodH0gPSBjb250YWluZXJTaXplO1xuXG4gIGlmIChzdHlsZS5ib3hTaXppbmcgPT09ICdjb250ZW50LWJveCcpIHtcbiAgICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIC0gbWFyZ2lucy53aWR0aCk7XG4gIGhlaWdodCA9IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gd2lkdGggLyBhc3BlY3RSYXRpbyA6IGhlaWdodCAtIG1hcmdpbnMuaGVpZ2h0KTtcbiAgd2lkdGggPSByb3VuZDEoTWF0aC5taW4od2lkdGgsIG1heFdpZHRoLCBjb250YWluZXJTaXplLm1heFdpZHRoKSk7XG4gIGhlaWdodCA9IHJvdW5kMShNYXRoLm1pbihoZWlnaHQsIG1heEhlaWdodCwgY29udGFpbmVyU2l6ZS5tYXhIZWlnaHQpKTtcbiAgaWYgKHdpZHRoICYmICFoZWlnaHQpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDY1OVxuICAgIC8vIElmIHRoZSBjYW52YXMgaGFzIHdpZHRoLCBidXQgbm8gaGVpZ2h0LCBkZWZhdWx0IHRvIGFzcGVjdFJhdGlvIG9mIDIgKGNhbnZhcyBkZWZhdWx0KVxuICAgIGhlaWdodCA9IHJvdW5kMSh3aWR0aCAvIDIpO1xuICB9XG5cbiAgY29uc3QgbWFpbnRhaW5IZWlnaHQgPSBiYldpZHRoICE9PSB1bmRlZmluZWQgfHwgYmJIZWlnaHQgIT09IHVuZGVmaW5lZDtcblxuICBpZiAobWFpbnRhaW5IZWlnaHQgJiYgYXNwZWN0UmF0aW8gJiYgY29udGFpbmVyU2l6ZS5oZWlnaHQgJiYgaGVpZ2h0ID4gY29udGFpbmVyU2l6ZS5oZWlnaHQpIHtcbiAgICBoZWlnaHQgPSBjb250YWluZXJTaXplLmhlaWdodDtcbiAgICB3aWR0aCA9IHJvdW5kMShNYXRoLmZsb29yKGhlaWdodCAqIGFzcGVjdFJhdGlvKSk7XG4gIH1cblxuICByZXR1cm4ge3dpZHRoLCBoZWlnaHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSBjaGFydFxuICogQHBhcmFtIGZvcmNlUmF0aW9cbiAqIEBwYXJhbSBmb3JjZVN0eWxlXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjYW52YXMgY29udGV4dCBzaXplIG9yIHRyYW5zZm9ybWF0aW9uIGhhcyBjaGFuZ2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV0aW5hU2NhbGUoXG4gIGNoYXJ0OiBDaGFydCxcbiAgZm9yY2VSYXRpbzogbnVtYmVyLFxuICBmb3JjZVN0eWxlPzogYm9vbGVhblxuKTogYm9vbGVhbiB8IHZvaWQge1xuICBjb25zdCBwaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAxO1xuICBjb25zdCBkZXZpY2VIZWlnaHQgPSBNYXRoLmZsb29yKGNoYXJ0LmhlaWdodCAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VXaWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGggKiBwaXhlbFJhdGlvKTtcblxuICBjaGFydC5oZWlnaHQgPSBNYXRoLmZsb29yKGNoYXJ0LmhlaWdodCk7XG4gIGNoYXJ0LndpZHRoID0gTWF0aC5mbG9vcihjaGFydC53aWR0aCk7XG5cbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuXG4gIC8vIElmIG5vIHN0eWxlIGhhcyBiZWVuIHNldCBvbiB0aGUgY2FudmFzLCB0aGUgcmVuZGVyIHNpemUgaXMgdXNlZCBhcyBkaXNwbGF5IHNpemUsXG4gIC8vIG1ha2luZyB0aGUgY2hhcnQgdmlzdWFsbHkgYmlnZ2VyLCBzbyBsZXQncyBlbmZvcmNlIGl0IHRvIHRoZSBcImNvcnJlY3RcIiB2YWx1ZXMuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzU3NVxuICBpZiAoY2FudmFzLnN0eWxlICYmIChmb3JjZVN0eWxlIHx8ICghY2FudmFzLnN0eWxlLmhlaWdodCAmJiAhY2FudmFzLnN0eWxlLndpZHRoKSkpIHtcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7Y2hhcnQuaGVpZ2h0fXB4YDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtjaGFydC53aWR0aH1weGA7XG4gIH1cblxuICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IHBpeGVsUmF0aW9cbiAgICAgIHx8IGNhbnZhcy5oZWlnaHQgIT09IGRldmljZUhlaWdodFxuICAgICAgfHwgY2FudmFzLndpZHRoICE9PSBkZXZpY2VXaWR0aCkge1xuICAgIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ID0gZGV2aWNlSGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCA9IGRldmljZVdpZHRoO1xuICAgIGNoYXJ0LmN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIERldGVjdHMgc3VwcG9ydCBmb3Igb3B0aW9ucyBvYmplY3QgYXJndW1lbnQgaW4gYWRkRXZlbnRMaXN0ZW5lci5cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI1NhZmVseV9kZXRlY3Rpbmdfb3B0aW9uX3N1cHBvcnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHsgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBicm93c2VyIGF0dGVtcHRzIHRvIGFjY2VzcyB0aGUgcGFzc2l2ZSBwcm9wZXJ0eS5cbiAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGFzIEV2ZW50TGlzdGVuZXJPcHRpb25zO1xuXG4gICAgaWYgKF9pc0RvbVN1cHBvcnRlZCgpKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gIH1cbiAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG59KCkpO1xuXG4vKipcbiAqIFRoZSBcInVzZWRcIiBzaXplIGlzIHRoZSBmaW5hbCB2YWx1ZSBvZiBhIGRpbWVuc2lvbiBwcm9wZXJ0eSBhZnRlciBhbGwgY2FsY3VsYXRpb25zIGhhdmVcbiAqIGJlZW4gcGVyZm9ybWVkLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjb21wdXRlZCBzdHlsZSBvZiBgZWxlbWVudGAgYnV0IHJldHVybnMgdW5kZWZpbmVkXG4gKiBpZiB0aGUgY29tcHV0ZWQgc3R5bGUgaXMgbm90IGV4cHJlc3NlZCBpbiBwaXhlbHMuIFRoYXQgY2FuIGhhcHBlbiBpbiBzb21lIGNhc2VzIHdoZXJlXG4gKiBgZWxlbWVudGAgaGFzIGEgc2l6ZSByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGFuZCB0aGlzIGxhc3Qgb25lIGlzIG5vdCB5ZXQgZGlzcGxheWVkLFxuICogZm9yIGV4YW1wbGUgYmVjYXVzZSBvZiBgZGlzcGxheTogbm9uZWAgb24gYSBwYXJlbnQgbm9kZS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3VzZWRfdmFsdWVcbiAqIEByZXR1cm5zIFNpemUgaW4gcGl4ZWxzIG9yIHVuZGVmaW5lZCBpZiB1bmtub3duLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkVXNlZFNpemUoXG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50LFxuICBwcm9wZXJ0eTogJ3dpZHRoJyB8ICdoZWlnaHQnXG4pOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBjb25zdCB2YWx1ZSA9IGdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9eKFxcZCspKFxcLlxcZCspP3B4JC8pO1xuICByZXR1cm4gbWF0Y2hlcyA/ICttYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xufVxuIiwgImltcG9ydCB0eXBlIHtQb2ludCwgU3BsaW5lUG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9wb2ludEluTGluZShwMTogUG9pbnQsIHAyOiBQb2ludCwgdDogbnVtYmVyLCBtb2RlPykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBwMS55ICsgdCAqIChwMi55IC0gcDEueSlcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uKFxuICBwMTogUG9pbnQsXG4gIHAyOiBQb2ludCxcbiAgdDogbnVtYmVyLCBtb2RlOiAnbWlkZGxlJyB8ICdhZnRlcicgfCB1bmtub3duXG4pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogbW9kZSA9PT0gJ21pZGRsZScgPyB0IDwgMC41ID8gcDEueSA6IHAyLnlcbiAgICAgIDogbW9kZSA9PT0gJ2FmdGVyJyA/IHQgPCAxID8gcDEueSA6IHAyLnlcbiAgICAgICAgOiB0ID4gMCA/IHAyLnkgOiBwMS55XG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9iZXppZXJJbnRlcnBvbGF0aW9uKHAxOiBTcGxpbmVQb2ludCwgcDI6IFNwbGluZVBvaW50LCB0OiBudW1iZXIsIG1vZGU/KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGNvbnN0IGNwMSA9IHt4OiBwMS5jcDJ4LCB5OiBwMS5jcDJ5fTtcbiAgY29uc3QgY3AyID0ge3g6IHAyLmNwMXgsIHk6IHAyLmNwMXl9O1xuICBjb25zdCBhID0gX3BvaW50SW5MaW5lKHAxLCBjcDEsIHQpO1xuICBjb25zdCBiID0gX3BvaW50SW5MaW5lKGNwMSwgY3AyLCB0KTtcbiAgY29uc3QgYyA9IF9wb2ludEluTGluZShjcDIsIHAyLCB0KTtcbiAgY29uc3QgZCA9IF9wb2ludEluTGluZShhLCBiLCB0KTtcbiAgY29uc3QgZSA9IF9wb2ludEluTGluZShiLCBjLCB0KTtcbiAgcmV0dXJuIF9wb2ludEluTGluZShkLCBlLCB0KTtcbn1cbiIsICJleHBvcnQgaW50ZXJmYWNlIFJUTEFkYXB0ZXIge1xuICB4KHg6IG51bWJlcik6IG51bWJlcjtcbiAgc2V0V2lkdGgodzogbnVtYmVyKTogdm9pZDtcbiAgdGV4dEFsaWduKGFsaWduOiAnY2VudGVyJyB8ICdsZWZ0JyB8ICdyaWdodCcpOiAnY2VudGVyJyB8ICdsZWZ0JyB8ICdyaWdodCc7XG4gIHhQbHVzKHg6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IG51bWJlcjtcbiAgbGVmdEZvckx0cih4OiBudW1iZXIsIGl0ZW1XaWR0aDogbnVtYmVyKTogbnVtYmVyO1xufVxuXG5jb25zdCBnZXRSaWdodFRvTGVmdEFkYXB0ZXIgPSBmdW5jdGlvbihyZWN0WDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKTogUlRMQWRhcHRlciB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4gcmVjdFggKyByZWN0WCArIHdpZHRoIC0geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHtcbiAgICAgIHdpZHRoID0gdztcbiAgICB9LFxuICAgIHRleHRBbGlnbihhbGlnbikge1xuICAgICAgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICByZXR1cm4gYWxpZ247XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH0sXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB4IC0gdmFsdWU7XG4gICAgfSxcbiAgICBsZWZ0Rm9yTHRyKHgsIGl0ZW1XaWR0aCkge1xuICAgICAgcmV0dXJuIHggLSBpdGVtV2lkdGg7XG4gICAgfSxcbiAgfTtcbn07XG5cbmNvbnN0IGdldExlZnRUb1JpZ2h0QWRhcHRlciA9IGZ1bmN0aW9uKCk6IFJUTEFkYXB0ZXIge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB9LFxuICAgIHRleHRBbGlnbihhbGlnbikge1xuICAgICAgcmV0dXJuIGFsaWduO1xuICAgIH0sXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB4ICsgdmFsdWU7XG4gICAgfSxcbiAgICBsZWZ0Rm9yTHRyKHgsIF9pdGVtV2lkdGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gIH07XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UnRsQWRhcHRlcihydGw6IGJvb2xlYW4sIHJlY3RYOiBudW1iZXIsIHdpZHRoOiBudW1iZXIpIHtcbiAgcmV0dXJuIHJ0bCA/IGdldFJpZ2h0VG9MZWZ0QWRhcHRlcihyZWN0WCwgd2lkdGgpIDogZ2V0TGVmdFRvUmlnaHRBZGFwdGVyKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGRpcmVjdGlvbjogJ2x0cicgfCAncnRsJykge1xuICBsZXQgc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24sIG9yaWdpbmFsOiBbc3RyaW5nLCBzdHJpbmddO1xuICBpZiAoZGlyZWN0aW9uID09PSAnbHRyJyB8fCBkaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgc3R5bGUgPSBjdHguY2FudmFzLnN0eWxlO1xuICAgIG9yaWdpbmFsID0gW1xuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJyksXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KCdkaXJlY3Rpb24nKSxcbiAgICBdO1xuXG4gICAgc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIGRpcmVjdGlvbiwgJ2ltcG9ydGFudCcpO1xuICAgIChjdHggYXMgeyBwcmV2VGV4dERpcmVjdGlvbj86IFtzdHJpbmcsIHN0cmluZ10gfSkucHJldlRleHREaXJlY3Rpb24gPSBvcmlnaW5hbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIG9yaWdpbmFsPzogW3N0cmluZywgc3RyaW5nXSkge1xuICBpZiAob3JpZ2luYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSAoY3R4IGFzIHsgcHJldlRleHREaXJlY3Rpb24/OiBbc3RyaW5nLCBzdHJpbmddIH0pLnByZXZUZXh0RGlyZWN0aW9uO1xuICAgIGN0eC5jYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIG9yaWdpbmFsWzBdLCBvcmlnaW5hbFsxXSk7XG4gIH1cbn1cbiIsICJpbXBvcnQge19hbmdsZUJldHdlZW4sIF9hbmdsZURpZmYsIF9pc0JldHdlZW4sIF9ub3JtYWxpemVBbmdsZX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0fSBmcm9tICcuL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2lzUGF0dGVybk9yR3JhZGllbnR9IGZyb20gJy4vaGVscGVycy5jb2xvci5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcycpLmRlZmF1bHQgfSBMaW5lRWxlbWVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKiBAdHlwZWRlZiB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBsb29wOiBib29sZWFuLCBzdHlsZT86IGFueX19IFNlZ21lbnRcbiAqL1xuXG5mdW5jdGlvbiBwcm9wZXJ0eUZuKHByb3BlcnR5KSB7XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgIHJldHVybiB7XG4gICAgICBiZXR3ZWVuOiBfYW5nbGVCZXR3ZWVuLFxuICAgICAgY29tcGFyZTogX2FuZ2xlRGlmZixcbiAgICAgIG5vcm1hbGl6ZTogX25vcm1hbGl6ZUFuZ2xlLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiZXR3ZWVuOiBfaXNCZXR3ZWVuLFxuICAgIGNvbXBhcmU6IChhLCBiKSA9PiBhIC0gYixcbiAgICBub3JtYWxpemU6IHggPT4geFxuICB9O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTZWdtZW50KHtzdGFydCwgZW5kLCBjb3VudCwgbG9vcCwgc3R5bGV9KSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0ICUgY291bnQsXG4gICAgZW5kOiBlbmQgJSBjb3VudCxcbiAgICBsb29wOiBsb29wICYmIChlbmQgLSBzdGFydCArIDEpICUgY291bnQgPT09IDAsXG4gICAgc3R5bGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3Qge2JldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCB7c3RhcnQsIGVuZCwgbG9vcH0gPSBzZWdtZW50O1xuICBsZXQgaSwgaWxlbjtcblxuICBpZiAobG9vcCkge1xuICAgIHN0YXJ0ICs9IGNvdW50O1xuICAgIGVuZCArPSBjb3VudDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICghYmV0d2Vlbihub3JtYWxpemUocG9pbnRzW3N0YXJ0ICUgY291bnRdW3Byb3BlcnR5XSksIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXJ0LS07XG4gICAgICBlbmQtLTtcbiAgICB9XG4gICAgc3RhcnQgJT0gY291bnQ7XG4gICAgZW5kICU9IGNvdW50O1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgZW5kICs9IGNvdW50O1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGU6IHNlZ21lbnQuc3R5bGV9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN1Yi1zZWdtZW50KHMpIG9mIGEgbGluZSBzZWdtZW50IHRoYXQgZmFsbCBpbiB0aGUgZ2l2ZW4gYm91bmRzXG4gKiBAcGFyYW0ge29iamVjdH0gc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuc3RhcnQgLSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LmVuZCAtIGVuZCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VnbWVudC5sb29wIC0gaW5kaWNhdGVzIHRoYXQgdGhlIHNlZ21lbnQgaXMgYSBsb29wXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnQuc3R5bGVdIC0gc2VnbWVudCBzdHlsZVxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzIC0gdGhlIHBvaW50cyB0aGF0IHRoaXMgc2VnbWVudCByZWZlcnMgdG9cbiAqIEBwYXJhbSB7b2JqZWN0fSBbYm91bmRzXVxuICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kcy5wcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eSBvZiBhIGBQb2ludEVsZW1lbnRgIHdlIGFyZSBib3VuZGluZy4gYHhgLCBgeWAgb3IgYGFuZ2xlYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuc3RhcnQgLSBzdGFydCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuZW5kIC0gZW5kIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICogQHByaXZhdGVcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBfYm91bmRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKSB7XG4gIGlmICghYm91bmRzKSB7XG4gICAgcmV0dXJuIFtzZWdtZW50XTtcbiAgfVxuXG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQ6IHN0YXJ0Qm91bmQsIGVuZDogZW5kQm91bmR9ID0gYm91bmRzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHtjb21wYXJlLCBiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IHtzdGFydCwgZW5kLCBsb29wLCBzdHlsZX0gPSBnZXRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKTtcblxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICBsZXQgc3ViU3RhcnQgPSBudWxsO1xuICBsZXQgdmFsdWUsIHBvaW50LCBwcmV2VmFsdWU7XG5cbiAgY29uc3Qgc3RhcnRJc0JlZm9yZSA9ICgpID0+IGJldHdlZW4oc3RhcnRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSkgJiYgY29tcGFyZShzdGFydEJvdW5kLCBwcmV2VmFsdWUpICE9PSAwO1xuICBjb25zdCBlbmRJc0JlZm9yZSA9ICgpID0+IGNvbXBhcmUoZW5kQm91bmQsIHZhbHVlKSA9PT0gMCB8fCBiZXR3ZWVuKGVuZEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKTtcbiAgY29uc3Qgc2hvdWxkU3RhcnQgPSAoKSA9PiBpbnNpZGUgfHwgc3RhcnRJc0JlZm9yZSgpO1xuICBjb25zdCBzaG91bGRTdG9wID0gKCkgPT4gIWluc2lkZSB8fCBlbmRJc0JlZm9yZSgpO1xuXG4gIGZvciAobGV0IGkgPSBzdGFydCwgcHJldiA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbaSAlIGNvdW50XTtcblxuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZShwb2ludFtwcm9wZXJ0eV0pO1xuXG4gICAgaWYgKHZhbHVlID09PSBwcmV2VmFsdWUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGluc2lkZSA9IGJldHdlZW4odmFsdWUsIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKTtcblxuICAgIGlmIChzdWJTdGFydCA9PT0gbnVsbCAmJiBzaG91bGRTdGFydCgpKSB7XG4gICAgICBzdWJTdGFydCA9IGNvbXBhcmUodmFsdWUsIHN0YXJ0Qm91bmQpID09PSAwID8gaSA6IHByZXY7XG4gICAgfVxuXG4gICAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsICYmIHNob3VsZFN0b3AoKSkge1xuICAgICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQ6IGksIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgICAgIHN1YlN0YXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgcHJldiA9IGk7XG4gICAgcHJldlZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBpZiAoc3ViU3RhcnQgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZCwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNlZ21lbnRzIG9mIHRoZSBsaW5lIHRoYXQgYXJlIGluc2lkZSBnaXZlbiBib3VuZHNcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYm91bmRzXVxuICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kcy5wcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgYm91bmRpbmcgd2l0aC4gYHhgLCBgeWAgb3IgYGFuZ2xlYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuc3RhcnQgLSBzdGFydCB2YWx1ZSBvZiB0aGUgYHByb3BlcnR5YFxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5lbmQgLSBlbmQgdmFsdWUgb2YgdGhlIGBwcm9wZXJ0eWBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYm91bmRTZWdtZW50cyhsaW5lLCBib3VuZHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3ViID0gX2JvdW5kU2VnbWVudChzZWdtZW50c1tpXSwgbGluZS5wb2ludHMsIGJvdW5kcyk7XG4gICAgaWYgKHN1Yi5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKC4uLnN1Yik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRmluZCBzdGFydCBhbmQgZW5kIGluZGV4IG9mIGEgbGluZS5cbiAqL1xuZnVuY3Rpb24gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBjb3VudCAtIDE7XG5cbiAgaWYgKGxvb3AgJiYgIXNwYW5HYXBzKSB7XG4gICAgLy8gbG9vcCBhbmQgbm90IHNwYW5uaW5nIGdhcHMsIGZpcnN0IGZpbmQgYSBnYXAgdG8gc3RhcnQgZnJvbVxuICAgIHdoaWxlIChzdGFydCA8IGNvdW50ICYmICFwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICB9XG5cbiAgLy8gZmluZCBmaXJzdCBub24gc2tpcHBlZCBwb2ludCAoYWZ0ZXIgdGhlIGZpcnN0IGdhcCBwb3NzaWJseSlcbiAgd2hpbGUgKHN0YXJ0IDwgY291bnQgJiYgcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuXG4gIC8vIGlmIHdlIGxvb3BlZCB0byBjb3VudCwgc3RhcnQgbmVlZHMgdG8gYmUgMFxuICBzdGFydCAlPSBjb3VudDtcblxuICBpZiAobG9vcCkge1xuICAgIC8vIGxvb3Agd2lsbCBnbyBwYXN0IGNvdW50LCBpZiBzdGFydCA+IDBcbiAgICBlbmQgKz0gc3RhcnQ7XG4gIH1cblxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgcG9pbnRzW2VuZCAlIGNvdW50XS5za2lwKSB7XG4gICAgZW5kLS07XG4gIH1cblxuICAvLyBlbmQgY291bGQgYmUgbW9yZSB0aGFuIGNvdW50LCBub3JtYWxpemVcbiAgZW5kICU9IGNvdW50O1xuXG4gIHJldHVybiB7c3RhcnQsIGVuZH07XG59XG5cbi8qKlxuICogQ29tcHV0ZSBzb2xpZCBzZWdtZW50cyBmcm9tIFBvaW50cywgd2hlbiBzcGFuR2FwcyA9PT0gZmFsc2VcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50cyAtIHRoZSBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gbWF4IGluZGV4IChjYW4gZ28gcGFzdCBjb3VudCBvbiBhIGxvb3ApXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3AgLSBib29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGlzIHdvdWxkIGJlIGEgbG9vcCBpZiBubyBnYXBzIGFyZSBmb3VuZFxuICovXG5mdW5jdGlvbiBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgbG9vcCkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgbGFzdCA9IHN0YXJ0O1xuICBsZXQgcHJldiA9IHBvaW50c1tzdGFydF07XG4gIGxldCBlbmQ7XG5cbiAgZm9yIChlbmQgPSBzdGFydCArIDE7IGVuZCA8PSBtYXg7ICsrZW5kKSB7XG4gICAgY29uc3QgY3VyID0gcG9pbnRzW2VuZCAlIGNvdW50XTtcbiAgICBpZiAoY3VyLnNraXAgfHwgY3VyLnN0b3ApIHtcbiAgICAgIGlmICghcHJldi5za2lwKSB7XG4gICAgICAgIGxvb3AgPSBmYWxzZTtcbiAgICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IChlbmQgLSAxKSAlIGNvdW50LCBsb29wfSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgc3RhcnQgPSBsYXN0ID0gY3VyLnN0b3AgPyBlbmQgOiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gZW5kO1xuICAgICAgaWYgKHByZXYuc2tpcCkge1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJldiA9IGN1cjtcbiAgfVxuXG4gIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IGxhc3QgJSBjb3VudCwgbG9vcH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBjb250aW51b3VzIHNlZ21lbnRzIHRoYXQgZGVmaW5lIHRoZSB3aG9sZSBsaW5lXG4gKiBUaGVyZSBjYW4gYmUgc2tpcHBlZCBwb2ludHMgd2l0aGluIGEgc2VnbWVudCwgaWYgc3BhbkdhcHMgaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2VnbWVudE9wdGlvbnNdXG4gKiBAcmV0dXJuIHtTZWdtZW50W119XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NvbXB1dGVTZWdtZW50cyhsaW5lLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3Qgc3BhbkdhcHMgPSBsaW5lLm9wdGlvbnMuc3BhbkdhcHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcblxuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgbG9vcCA9ICEhbGluZS5fbG9vcDtcbiAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKTtcblxuICBpZiAoc3BhbkdhcHMgPT09IHRydWUpIHtcbiAgICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBbe3N0YXJ0LCBlbmQsIGxvb3B9XSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG4gIH1cblxuICBjb25zdCBtYXggPSBlbmQgPCBzdGFydCA/IGVuZCArIGNvdW50IDogZW5kO1xuICBjb25zdCBjb21wbGV0ZUxvb3AgPSAhIWxpbmUuX2Z1bGxMb29wICYmIHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gY291bnQgLSAxO1xuICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgY29tcGxldGVMb29wKSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTZWdtZW50W119IHNlZ21lbnRzXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2VnbWVudE9wdGlvbnNdXG4gKiBAcmV0dXJuIHtTZWdtZW50W119XG4gKi9cbmZ1bmN0aW9uIHNwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcbiAgaWYgKCFzZWdtZW50T3B0aW9ucyB8fCAhc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dCB8fCAhcG9pbnRzKSB7XG4gICAgcmV0dXJuIHNlZ21lbnRzO1xuICB9XG4gIHJldHVybiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7U2VnbWVudFtdfSBzZWdtZW50c1xuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnRPcHRpb25zXVxuICogQHJldHVybiB7U2VnbWVudFtdfVxuICovXG5mdW5jdGlvbiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnRDb250ZXh0ID0gbGluZS5fY2hhcnQuZ2V0Q29udGV4dCgpO1xuICBjb25zdCBiYXNlU3R5bGUgPSByZWFkU3R5bGUobGluZS5vcHRpb25zKTtcbiAgY29uc3Qge19kYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCwgb3B0aW9uczoge3NwYW5HYXBzfX0gPSBsaW5lO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgcHJldlN0eWxlID0gYmFzZVN0eWxlO1xuICBsZXQgc3RhcnQgPSBzZWdtZW50c1swXS5zdGFydDtcbiAgbGV0IGkgPSBzdGFydDtcblxuICBmdW5jdGlvbiBhZGRTdHlsZShzLCBlLCBsLCBzdCkge1xuICAgIGNvbnN0IGRpciA9IHNwYW5HYXBzID8gLTEgOiAxO1xuICAgIGlmIChzID09PSBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFN0eWxlIGNhbiBub3Qgc3RhcnQvZW5kIG9uIGEgc2tpcHBlZCBwb2ludCwgYWRqdXN0IGluZGljZXMgYWNjb3JkaW5nbHlcbiAgICBzICs9IGNvdW50O1xuICAgIHdoaWxlIChwb2ludHNbcyAlIGNvdW50XS5za2lwKSB7XG4gICAgICBzIC09IGRpcjtcbiAgICB9XG4gICAgd2hpbGUgKHBvaW50c1tlICUgY291bnRdLnNraXApIHtcbiAgICAgIGUgKz0gZGlyO1xuICAgIH1cbiAgICBpZiAocyAlIGNvdW50ICE9PSBlICUgY291bnQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogcyAlIGNvdW50LCBlbmQ6IGUgJSBjb3VudCwgbG9vcDogbCwgc3R5bGU6IHN0fSk7XG4gICAgICBwcmV2U3R5bGUgPSBzdDtcbiAgICAgIHN0YXJ0ID0gZSAlIGNvdW50O1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHN0YXJ0ID0gc3BhbkdhcHMgPyBzdGFydCA6IHNlZ21lbnQuc3RhcnQ7XG4gICAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnQgJSBjb3VudF07XG4gICAgbGV0IHN0eWxlO1xuICAgIGZvciAoaSA9IHN0YXJ0ICsgMTsgaSA8PSBzZWdtZW50LmVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBwdCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgICAgc3R5bGUgPSByZWFkU3R5bGUoc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dChjcmVhdGVDb250ZXh0KGNoYXJ0Q29udGV4dCwge1xuICAgICAgICB0eXBlOiAnc2VnbWVudCcsXG4gICAgICAgIHAwOiBwcmV2LFxuICAgICAgICBwMTogcHQsXG4gICAgICAgIHAwRGF0YUluZGV4OiAoaSAtIDEpICUgY291bnQsXG4gICAgICAgIHAxRGF0YUluZGV4OiBpICUgY291bnQsXG4gICAgICAgIGRhdGFzZXRJbmRleFxuICAgICAgfSkpKTtcbiAgICAgIGlmIChzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkpIHtcbiAgICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgICB9XG4gICAgICBwcmV2ID0gcHQ7XG4gICAgICBwcmV2U3R5bGUgPSBzdHlsZTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0IDwgaSAtIDEpIHtcbiAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRTdHlsZShvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICBib3JkZXJDYXBTdHlsZTogb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSxcbiAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXG4gICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgIGJvcmRlckpvaW5TdHlsZTogb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUsXG4gICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3JcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpIHtcbiAgaWYgKCFwcmV2U3R5bGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY2FjaGUgPSBbXTtcbiAgY29uc3QgcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoIWNhY2hlLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgY2FjaGUucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZS5pbmRleE9mKHZhbHVlKTtcbiAgfTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0eWxlLCByZXBsYWNlcikgIT09IEpTT04uc3RyaW5naWZ5KHByZXZTdHlsZSwgcmVwbGFjZXIpO1xufVxuIiwgImltcG9ydCB7cmVxdWVzdEFuaW1GcmFtZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5hbmltYXRpb24uanMnKS5kZWZhdWx0IH0gQW5pbWF0aW9uXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG4vKipcbiAqIFBsZWFzZSB1c2UgdGhlIG1vZHVsZSdzIGRlZmF1bHQgZXhwb3J0IHdoaWNoIHByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBOb3RlOiBjbGFzcyBpcyBleHBvcnQgZm9yIHR5cGVkb2NcbiAqL1xuZXhwb3J0IGNsYXNzIEFuaW1hdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5fY2hhcnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXN0RGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsIHR5cGUpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBhbmltcy5saXN0ZW5lcnNbdHlwZV07XG4gICAgY29uc3QgbnVtU3RlcHMgPSBhbmltcy5kdXJhdGlvbjtcblxuICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZuID0+IGZuKHtcbiAgICAgIGNoYXJ0LFxuICAgICAgaW5pdGlhbDogYW5pbXMuaW5pdGlhbCxcbiAgICAgIG51bVN0ZXBzLFxuICAgICAgY3VycmVudFN0ZXA6IE1hdGgubWluKGRhdGUgLSBhbmltcy5zdGFydCwgbnVtU3RlcHMpXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVmcmVzaCgpIHtcbiAgICBpZiAodGhpcy5fcmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5fcnVubmluZykge1xuICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGUoZGF0ZSA9IERhdGUubm93KCkpIHtcbiAgICBsZXQgcmVtYWluaW5nID0gMDtcblxuICAgIHRoaXMuX2NoYXJ0cy5mb3JFYWNoKChhbmltcywgY2hhcnQpID0+IHtcbiAgICAgIGlmICghYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgZHJhdyA9IGZhbHNlO1xuICAgICAgbGV0IGl0ZW07XG5cbiAgICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgaWYgKGl0ZW0uX2FjdGl2ZSkge1xuICAgICAgICAgIGlmIChpdGVtLl90b3RhbCA+IGFuaW1zLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgYW5pbWF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQgYW5kIGl0cyBkdXJhdGlvbiBwcm9sb25nZWQsXG4gICAgICAgICAgICAvLyB1cGRhdGUgdG8gdG90YWwgZHVyYXRpb24gb2YgY3VycmVudCBhbmltYXRpb25zIHJ1biAoZm9yIHByb2dyZXNzIGV2ZW50KVxuICAgICAgICAgICAgYW5pbXMuZHVyYXRpb24gPSBpdGVtLl90b3RhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbS50aWNrKGRhdGUpO1xuICAgICAgICAgIGRyYXcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgaXRlbSBieSByZXBsYWNpbmcgaXQgd2l0aCBsYXN0IGl0ZW0gYW5kIHJlbW92aW5nIHRoZSBsYXN0XG4gICAgICAgICAgLy8gQSBsb3QgZmFzdGVyIHRoYW4gc3BsaWNlLlxuICAgICAgICAgIGl0ZW1zW2ldID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaXRlbXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRyYXcpIHtcbiAgICAgICAgY2hhcnQuZHJhdygpO1xuICAgICAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAncHJvZ3Jlc3MnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgYW5pbXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAnY29tcGxldGUnKTtcbiAgICAgICAgYW5pbXMuaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZW1haW5pbmcgKz0gaXRlbXMubGVuZ3RoO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fbGFzdERhdGUgPSBkYXRlO1xuXG4gICAgaWYgKHJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldEFuaW1zKGNoYXJ0KSB7XG4gICAgY29uc3QgY2hhcnRzID0gdGhpcy5fY2hhcnRzO1xuICAgIGxldCBhbmltcyA9IGNoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIGFuaW1zID0ge1xuICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICBjb21wbGV0ZTogW10sXG4gICAgICAgICAgcHJvZ3Jlc3M6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFydHMuc2V0KGNoYXJ0LCBhbmltcyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBldmVudCBuYW1lXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGJhY2tcblx0ICovXG4gIGxpc3RlbihjaGFydCwgZXZlbnQsIGNiKSB7XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLmxpc3RlbmVyc1tldmVudF0ucHVzaChjYik7XG4gIH1cblxuICAvKipcblx0ICogQWRkIGFuaW1hdGlvbnNcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtBbmltYXRpb25bXX0gaXRlbXMgLSBhbmltYXRpb25zXG5cdCAqL1xuICBhZGQoY2hhcnQsIGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5wdXNoKC4uLml0ZW1zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDb3VudHMgbnVtYmVyIG9mIGFjdGl2ZSBhbmltYXRpb25zIGZvciB0aGUgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIGhhcyhjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTdGFydCBhbmltYXRpbmcgKGFsbCBjaGFydHMpXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICBzdGFydChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhbmltcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICBhbmltcy5zdGFydCA9IERhdGUubm93KCk7XG4gICAgYW5pbXMuZHVyYXRpb24gPSBhbmltcy5pdGVtcy5yZWR1Y2UoKGFjYywgY3VyKSA9PiBNYXRoLm1heChhY2MsIGN1ci5fZHVyYXRpb24pLCAwKTtcbiAgICB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cblxuICBydW5uaW5nKGNoYXJ0KSB7XG4gICAgaWYgKCF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcyB8fCAhYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG5cdCAqIFN0b3AgYWxsIGFuaW1hdGlvbnMgZm9yIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuXG4gICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpdGVtc1tpXS5jYW5jZWwoKTtcbiAgICB9XG4gICAgYW5pbXMuaXRlbXMgPSBbXTtcbiAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBEYXRlLm5vdygpLCAnY29tcGxldGUnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZW1vdmUgY2hhcnQgZnJvbSBBbmltYXRvclxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgcmVtb3ZlKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICB9XG59XG5cbi8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGRlZmF1bHQgLyogI19fUFVSRV9fICovIG5ldyBBbmltYXRvcigpO1xuIiwgImltcG9ydCBlZmZlY3RzIGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5lYXNpbmcuanMnO1xuaW1wb3J0IHtyZXNvbHZlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2NvbG9yIGFzIGhlbHBlcnNDb2xvcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbG9yLmpzJztcblxuY29uc3QgdHJhbnNwYXJlbnQgPSAndHJhbnNwYXJlbnQnO1xuY29uc3QgaW50ZXJwb2xhdG9ycyA9IHtcbiAgYm9vbGVhbihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZhY3RvciA+IDAuNSA/IHRvIDogZnJvbTtcbiAgfSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b1xuICAgKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yXG4gICAqL1xuICBjb2xvcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgY29uc3QgYzAgPSBoZWxwZXJzQ29sb3IoZnJvbSB8fCB0cmFuc3BhcmVudCk7XG4gICAgY29uc3QgYzEgPSBjMC52YWxpZCAmJiBoZWxwZXJzQ29sb3IodG8gfHwgdHJhbnNwYXJlbnQpO1xuICAgIHJldHVybiBjMSAmJiBjMS52YWxpZFxuICAgICAgPyBjMS5taXgoYzAsIGZhY3RvcikuaGV4U3RyaW5nKClcbiAgICAgIDogdG87XG4gIH0sXG4gIG51bWJlcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIGZhY3RvcjtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uIHtcbiAgY29uc3RydWN0b3IoY2ZnLCB0YXJnZXQsIHByb3AsIHRvKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuXG4gICAgdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgY29uc3QgZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG5cbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuX2ZuID0gY2ZnLmZuIHx8IGludGVycG9sYXRvcnNbY2ZnLnR5cGUgfHwgdHlwZW9mIGZyb21dO1xuICAgIHRoaXMuX2Vhc2luZyA9IGVmZmVjdHNbY2ZnLmVhc2luZ10gfHwgZWZmZWN0cy5saW5lYXI7XG4gICAgdGhpcy5fc3RhcnQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgKyAoY2ZnLmRlbGF5IHx8IDApKTtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsID0gTWF0aC5mbG9vcihjZmcuZHVyYXRpb24pO1xuICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9wcm9wID0gcHJvcDtcbiAgICB0aGlzLl9mcm9tID0gZnJvbTtcbiAgICB0aGlzLl90byA9IHRvO1xuICAgIHRoaXMuX3Byb21pc2VzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cblxuICB1cGRhdGUoY2ZnLCB0bywgZGF0ZSkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuX3RhcmdldFt0aGlzLl9wcm9wXTtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gdGhpcy5fc3RhcnQ7XG4gICAgICBjb25zdCByZW1haW4gPSB0aGlzLl9kdXJhdGlvbiAtIGVsYXBzZWQ7XG4gICAgICB0aGlzLl9zdGFydCA9IGRhdGU7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5tYXgocmVtYWluLCBjZmcuZHVyYXRpb24pKTtcbiAgICAgIHRoaXMuX3RvdGFsICs9IGVsYXBzZWQ7XG4gICAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICAgIHRoaXMuX3RvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgICAgdGhpcy5fZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG4gICAgfVxuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIC8vIHVwZGF0ZSBjdXJyZW50IGV2YWx1YXRlZCB2YWx1ZSwgZm9yIHNtb290aGVyIGFuaW1hdGlvbnNcbiAgICAgIHRoaXMudGljayhEYXRlLm5vdygpKTtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICB0aWNrKGRhdGUpIHtcbiAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuX3Byb3A7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuX2Zyb207XG4gICAgY29uc3QgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgY29uc3QgdG8gPSB0aGlzLl90bztcbiAgICBsZXQgZmFjdG9yO1xuXG4gICAgdGhpcy5fYWN0aXZlID0gZnJvbSAhPT0gdG8gJiYgKGxvb3AgfHwgKGVsYXBzZWQgPCBkdXJhdGlvbikpO1xuXG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRvO1xuICAgICAgdGhpcy5fbm90aWZ5KHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGFwc2VkIDwgMCkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gZnJvbTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmYWN0b3IgPSAoZWxhcHNlZCAvIGR1cmF0aW9uKSAlIDI7XG4gICAgZmFjdG9yID0gbG9vcCAmJiBmYWN0b3IgPiAxID8gMiAtIGZhY3RvciA6IGZhY3RvcjtcbiAgICBmYWN0b3IgPSB0aGlzLl9lYXNpbmcoTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZmFjdG9yKSkpO1xuXG4gICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdGhpcy5fZm4oZnJvbSwgdG8sIGZhY3Rvcik7XG4gIH1cblxuICB3YWl0KCkge1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgKHRoaXMuX3Byb21pc2VzID0gW10pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHByb21pc2VzLnB1c2goe3JlcywgcmVqfSk7XG4gICAgfSk7XG4gIH1cblxuICBfbm90aWZ5KHJlc29sdmVkKSB7XG4gICAgY29uc3QgbWV0aG9kID0gcmVzb2x2ZWQgPyAncmVzJyA6ICdyZWonO1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvbWlzZXNbaV1bbWV0aG9kXSgpO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBhbmltYXRvciBmcm9tICcuL2NvcmUuYW5pbWF0b3IuanMnO1xuaW1wb3J0IEFuaW1hdGlvbiBmcm9tICcuL2NvcmUuYW5pbWF0aW9uLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb25zIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGNvbmZpZykge1xuICAgIHRoaXMuX2NoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fcHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNvbmZpZ3VyZShjb25maWcpO1xuICB9XG5cbiAgY29uZmlndXJlKGNvbmZpZykge1xuICAgIGlmICghaXNPYmplY3QoY29uZmlnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cy5hbmltYXRpb24pO1xuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY29uZmlnKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBjZmcgPSBjb25maWdba2V5XTtcbiAgICAgIGlmICghaXNPYmplY3QoY2ZnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgYW5pbWF0aW9uT3B0aW9ucykge1xuICAgICAgICByZXNvbHZlZFtvcHRpb25dID0gY2ZnW29wdGlvbl07XG4gICAgICB9XG5cbiAgICAgIChpc0FycmF5KGNmZy5wcm9wZXJ0aWVzKSAmJiBjZmcucHJvcGVydGllcyB8fCBba2V5XSkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBpZiAocHJvcCA9PT0ga2V5IHx8ICFhbmltYXRlZFByb3BzLmhhcyhwcm9wKSkge1xuICAgICAgICAgIGFuaW1hdGVkUHJvcHMuc2V0KHByb3AsIHJlc29sdmVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSB0byBoYW5kbGUgYW5pbWF0aW9uIG9mIGBvcHRpb25zYC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSB2YWx1ZXMub3B0aW9ucztcbiAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyhvcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICBpZiAobmV3T3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgICAvLyBHb2luZyB0byBzaGFyZWQgb3B0aW9uczpcbiAgICAgIC8vIEFmdGVyIGFsbCBhbmltYXRpb25zIGFyZSBkb25lLCBhc3NpZ24gdGhlIHNoYXJlZCBvcHRpb25zIG9iamVjdCB0byB0aGUgZWxlbWVudFxuICAgICAgLy8gU28gYW55IG5ldyB1cGRhdGVzIHRvIHRoZSBzaGFyZWQgb3B0aW9ucyBhcmUgb2JzZXJ2ZWRcbiAgICAgIGF3YWl0QWxsKHRhcmdldC5vcHRpb25zLiRhbmltYXRpb25zLCBuZXdPcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAvLyByZWplY3RlZCwgbm9vcFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHJ1bm5pbmcgPSB0YXJnZXQuJGFuaW1hdGlvbnMgfHwgKHRhcmdldC4kYW5pbWF0aW9ucyA9IHt9KTtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKHZhbHVlcyk7XG4gICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSBwcm9wcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHByb3AuY2hhckF0KDApID09PSAnJCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgYW5pbWF0aW9ucy5wdXNoKC4uLnRoaXMuX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbcHJvcF07XG4gICAgICBsZXQgYW5pbWF0aW9uID0gcnVubmluZ1twcm9wXTtcbiAgICAgIGNvbnN0IGNmZyA9IGFuaW1hdGVkUHJvcHMuZ2V0KHByb3ApO1xuXG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGlmIChjZmcgJiYgYW5pbWF0aW9uLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgYW4gZXhpc3RpbmcgYWN0aXZlIGFuaW1hdGlvbiwgbGV0J3MgdXBkYXRlIHRoYXRcbiAgICAgICAgICBhbmltYXRpb24udXBkYXRlKGNmZywgdmFsdWUsIGRhdGUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjZmcgfHwgIWNmZy5kdXJhdGlvbikge1xuICAgICAgICAvLyBub3QgYW5pbWF0ZWQsIHNldCBkaXJlY3RseSB0byBuZXcgdmFsdWVcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBydW5uaW5nW3Byb3BdID0gYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihjZmcsIHRhcmdldCwgcHJvcCwgdmFsdWUpO1xuICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG5cblxuICAvKipcblx0ICogVXBkYXRlIGB0YXJnZXRgIHByb3BlcnRpZXMgdG8gbmV3IHZhbHVlcywgdXNpbmcgY29uZmlndXJlZCBhbmltYXRpb25zXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBvYmplY3QgdG8gdXBkYXRlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgLSBuZXcgdGFyZ2V0IHByb3BlcnRpZXNcblx0ICogQHJldHVybnMge2Jvb2xlYW58dW5kZWZpbmVkfSAtIGB0cnVlYCBpZiBhbmltYXRpb25zIHdlcmUgc3RhcnRlZFxuXHQgKiovXG4gIHVwZGF0ZSh0YXJnZXQsIHZhbHVlcykge1xuICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzLnNpemUgPT09IDApIHtcbiAgICAgIC8vIE5vdGhpbmcgaXMgYW5pbWF0ZWQsIGp1c3QgYXBwbHkgdGhlIG5ldyB2YWx1ZXMuXG4gICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgdmFsdWVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcyk7XG5cbiAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGFuaW1hdG9yLmFkZCh0aGlzLl9jaGFydCwgYW5pbWF0aW9ucyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXdhaXRBbGwoYW5pbWF0aW9ucywgcHJvcGVydGllcykge1xuICBjb25zdCBydW5uaW5nID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYW5pbSA9IGFuaW1hdGlvbnNba2V5c1tpXV07XG4gICAgaWYgKGFuaW0gJiYgYW5pbS5hY3RpdmUoKSkge1xuICAgICAgcnVubmluZy5wdXNoKGFuaW0ud2FpdCgpKTtcbiAgICB9XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gUHJvbWlzZS5hbGwocnVubmluZyk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucykge1xuICBpZiAoIW5ld09wdGlvbnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG9wdGlvbnMgPSB0YXJnZXQub3B0aW9ucztcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgLy8gR29pbmcgZnJvbSBzaGFyZWQgb3B0aW9ucyB0byBkaXN0aW5jdCBvbmU6XG4gICAgLy8gQ3JlYXRlIG5ldyBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIHRoZSBvbGQgc2hhcmVkIHZhbHVlcyBhbmQgc3RhcnQgdXBkYXRpbmcgdGhhdC5cbiAgICB0YXJnZXQub3B0aW9ucyA9IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7JHNoYXJlZDogZmFsc2UsICRhbmltYXRpb25zOiB7fX0pO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuIiwgImltcG9ydCBBbmltYXRpb25zIGZyb20gJy4vY29yZS5hbmltYXRpb25zLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc0Zpbml0ZSwgaXNPYmplY3QsIHZhbHVlT3JEZWZhdWx0LCByZXNvbHZlT2JqZWN0S2V5LCBkZWZpbmVkfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2xpc3RlbkFycmF5RXZlbnRzLCB1bmxpc3RlbkFycmF5RXZlbnRzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIHNpZ259IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICovXG5cbmZ1bmN0aW9uIHNjYWxlQ2xpcChzY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zIHx8IHt9O1xuICBjb25zdCByZXZlcnNlID0gb3B0cy5yZXZlcnNlO1xuICBjb25zdCBtaW4gPSBvcHRzLm1pbiA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcbiAgY29uc3QgbWF4ID0gb3B0cy5tYXggPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHJldmVyc2UgPyBtYXggOiBtaW4sXG4gICAgZW5kOiByZXZlcnNlID8gbWluIDogbWF4XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDbGlwKHhTY2FsZSwgeVNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpIHtcbiAgaWYgKGFsbG93ZWRPdmVyZmxvdyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgeCA9IHNjYWxlQ2xpcCh4U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG4gIGNvbnN0IHkgPSBzY2FsZUNsaXAoeVNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuXG4gIHJldHVybiB7XG4gICAgdG9wOiB5LmVuZCxcbiAgICByaWdodDogeC5lbmQsXG4gICAgYm90dG9tOiB5LnN0YXJ0LFxuICAgIGxlZnQ6IHguc3RhcnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9DbGlwKHZhbHVlKSB7XG4gIGxldCB0LCByLCBiLCBsO1xuXG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB0ID0gdmFsdWUudG9wO1xuICAgIHIgPSB2YWx1ZS5yaWdodDtcbiAgICBiID0gdmFsdWUuYm90dG9tO1xuICAgIGwgPSB2YWx1ZS5sZWZ0O1xuICB9IGVsc2Uge1xuICAgIHQgPSByID0gYiA9IGwgPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiB0LFxuICAgIHJpZ2h0OiByLFxuICAgIGJvdHRvbTogYixcbiAgICBsZWZ0OiBsLFxuICAgIGRpc2FibGVkOiB2YWx1ZSA9PT0gZmFsc2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIGZpbHRlclZpc2libGUpIHtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSk7XG4gIGxldCBpLCBpbGVuO1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBrZXlzLnB1c2gobWV0YXNldHNbaV0uaW5kZXgpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgZHNJbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGtleXMgPSBzdGFjay5rZXlzO1xuICBjb25zdCBzaW5nbGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSAnc2luZ2xlJztcbiAgbGV0IGksIGlsZW4sIGRhdGFzZXRJbmRleCwgb3RoZXJWYWx1ZTtcblxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBkYXRhc2V0SW5kZXggPSAra2V5c1tpXTtcbiAgICBpZiAoZGF0YXNldEluZGV4ID09PSBkc0luZGV4KSB7XG4gICAgICBpZiAob3B0aW9ucy5hbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb3RoZXJWYWx1ZSA9IHN0YWNrLnZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChpc0Zpbml0ZShvdGhlclZhbHVlKSAmJiAoc2luZ2xlTW9kZSB8fCAodmFsdWUgPT09IDAgfHwgc2lnbih2YWx1ZSkgPT09IHNpZ24ob3RoZXJWYWx1ZSkpKSkge1xuICAgICAgdmFsdWUgKz0gb3RoZXJWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIGNvbnN0IGFkYXRhID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgbGV0IGksIGlsZW4sIGtleTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBhZGF0YVtpXSA9IHtcbiAgICAgIHg6IGtleSxcbiAgICAgIHk6IGRhdGFba2V5XVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFkYXRhO1xufVxuXG5mdW5jdGlvbiBpc1N0YWNrZWQoc2NhbGUsIG1ldGEpIHtcbiAgY29uc3Qgc3RhY2tlZCA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgcmV0dXJuIHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpO1xufVxuXG5mdW5jdGlvbiBnZXRTdGFja0tleShpbmRleFNjYWxlLCB2YWx1ZVNjYWxlLCBtZXRhKSB7XG4gIHJldHVybiBgJHtpbmRleFNjYWxlLmlkfS4ke3ZhbHVlU2NhbGUuaWR9LiR7bWV0YS5zdGFjayB8fCBtZXRhLnR5cGV9YDtcbn1cblxuZnVuY3Rpb24gZ2V0VXNlckJvdW5kcyhzY2FsZSkge1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gc2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICByZXR1cm4ge1xuICAgIG1pbjogbWluRGVmaW5lZCA/IG1pbiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICBtYXg6IG1heERlZmluZWQgPyBtYXggOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIHN0YWNrS2V5LCBpbmRleFZhbHVlKSB7XG4gIGNvbnN0IHN1YlN0YWNrID0gc3RhY2tzW3N0YWNrS2V5XSB8fCAoc3RhY2tzW3N0YWNrS2V5XSA9IHt9KTtcbiAgcmV0dXJuIHN1YlN0YWNrW2luZGV4VmFsdWVdIHx8IChzdWJTdGFja1tpbmRleFZhbHVlXSA9IHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBwb3NpdGl2ZSwgdHlwZSkge1xuICBmb3IgKGNvbnN0IG1ldGEgb2YgdlNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpLnJldmVyc2UoKSkge1xuICAgIGNvbnN0IHZhbHVlID0gc3RhY2tbbWV0YS5pbmRleF07XG4gICAgaWYgKChwb3NpdGl2ZSAmJiB2YWx1ZSA+IDApIHx8ICghcG9zaXRpdmUgJiYgdmFsdWUgPCAwKSkge1xuICAgICAgcmV0dXJuIG1ldGEuaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0YWNrcyhjb250cm9sbGVyLCBwYXJzZWQpIHtcbiAgY29uc3Qge2NoYXJ0LCBfY2FjaGVkTWV0YTogbWV0YX0gPSBjb250cm9sbGVyO1xuICBjb25zdCBzdGFja3MgPSBjaGFydC5fc3RhY2tzIHx8IChjaGFydC5fc3RhY2tzID0ge30pOyAvLyBtYXAgc3RydWN0dXJlIGlzIHtzdGFja0tleToge2RhdGFzZXRJbmRleDogdmFsdWV9fVxuICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIGluZGV4OiBkYXRhc2V0SW5kZXh9ID0gbWV0YTtcbiAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgY29uc3Qga2V5ID0gZ2V0U3RhY2tLZXkoaVNjYWxlLCB2U2NhbGUsIG1ldGEpO1xuICBjb25zdCBpbGVuID0gcGFyc2VkLmxlbmd0aDtcbiAgbGV0IHN0YWNrO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3QgaXRlbSA9IHBhcnNlZFtpXTtcbiAgICBjb25zdCB7W2lBeGlzXTogaW5kZXgsIFt2QXhpc106IHZhbHVlfSA9IGl0ZW07XG4gICAgY29uc3QgaXRlbVN0YWNrcyA9IGl0ZW0uX3N0YWNrcyB8fCAoaXRlbS5fc3RhY2tzID0ge30pO1xuICAgIHN0YWNrID0gaXRlbVN0YWNrc1t2QXhpc10gPSBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywga2V5LCBpbmRleCk7XG4gICAgc3RhY2tbZGF0YXNldEluZGV4XSA9IHZhbHVlO1xuXG4gICAgc3RhY2suX3RvcCA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgdHJ1ZSwgbWV0YS50eXBlKTtcbiAgICBzdGFjay5fYm90dG9tID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBmYWxzZSwgbWV0YS50eXBlKTtcblxuICAgIGNvbnN0IHZpc3VhbFZhbHVlcyA9IHN0YWNrLl92aXN1YWxWYWx1ZXMgfHwgKHN0YWNrLl92aXN1YWxWYWx1ZXMgPSB7fSk7XG4gICAgdmlzdWFsVmFsdWVzW2RhdGFzZXRJbmRleF0gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsIGF4aXMpIHtcbiAgY29uc3Qgc2NhbGVzID0gY2hhcnQuc2NhbGVzO1xuICByZXR1cm4gT2JqZWN0LmtleXMoc2NhbGVzKS5maWx0ZXIoa2V5ID0+IHNjYWxlc1trZXldLmF4aXMgPT09IGF4aXMpLnNoaWZ0KCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURhdGFzZXRDb250ZXh0KHBhcmVudCwgaW5kZXgpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LFxuICAgIHtcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICBkYXRhc2V0OiB1bmRlZmluZWQsXG4gICAgICBkYXRhc2V0SW5kZXg6IGluZGV4LFxuICAgICAgaW5kZXgsXG4gICAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgICB0eXBlOiAnZGF0YXNldCdcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURhdGFDb250ZXh0KHBhcmVudCwgaW5kZXgsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIHBhcnNlZDogdW5kZWZpbmVkLFxuICAgIHJhdzogdW5kZWZpbmVkLFxuICAgIGVsZW1lbnQsXG4gICAgaW5kZXgsXG4gICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgIHR5cGU6ICdkYXRhJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJTdGFja3MobWV0YSwgaXRlbXMpIHtcbiAgLy8gTm90IHVzaW5nIG1ldGEuaW5kZXggaGVyZSwgYmVjYXVzZSBpdCBtaWdodCBiZSBhbHJlYWR5IHVwZGF0ZWQgaWYgdGhlIGRhdGFzZXQgY2hhbmdlZCBsb2NhdGlvblxuICBjb25zdCBkYXRhc2V0SW5kZXggPSBtZXRhLmNvbnRyb2xsZXIuaW5kZXg7XG4gIGNvbnN0IGF4aXMgPSBtZXRhLnZTY2FsZSAmJiBtZXRhLnZTY2FsZS5heGlzO1xuICBpZiAoIWF4aXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpdGVtcyA9IGl0ZW1zIHx8IG1ldGEuX3BhcnNlZDtcbiAgZm9yIChjb25zdCBwYXJzZWQgb2YgaXRlbXMpIHtcbiAgICBjb25zdCBzdGFja3MgPSBwYXJzZWQuX3N0YWNrcztcbiAgICBpZiAoIXN0YWNrcyB8fCBzdGFja3NbYXhpc10gPT09IHVuZGVmaW5lZCB8fCBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XTtcbiAgICBpZiAoc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXMgIT09IHVuZGVmaW5lZCAmJiBzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSBzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBpc0RpcmVjdFVwZGF0ZU1vZGUgPSAobW9kZSkgPT4gbW9kZSA9PT0gJ3Jlc2V0JyB8fCBtb2RlID09PSAnbm9uZSc7XG5jb25zdCBjbG9uZUlmTm90U2hhcmVkID0gKGNhY2hlZCwgc2hhcmVkKSA9PiBzaGFyZWQgPyBjYWNoZWQgOiBPYmplY3QuYXNzaWduKHt9LCBjYWNoZWQpO1xuY29uc3QgY3JlYXRlU3RhY2sgPSAoY2FuU3RhY2ssIG1ldGEsIGNoYXJ0KSA9PiBjYW5TdGFjayAmJiAhbWV0YS5oaWRkZW4gJiYgbWV0YS5fc3RhY2tlZFxuICAmJiB7a2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLCB2YWx1ZXM6IG51bGx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7fTtcblxuICAvKipcbiAgICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGFzZXQgKGUuZy4gQ2hhcnQuZWxlbWVudC5MaW5lRWxlbWVudCkuXG4gICAqL1xuICBzdGF0aWMgZGF0YXNldEVsZW1lbnRUeXBlID0gbnVsbDtcblxuICAvKipcbiAgICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGEgKGUuZy4gQ2hhcnQuZWxlbWVudC5Qb2ludEVsZW1lbnQpLlxuICAgKi9cbiAgc3RhdGljIGRhdGFFbGVtZW50VHlwZSA9IG51bGw7XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhc2V0SW5kZXhcblx0ICovXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fY3R4ID0gY2hhcnQuY3R4O1xuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgICB0aGlzLl9jYWNoZWRNZXRhID0gdGhpcy5nZXRNZXRhKCk7XG4gICAgdGhpcy5fdHlwZSA9IHRoaXMuX2NhY2hlZE1ldGEudHlwZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtib29sZWFuIHwgb2JqZWN0fSAqL1xuICAgIHRoaXMuX3BhcnNpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29iamVjdERhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2hhcmVkT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IGZhbHNlO1xuICAgIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gbmV3LnRhcmdldC5kYXRhc2V0RWxlbWVudFR5cGU7XG4gICAgdGhpcy5kYXRhRWxlbWVudFR5cGUgPSBuZXcudGFyZ2V0LmRhdGFFbGVtZW50VHlwZTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMubGlua1NjYWxlcygpO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIHRoaXMuYWRkRWxlbWVudHMoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsbCAmJiAhdGhpcy5jaGFydC5pc1BsdWdpbkVuYWJsZWQoJ2ZpbGxlcicpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUcmllZCB0byB1c2UgdGhlICdmaWxsJyBvcHRpb24gd2l0aG91dCB0aGUgJ0ZpbGxlcicgcGx1Z2luIGVuYWJsZWQuIFBsZWFzZSBpbXBvcnQgYW5kIHJlZ2lzdGVyIHRoZSAnRmlsbGVyJyBwbHVnaW4gYW5kIG1ha2Ugc3VyZSBpdCBpcyBub3QgZGlzYWJsZWQgaW4gdGhlIG9wdGlvbnNcIik7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlSW5kZXgoZGF0YXNldEluZGV4KSB7XG4gICAgaWYgKHRoaXMuaW5kZXggIT09IGRhdGFzZXRJbmRleCkge1xuICAgICAgY2xlYXJTdGFja3ModGhpcy5fY2FjaGVkTWV0YSk7XG4gICAgfVxuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG4gIH1cblxuICBsaW5rU2NhbGVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG5cbiAgICBjb25zdCBjaG9vc2VJZCA9IChheGlzLCB4LCB5LCByKSA9PiBheGlzID09PSAneCcgPyB4IDogYXhpcyA9PT0gJ3InID8gciA6IHk7XG5cbiAgICBjb25zdCB4aWQgPSBtZXRhLnhBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnhBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3gnKSk7XG4gICAgY29uc3QgeWlkID0gbWV0YS55QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC55QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd5JykpO1xuICAgIGNvbnN0IHJpZCA9IG1ldGEuckF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuckF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAncicpKTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBtZXRhLmluZGV4QXhpcztcbiAgICBjb25zdCBpaWQgPSBtZXRhLmlBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHhpZCwgeWlkLCByaWQpO1xuICAgIGNvbnN0IHZpZCA9IG1ldGEudkF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeWlkLCB4aWQsIHJpZCk7XG4gICAgbWV0YS54U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeGlkKTtcbiAgICBtZXRhLnlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh5aWQpO1xuICAgIG1ldGEuclNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHJpZCk7XG4gICAgbWV0YS5pU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoaWlkKTtcbiAgICBtZXRhLnZTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh2aWQpO1xuICB9XG5cbiAgZ2V0RGF0YXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgZ2V0TWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NhbGVJRFxuXHQgKiBAcmV0dXJuIHtTY2FsZX1cblx0ICovXG4gIGdldFNjYWxlRm9ySWQoc2NhbGVJRCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlc1tzY2FsZUlEXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldE90aGVyU2NhbGUoc2NhbGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICByZXR1cm4gc2NhbGUgPT09IG1ldGEuaVNjYWxlXG4gICAgICA/IG1ldGEudlNjYWxlXG4gICAgICA6IG1ldGEuaVNjYWxlO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fdXBkYXRlKCdyZXNldCcpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZGVzdHJveSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RhdGFDaGVjaygpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuZGF0YSB8fCAoZGF0YXNldC5kYXRhID0gW10pO1xuICAgIGNvbnN0IF9kYXRhID0gdGhpcy5fZGF0YTtcblxuICAgIC8vIEluIG9yZGVyIHRvIGNvcnJlY3RseSBoYW5kbGUgZGF0YSBhZGRpdGlvbi9kZWxldGlvbiBhbmltYXRpb24gKGFuZCB0aHVzIHNpbXVsYXRlXG4gICAgLy8gcmVhbC10aW1lIGNoYXJ0cyksIHdlIG5lZWQgdG8gbW9uaXRvciB0aGVzZSBkYXRhIG1vZGlmaWNhdGlvbnMgYW5kIHN5bmNocm9uaXplXG4gICAgLy8gdGhlIGludGVybmFsIG1ldGFkYXRhIGFjY29yZGluZ2x5LlxuXG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoX2RhdGEgIT09IGRhdGEpIHtcbiAgICAgIGlmIChfZGF0YSkge1xuICAgICAgICAvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IGluc3RhbmNlLlxuICAgICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKF9kYXRhLCB0aGlzKTtcbiAgICAgICAgLy8gRGlzY2FyZCBvbGQgcGFyc2VkIGRhdGEgYW5kIHN0YWNrc1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICAgIG1ldGEuX3BhcnNlZCA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuICAgICAgICBsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cblxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcblxuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuXG4gICAgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICBtZXRhLmRhdGFzZXQgPSBuZXcgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUoKTtcbiAgICB9XG4gIH1cblxuICBidWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgc3RhY2tDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcblxuICAgIC8vIG1ha2Ugc3VyZSBjYWNoZWQgX3N0YWNrZWQgc3RhdHVzIGlzIGN1cnJlbnRcbiAgICBjb25zdCBvbGRTdGFja2VkID0gbWV0YS5fc3RhY2tlZDtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcblxuICAgIC8vIGRldGVjdCBjaGFuZ2UgaW4gc3RhY2sgb3B0aW9uXG4gICAgaWYgKG1ldGEuc3RhY2sgIT09IGRhdGFzZXQuc3RhY2spIHtcbiAgICAgIHN0YWNrQ2hhbmdlZCA9IHRydWU7XG4gICAgICAvLyByZW1vdmUgdmFsdWVzIGZyb20gb2xkIHN0YWNrXG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgIG1ldGEuc3RhY2sgPSBkYXRhc2V0LnN0YWNrO1xuICAgIH1cblxuICAgIC8vIFJlLXN5bmMgbWV0YSBkYXRhIGluIGNhc2UgdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgb3IgaWYgd2UgbWlzc2VkXG4gICAgLy8gYW55IHVwZGF0ZXMgYW5kIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBudW1iZXIgb2YgZGF0YXBvaW50cyBjaGFuZ2luZy5cbiAgICB0aGlzLl9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKTtcblxuICAgIC8vIGlmIHN0YWNrIGNoYW5nZWQsIHVwZGF0ZSBzdGFjayB2YWx1ZXMgZm9yIHRoZSB3aG9sZSBkYXRhc2V0XG4gICAgaWYgKHN0YWNrQ2hhbmdlZCB8fCBvbGRTdGFja2VkICE9PSBtZXRhLl9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgbWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogTWVyZ2VzIHVzZXItc3VwcGxpZWQgYW5kIGRlZmF1bHQgZGF0YXNldC1sZXZlbCBvcHRpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRTY29wZUtleXModGhpcy5fdHlwZSk7XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzLCB0cnVlKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5fcGFyc2luZyA9IHRoaXMub3B0aW9ucy5wYXJzaW5nO1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuXHQgKi9cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiBtZXRhLCBfZGF0YTogZGF0YX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpU2NhbGUsIF9zdGFja2VkfSA9IG1ldGE7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcblxuICAgIGxldCBzb3J0ZWQgPSBzdGFydCA9PT0gMCAmJiBjb3VudCA9PT0gZGF0YS5sZW5ndGggPyB0cnVlIDogbWV0YS5fc29ydGVkO1xuICAgIGxldCBwcmV2ID0gc3RhcnQgPiAwICYmIG1ldGEuX3BhcnNlZFtzdGFydCAtIDFdO1xuICAgIGxldCBpLCBjdXIsIHBhcnNlZDtcblxuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICAgIG1ldGEuX3NvcnRlZCA9IHRydWU7XG4gICAgICBwYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2ID0gKCkgPT4gY3VyW2lBeGlzXSA9PT0gbnVsbCB8fCAocHJldiAmJiBjdXJbaUF4aXNdIDwgcHJldltpQXhpc10pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2kgKyBzdGFydF0gPSBjdXIgPSBwYXJzZWRbaV07XG4gICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICBpZiAoaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYoKSkge1xuICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1ldGEuX3NvcnRlZCA9IHNvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBwYXJzZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBwcmltaXRpdmUgdmFsdWVzXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhIC0gZGF0YXNldCBtZXRhXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGRhdGEgLSBkYXRhIGFycmF5LiBFeGFtcGxlIFsxLDMsNF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gc3RhcnQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gbnVtYmVyIG9mIGl0ZW1zIHRvIHBhcnNlXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHBhcnNlZCBpdGVtIC0gaXRlbSBjb250YWluaW5nIGluZGV4IGFuZCBhIHBhcnNlZCB2YWx1ZVxuXHQgKiBmb3IgZWFjaCBzY2FsZSBpZC5cblx0ICogRXhhbXBsZToge3hTY2FsZTA6IDAsIHlTY2FsZTA6IDF9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICAgIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXg7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICBbaUF4aXNdOiBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2luZGV4XSwgaW5kZXgpLFxuICAgICAgICBbdkF4aXNdOiB2U2NhbGUucGFyc2UoZGF0YVtpbmRleF0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBhcnJheXNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgW1sxLDJdLFszLDRdXVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLlxuXHQgKiBFeGFtcGxlOiB7eDogMCwgeTogMX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UoaXRlbVswXSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UoaXRlbVsxXSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIG9iamVjdHNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgW3t4OjEsIHk6NX0sIHt4OjIsIHk6MTB9XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLiBfY3VzdG9tIGlzIG9wdGlvbmFsXG5cdCAqIEV4YW1wbGU6IHt4U2NhbGUwOiAwLCB5U2NhbGUwOiAxLCBfY3VzdG9tOiB7cjogMTAsIGZvbzogJ2Jhcid9fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeEF4aXNLZXkpLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHlBeGlzS2V5KSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldFBhcnNlZChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWRbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldERhdGFFbGVtZW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgYXBwbHlTdGFjayhzY2FsZSwgcGFyc2VkLCBtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGNvbnN0IHN0YWNrID0ge1xuICAgICAga2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLFxuICAgICAgdmFsdWVzOiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXS5fdmlzdWFsVmFsdWVzXG4gICAgfTtcbiAgICByZXR1cm4gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIG1ldGEuaW5kZXgsIHttb2RlfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFZhbHVlID09PSBudWxsID8gTmFOIDogcGFyc2VkVmFsdWU7XG4gICAgY29uc3QgdmFsdWVzID0gc3RhY2sgJiYgcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc107XG4gICAgaWYgKHN0YWNrICYmIHZhbHVlcykge1xuICAgICAgc3RhY2sudmFsdWVzID0gdmFsdWVzO1xuICAgICAgdmFsdWUgPSBhcHBseVN0YWNrKHN0YWNrLCBwYXJzZWRWYWx1ZSwgdGhpcy5fY2FjaGVkTWV0YS5pbmRleCk7XG4gICAgfVxuICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgdmFsdWUpO1xuICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1pbk1heChzY2FsZSwgY2FuU3RhY2spIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBfcGFyc2VkID0gbWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHNvcnRlZCA9IG1ldGEuX3NvcnRlZCAmJiBzY2FsZSA9PT0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgaWxlbiA9IF9wYXJzZWQubGVuZ3RoO1xuICAgIGNvbnN0IG90aGVyU2NhbGUgPSB0aGlzLl9nZXRPdGhlclNjYWxlKHNjYWxlKTtcbiAgICBjb25zdCBzdGFjayA9IGNyZWF0ZVN0YWNrKGNhblN0YWNrLCBtZXRhLCB0aGlzLmNoYXJ0KTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuICAgIGNvbnN0IHttaW46IG90aGVyTWluLCBtYXg6IG90aGVyTWF4fSA9IGdldFVzZXJCb3VuZHMob3RoZXJTY2FsZSk7XG4gICAgbGV0IGksIHBhcnNlZDtcblxuICAgIGZ1bmN0aW9uIF9za2lwKCkge1xuICAgICAgcGFyc2VkID0gX3BhcnNlZFtpXTtcbiAgICAgIGNvbnN0IG90aGVyVmFsdWUgPSBwYXJzZWRbb3RoZXJTY2FsZS5heGlzXTtcbiAgICAgIHJldHVybiAhaXNGaW5pdGUocGFyc2VkW3NjYWxlLmF4aXNdKSB8fCBvdGhlck1pbiA+IG90aGVyVmFsdWUgfHwgb3RoZXJNYXggPCBvdGhlclZhbHVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGRhdGEgaXMgc29ydGVkLCB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZ1cnRoZXIgZnJvbSB0aGlzIGVuZCBvZiBhcnJheVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNvcnRlZCkge1xuICAgICAgLy8gaW4gdGhlIHNvcnRlZCBjYXNlLCBmaW5kIGZpcnN0IG5vbi1za2lwcGVkIHZhbHVlIGZyb20gb3RoZXIgZW5kIG9mIGFycmF5XG4gICAgICBmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB2YWx1ZTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwYXJzZWQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlZFtpXVtzY2FsZS5heGlzXTtcbiAgICAgIGlmIChpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcnxib29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGlTY2FsZSA/ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSkgOiAnJyxcbiAgICAgIHZhbHVlOiB2U2NhbGUgPyAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pIDogJydcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZShtb2RlIHx8ICdkZWZhdWx0Jyk7XG4gICAgbWV0YS5fY2xpcCA9IHRvQ2xpcCh2YWx1ZU9yRGVmYXVsdCh0aGlzLm9wdGlvbnMuY2xpcCwgZGVmYXVsdENsaXAobWV0YS54U2NhbGUsIG1ldGEueVNjYWxlLCB0aGlzLmdldE1heE92ZXJmbG93KCkpKSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGVcblx0ICovXG4gIHVwZGF0ZShtb2RlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9jdHg7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3QgYWN0aXZlID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9kcmF3U3RhcnQgfHwgMDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2RyYXdDb3VudCB8fCAoZWxlbWVudHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGNvbnN0IGRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdGhpcy5vcHRpb25zLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wO1xuICAgIGxldCBpO1xuXG4gICAgaWYgKG1ldGEuZGF0YXNldCkge1xuICAgICAgbWV0YS5kYXRhc2V0LmRyYXcoY3R4LCBhcmVhLCBzdGFydCwgY291bnQpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5oaWRkZW4pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5hY3RpdmUgJiYgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3ApIHtcbiAgICAgICAgYWN0aXZlLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmRyYXcoY3R4LCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgKytpKSB7XG4gICAgICBhY3RpdmVbaV0uZHJhdyhjdHgsIGFyZWEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEgc2V0IG9mIHByZWRlZmluZWQgc3R5bGUgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgZGF0YXNldFxuXHQgKiBvciB0aGUgZGF0YSBpZiB0aGUgaW5kZXggaXMgc3BlY2lmaWVkXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGRhdGEgaW5kZXhcblx0ICogQHBhcmFtIHtib29sZWFufSBbYWN0aXZlXSAtIHRydWUgaWYgaG92ZXJcblx0ICogQHJldHVybiB7b2JqZWN0fSBzdHlsZSBvYmplY3Rcblx0ICovXG4gIGdldFN0eWxlKGluZGV4LCBhY3RpdmUpIHtcbiAgICBjb25zdCBtb2RlID0gYWN0aXZlID8gJ2FjdGl2ZScgOiAnZGVmYXVsdCc7XG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgJiYgdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0XG4gICAgICA/IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKVxuICAgICAgOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXggfHwgMCwgbW9kZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0ID0gZWxlbWVudC4kY29udGV4dCB8fFxuICAgICAgICAoZWxlbWVudC4kY29udGV4dCA9IGNyZWF0ZURhdGFDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgZWxlbWVudCkpO1xuICAgICAgY29udGV4dC5wYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgICBjb250ZXh0LnJhdyA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhSW5kZXggPSBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IHRoaXMuJGNvbnRleHQgfHxcbiAgICAgICAgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVEYXRhc2V0Q29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcy5pbmRleCkpO1xuICAgICAgY29udGV4dC5kYXRhc2V0ID0gZGF0YXNldDtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgfVxuXG4gICAgY29udGV4dC5hY3RpdmUgPSAhIWFjdGl2ZTtcbiAgICBjb250ZXh0Lm1vZGUgPSBtb2RlO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZS5pZCwgbW9kZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhRWxlbWVudFR5cGUuaWQsIG1vZGUsIGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhlbGVtZW50VHlwZSwgbW9kZSA9ICdkZWZhdWx0JywgaW5kZXgpIHtcbiAgICBjb25zdCBhY3RpdmUgPSBtb2RlID09PSAnYWN0aXZlJztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZWxlbWVudFR5cGUgKyAnLScgKyBtb2RlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBjb25zdCBzaGFyaW5nID0gdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nICYmIGRlZmluZWQoaW5kZXgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjbG9uZUlmTm90U2hhcmVkKGNhY2hlZCwgc2hhcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0RWxlbWVudFNjb3BlS2V5cyh0aGlzLl90eXBlLCBlbGVtZW50VHlwZSk7XG4gICAgY29uc3QgcHJlZml4ZXMgPSBhY3RpdmUgPyBbYCR7ZWxlbWVudFR5cGV9SG92ZXJgLCAnaG92ZXInLCBlbGVtZW50VHlwZSwgJyddIDogW2VsZW1lbnRUeXBlLCAnJ107XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmVsZW1lbnRzW2VsZW1lbnRUeXBlXSk7XG4gICAgLy8gY29udGV4dCBpcyBwcm92aWRlZCBhcyBhIGZ1bmN0aW9uLCBhbmQgaXMgY2FsbGVkIG9ubHkgaWYgbmVlZGVkLFxuICAgIC8vIHNvIHdlIGRvbid0IGNyZWF0ZSBhIGNvbnRleHQgZm9yIGVhY2ggZWxlbWVudCBpZiBub3QgbmVlZGVkLlxuICAgIGNvbnN0IGNvbnRleHQgPSAoKSA9PiB0aGlzLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgbW9kZSk7XG4gICAgY29uc3QgdmFsdWVzID0gY29uZmlnLnJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMpO1xuXG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICAvLyBgJHNoYXJlZGAgaW5kaWNhdGVzIHRoaXMgc2V0IG9mIG9wdGlvbnMgY2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIGVsZW1lbnRzLlxuICAgICAgLy8gU2hhcmluZyBpcyB1c2VkIHRvIHJlZHVjZSBudW1iZXIgb2YgcHJvcGVydGllcyB0byBjaGFuZ2UgZHVyaW5nIGFuaW1hdGlvbi5cbiAgICAgIHZhbHVlcy4kc2hhcmVkID0gc2hhcmluZztcblxuICAgICAgLy8gV2UgY2FjaGUgb3B0aW9ucyBieSBgbW9kZWAsIHdoaWNoIGNhbiBiZSAnYWN0aXZlJyBmb3IgZXhhbXBsZS4gVGhpcyBlbmFibGVzIHVzXG4gICAgICAvLyB0byBoYXZlIHRoZSAnYWN0aXZlJyBlbGVtZW50IG9wdGlvbnMgYW5kICdkZWZhdWx0JyBvcHRpb25zIHRvIHN3aXRjaCBiZXR3ZWVuXG4gICAgICAvLyB3aGVuIGludGVyYWN0aW5nLlxuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShjbG9uZUlmTm90U2hhcmVkKHZhbHVlcywgc2hhcmluZykpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCB0cmFuc2l0aW9uLCBhY3RpdmUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGBhbmltYXRpb24tJHt0cmFuc2l0aW9ufWA7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGxldCBvcHRpb25zO1xuICAgIGlmIChjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRBbmltYXRpb25TY29wZUtleXModGhpcy5fdHlwZSwgdHJhbnNpdGlvbik7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgICAgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCB0cmFuc2l0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyhjaGFydCwgb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2NhY2hlYWJsZSkge1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgb3B0aW9ucyBvYmplY3Qgc2hhcmVkIGJldHdlZW4gZWxlbWVudHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZE9wdGlvbnMgfHwgKHRoaXMuX3NoYXJlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZGV0ZXJtaW5pbmcgaWYgYG9wdGlvbnNgIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdXBkYXRlZCBwcm9wZXJ0aWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gIXNoYXJlZE9wdGlvbnMgfHwgaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpIHx8IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdG9kbyB2NCwgcmVuYW1lIHRvIGdldFNoYXJlZE9wdGlvbnMgYW5kIHJlbW92ZSBleGNlc3MgZnVuY3Rpb25zXG4gICAqL1xuICBfZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSkge1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgcHJldmlvdXNseVNoYXJlZE9wdGlvbnMgPSB0aGlzLl9zaGFyZWRPcHRpb25zO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykgfHwgKHNoYXJlZE9wdGlvbnMgIT09IHByZXZpb3VzbHlTaGFyZWRPcHRpb25zKTtcbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgICByZXR1cm4ge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciB1cGRhdGluZyBhbiBlbGVtZW50IHdpdGggbmV3IHByb3BlcnRpZXMsIHVzaW5nIGFuaW1hdGlvbnMgd2hlbiBhcHByb3ByaWF0ZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgcHJvcGVydGllcywgbW9kZSkge1xuICAgIGlmIChpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlKS51cGRhdGUoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgdG8gYW5pbWF0ZSB0aGUgc2hhcmVkIG9wdGlvbnMsIHRoYXQgYXJlIHBvdGVudGlhbGx5IGFmZmVjdGluZyBtdWx0aXBsZSBlbGVtZW50cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBuZXdPcHRpb25zKSB7XG4gICAgaWYgKHNoYXJlZE9wdGlvbnMgJiYgIWlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKS51cGRhdGUoc2hhcmVkT3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsIG1vZGUsIGFjdGl2ZSkge1xuICAgIGVsZW1lbnQuYWN0aXZlID0gYWN0aXZlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldFN0eWxlKGluZGV4LCBhY3RpdmUpO1xuICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlLCBhY3RpdmUpLnVwZGF0ZShlbGVtZW50LCB7XG4gICAgICAvLyBXaGVuIGdvaW5nIGZyb20gYWN0aXZlIHRvIGluYWN0aXZlLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0byB0aGUgc2hhcmVkIG9wdGlvbnMuXG4gICAgICAvLyBUaGlzIHdheSB0aGUgb25jZSBob3ZlcmVkIGVsZW1lbnQgd2lsbCBlbmQgdXAgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzaGFyZWQgb3B0aW9ucyBpbnN0YW5jZSwgYWZ0ZXIgYW5pbWF0aW9uLlxuICAgICAgb3B0aW9uczogKCFhY3RpdmUgJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpKSB8fCBvcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICByZW1vdmVIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgfVxuXG4gIHNldEhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgdHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9zZXREYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIC8vIEFwcGx5IGNoYW5nZXMgZGV0ZWN0ZWQgdGhyb3VnaCBhcnJheSBsaXN0ZW5lcnNcbiAgICBmb3IgKGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdIG9mIHRoaXMuX3N5bmNMaXN0KSB7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG5cbiAgICBjb25zdCBudW1NZXRhID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bURhdGEgPSBkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKG51bURhdGEsIG51bU1ldGEpO1xuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICAvLyBUT0RPOiBJdCBpcyBub3Qgb3B0aW1hbCB0byBhbHdheXMgcGFyc2UgdGhlIG9sZCBkYXRhXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgYmVjYXVzZSB3ZSBhcmUgbm90IGRldGVjdGluZyBkaXJlY3QgYXNzaWdubWVudHM6XG4gICAgICAvLyBjaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGFbNV0gPSAxMDtcbiAgICAgIC8vIGNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVs1XS55ID0gMTA7XG4gICAgICB0aGlzLnBhcnNlKDAsIGNvdW50KTtcbiAgICB9XG5cbiAgICBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX2luc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhLCByZXNldE5ld0VsZW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50cyhudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGNvdW50LCByZXNldE5ld0VsZW1lbnRzID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICBsZXQgaTtcblxuICAgIGNvbnN0IG1vdmUgPSAoYXJyKSA9PiB7XG4gICAgICBhcnIubGVuZ3RoICs9IGNvdW50O1xuICAgICAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gZW5kOyBpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW2kgLSBjb3VudF07XG4gICAgICB9XG4gICAgfTtcbiAgICBtb3ZlKGRhdGEpO1xuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgZGF0YVtpXSA9IG5ldyB0aGlzLmRhdGFFbGVtZW50VHlwZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBtb3ZlKG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICAgIHRoaXMucGFyc2Uoc3RhcnQsIGNvdW50KTtcblxuICAgIGlmIChyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGRhdGEsIHN0YXJ0LCBjb3VudCwgJ3Jlc2V0Jyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoZWxlbWVudCwgc3RhcnQsIGNvdW50LCBtb2RlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVtb3ZlRWxlbWVudHMoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBtZXRhLl9wYXJzZWQuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gICAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhLCByZW1vdmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWV0YS5kYXRhLnNwbGljZShzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG4gICAqL1xuICBfc3luYyhhcmdzKSB7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIHRoaXMuX3N5bmNMaXN0LnB1c2goYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdID0gYXJncztcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5jaGFydC5fZGF0YUNoYW5nZXMucHVzaChbdGhpcy5pbmRleCwgLi4uYXJnc10pO1xuICB9XG5cbiAgX29uRGF0YVB1c2goKSB7XG4gICAgY29uc3QgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCB0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudF0pO1xuICB9XG5cbiAgX29uRGF0YVBvcCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCAtIDEsIDFdKTtcbiAgfVxuXG4gIF9vbkRhdGFTaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgMCwgMV0pO1xuICB9XG5cbiAgX29uRGF0YVNwbGljZShzdGFydCwgY291bnQpIHtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCBzdGFydCwgY291bnRdKTtcbiAgICB9XG4gICAgY29uc3QgbmV3Q291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICBpZiAobmV3Q291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCBzdGFydCwgbmV3Q291bnRdKTtcbiAgICB9XG4gIH1cblxuICBfb25EYXRhVW5zaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgMCwgYXJndW1lbnRzLmxlbmd0aF0pO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge1xuICBfYXJyYXlVbmlxdWUsIGlzQXJyYXksIGlzTnVsbE9yVW5kZWYsXG4gIHZhbHVlT3JEZWZhdWx0LCByZXNvbHZlT2JqZWN0S2V5LCBzaWduLCBkZWZpbmVkXG59IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgdHlwZSkge1xuICBpZiAoIXNjYWxlLl9jYWNoZS4kYmFyKSB7XG4gICAgY29uc3QgdmlzaWJsZU1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSk7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB2aXNpYmxlTWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHZpc2libGVNZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkpO1xuICAgIH1cbiAgICBzY2FsZS5fY2FjaGUuJGJhciA9IF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpKTtcbiAgfVxuICByZXR1cm4gc2NhbGUuX2NhY2hlLiRiYXI7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFwib3B0aW1hbFwiIHNhbXBsZSBzaXplIHRvIG1haW50YWluIGJhcnMgZXF1YWxseSBzaXplZCB3aGlsZSBwcmV2ZW50aW5nIG92ZXJsYXAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKSB7XG4gIGNvbnN0IHNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZhbHVlcyA9IGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCBtZXRhLnR5cGUpO1xuICBsZXQgbWluID0gc2NhbGUuX2xlbmd0aDtcbiAgbGV0IGksIGlsZW4sIGN1cnIsIHByZXY7XG4gIGNvbnN0IHVwZGF0ZU1pbkFuZFByZXYgPSAoKSA9PiB7XG4gICAgaWYgKGN1cnIgPT09IDMyNzY3IHx8IGN1cnIgPT09IC0zMjc2OCkge1xuICAgICAgLy8gSWdub3JlIHRydW5jYXRlZCBwaXhlbHNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlZmluZWQocHJldikpIHtcbiAgICAgIC8vIGN1cnIgLSBwcmV2ID09PSAwIGlzIGlnbm9yZWRcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMoY3VyciAtIHByZXYpIHx8IG1pbik7XG4gICAgfVxuICAgIHByZXYgPSBjdXJyO1xuICB9O1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodmFsdWVzW2ldKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cblxuICBwcmV2ID0gdW5kZWZpbmVkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gc2NhbGUudGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cblxuICByZXR1cm4gbWluO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwiaWRlYWxcIiBjYXRlZ29yeSBiYXNlZCBvbiB0aGUgYWJzb2x1dGUgYmFyIHRoaWNrbmVzcyBvciwgaWYgdW5kZWZpbmVkIG9yIG51bGwsXG4gKiB1c2VzIHRoZSBzbWFsbGVzdCBpbnRlcnZhbCAoc2VlIGNvbXB1dGVNaW5TYW1wbGVTaXplKSB0aGF0IHByZXZlbnRzIGJhciBvdmVybGFwcGluZy4gVGhpc1xuICogbW9kZSBjdXJyZW50bHkgYWx3YXlzIGdlbmVyYXRlcyBiYXJzIGVxdWFsbHkgc2l6ZWQgKHVudGlsIHdlIGludHJvZHVjZSBzY3JpcHRhYmxlIG9wdGlvbnM/KS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gIGxldCBzaXplLCByYXRpbztcblxuICBpZiAoaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG4gICAgc2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICAgIHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gYmFyIHRoaWNrbmVzcyBpcyBlbmZvcmNlZCwgY2F0ZWdvcnkgYW5kIGJhciBwZXJjZW50YWdlcyBhcmUgaWdub3JlZC5cbiAgICAvLyBOb3RlKFNCKTogd2UgY291bGQgYWRkIHN1cHBvcnQgZm9yIHJlbGF0aXZlIGJhciB0aGlja25lc3MgKGUuZy4gYmFyVGhpY2tuZXNzOiAnNTAlJylcbiAgICAvLyBhbmQgZGVwcmVjYXRlIGJhclBlcmNlbnRhZ2Ugc2luY2UgdGhpcyB2YWx1ZSBpcyBpZ25vcmVkIHdoZW4gdGhpY2tuZXNzIGlzIGFic29sdXRlLlxuICAgIHNpemUgPSB0aGlja25lc3MgKiBzdGFja0NvdW50O1xuICAgIHJhdGlvID0gMTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvLFxuICAgIHN0YXJ0OiBydWxlci5waXhlbHNbaW5kZXhdIC0gKHNpemUgLyAyKVxuICB9O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwib3B0aW1hbFwiIGNhdGVnb3J5IHRoYXQgZ2xvYmFsbHkgYXJyYW5nZXMgYmFycyBzaWRlIGJ5IHNpZGUgKG5vIGdhcCB3aGVuXG4gKiBwZXJjZW50YWdlIG9wdGlvbnMgYXJlIDEpLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYW5kIGZvbGxvd2luZyBjYXRlZ29yaWVzLiBUaGlzIG1vZGVcbiAqIGdlbmVyYXRlcyBiYXJzIHdpdGggZGlmZmVyZW50IHdpZHRocyB3aGVuIGRhdGEgYXJlIG5vdCBldmVubHkgc3BhY2VkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgcGl4ZWxzID0gcnVsZXIucGl4ZWxzO1xuICBjb25zdCBjdXJyID0gcGl4ZWxzW2luZGV4XTtcbiAgbGV0IHByZXYgPSBpbmRleCA+IDAgPyBwaXhlbHNbaW5kZXggLSAxXSA6IG51bGw7XG4gIGxldCBuZXh0ID0gaW5kZXggPCBwaXhlbHMubGVuZ3RoIC0gMSA/IHBpeGVsc1tpbmRleCArIDFdIDogbnVsbDtcbiAgY29uc3QgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXG4gIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgLy8gZmlyc3QgZGF0YTogaXRzIHNpemUgaXMgZG91YmxlIGJhc2VkIG9uIHRoZSBuZXh0IHBvaW50IG9yLFxuICAgIC8vIGlmIGl0J3MgYWxzbyB0aGUgbGFzdCBkYXRhLCB3ZSB1c2UgdGhlIHNjYWxlIHNpemUuXG4gICAgcHJldiA9IGN1cnIgLSAobmV4dCA9PT0gbnVsbCA/IHJ1bGVyLmVuZCAtIHJ1bGVyLnN0YXJ0IDogbmV4dCAtIGN1cnIpO1xuICB9XG5cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAvLyBsYXN0IGRhdGE6IGl0cyBzaXplIGlzIGFsc28gZG91YmxlIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBwb2ludC5cbiAgICBuZXh0ID0gY3VyciArIGN1cnIgLSBwcmV2O1xuICB9XG5cbiAgY29uc3Qgc3RhcnQgPSBjdXJyIC0gKGN1cnIgLSBNYXRoLm1pbihwcmV2LCBuZXh0KSkgLyAyICogcGVyY2VudDtcbiAgY29uc3Qgc2l6ZSA9IE1hdGguYWJzKG5leHQgLSBwcmV2KSAvIDIgKiBwZXJjZW50O1xuXG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvOiBvcHRpb25zLmJhclBlcmNlbnRhZ2UsXG4gICAgc3RhcnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGNvbnN0IHN0YXJ0VmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMF0sIGkpO1xuICBjb25zdCBlbmRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVsxXSwgaSk7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBsZXQgYmFyU3RhcnQgPSBtaW47XG4gIGxldCBiYXJFbmQgPSBtYXg7XG5cbiAgaWYgKE1hdGguYWJzKG1pbikgPiBNYXRoLmFicyhtYXgpKSB7XG4gICAgYmFyU3RhcnQgPSBtYXg7XG4gICAgYmFyRW5kID0gbWluO1xuICB9XG5cbiAgLy8gU3RvcmUgYGJhckVuZGAgKGZ1cnRoZXN0IGF3YXkgZnJvbSBvcmlnaW4pIGFzIHBhcnNlZCB2YWx1ZSxcbiAgLy8gdG8gbWFrZSBzdGFja2luZyBzdHJhaWdodCBmb3J3YXJkXG4gIGl0ZW1bdlNjYWxlLmF4aXNdID0gYmFyRW5kO1xuXG4gIGl0ZW0uX2N1c3RvbSA9IHtcbiAgICBiYXJTdGFydCxcbiAgICBiYXJFbmQsXG4gICAgc3RhcnQ6IHN0YXJ0VmFsdWUsXG4gICAgZW5kOiBlbmRWYWx1ZSxcbiAgICBtaW4sXG4gICAgbWF4XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBpZiAoaXNBcnJheShlbnRyeSkpIHtcbiAgICBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpO1xuICB9IGVsc2Uge1xuICAgIGl0ZW1bdlNjYWxlLmF4aXNdID0gdlNjYWxlLnBhcnNlKGVudHJ5LCBpKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuZnVuY3Rpb24gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gIGNvbnN0IGxhYmVscyA9IGlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgY29uc3QgcGFyc2VkID0gW107XG4gIGxldCBpLCBpbGVuLCBpdGVtLCBlbnRyeTtcblxuICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBlbnRyeSA9IGRhdGFbaV07XG4gICAgaXRlbSA9IHt9O1xuICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpXSwgaSk7XG4gICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuZnVuY3Rpb24gaXNGbG9hdEJhcihjdXN0b20pIHtcbiAgcmV0dXJuIGN1c3RvbSAmJiBjdXN0b20uYmFyU3RhcnQgIT09IHVuZGVmaW5lZCAmJiBjdXN0b20uYmFyRW5kICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSB7XG4gIGlmIChzaXplICE9PSAwKSB7XG4gICAgcmV0dXJuIHNpZ24oc2l6ZSk7XG4gIH1cbiAgcmV0dXJuICh2U2NhbGUuaXNIb3Jpem9udGFsKCkgPyAxIDogLTEpICogKHZTY2FsZS5taW4gPj0gYWN0dWFsQmFzZSA/IDEgOiAtMSk7XG59XG5cbmZ1bmN0aW9uIGJvcmRlclByb3BzKHByb3BlcnRpZXMpIHtcbiAgbGV0IHJldmVyc2UsIHN0YXJ0LCBlbmQsIHRvcCwgYm90dG9tO1xuICBpZiAocHJvcGVydGllcy5ob3Jpem9udGFsKSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA+IHByb3BlcnRpZXMueDtcbiAgICBzdGFydCA9ICdsZWZ0JztcbiAgICBlbmQgPSAncmlnaHQnO1xuICB9IGVsc2Uge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPCBwcm9wZXJ0aWVzLnk7XG4gICAgc3RhcnQgPSAnYm90dG9tJztcbiAgICBlbmQgPSAndG9wJztcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHRvcCA9ICdlbmQnO1xuICAgIGJvdHRvbSA9ICdzdGFydCc7XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gJ3N0YXJ0JztcbiAgICBib3R0b20gPSAnZW5kJztcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfTtcbn1cblxuZnVuY3Rpb24gc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpIHtcbiAgbGV0IGVkZ2UgPSBvcHRpb25zLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IHJlcyA9IHt9O1xuXG4gIGlmICghZWRnZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWRnZSA9PT0gdHJ1ZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHt0b3A6IHRydWUsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUsIGxlZnQ6IHRydWV9O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX0gPSBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKTtcblxuICBpZiAoZWRnZSA9PT0gJ21pZGRsZScgJiYgc3RhY2spIHtcbiAgICBwcm9wZXJ0aWVzLmVuYWJsZUJvcmRlclJhZGl1cyA9IHRydWU7XG4gICAgaWYgKChzdGFjay5fdG9wIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9IGVsc2UgaWYgKChzdGFjay5fYm90dG9tIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IGJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW3BhcnNlRWRnZShib3R0b20sIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH1cbiAgfVxuXG4gIHJlc1twYXJzZUVkZ2UoZWRnZSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUVkZ2UoZWRnZSwgYSwgYiwgcmV2ZXJzZSkge1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGVkZ2UgPSBzd2FwKGVkZ2UsIGEsIGIpO1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBiLCBhKTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYSwgYik7XG4gIH1cbiAgcmV0dXJuIGVkZ2U7XG59XG5cbmZ1bmN0aW9uIHN3YXAob3JpZywgdjEsIHYyKSB7XG4gIHJldHVybiBvcmlnID09PSB2MSA/IHYyIDogb3JpZyA9PT0gdjIgPyB2MSA6IG9yaWc7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0RW5kKHYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHYgPT09ICdzdGFydCcgPyBzdGFydCA6IHYgPT09ICdlbmQnID8gZW5kIDogdjtcbn1cblxuZnVuY3Rpb24gc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCB7aW5mbGF0ZUFtb3VudH0sIHJhdGlvKSB7XG4gIHByb3BlcnRpZXMuaW5mbGF0ZUFtb3VudCA9IGluZmxhdGVBbW91bnQgPT09ICdhdXRvJ1xuICAgID8gcmF0aW8gPT09IDEgPyAwLjMzIDogMFxuICAgIDogaW5mbGF0ZUFtb3VudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnYmFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ2JhcicsXG5cbiAgICBjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcbiAgICBiYXJQZXJjZW50YWdlOiAwLjksXG4gICAgZ3JvdXBlZDogdHJ1ZSxcblxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J11cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIHNjYWxlczoge1xuICAgICAgX2luZGV4Xzoge1xuICAgICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgICBvZmZzZXQ6IHRydWUsXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBvZmZzZXQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF92YWx1ZV86IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuXHQgKiBPdmVycmlkaW5nIHByaW1pdGl2ZSBkYXRhIHBhcnNpbmcgc2luY2Ugd2Ugc3VwcG9ydCBtaXhlZCBwcmltaXRpdmUvYXJyYXlcblx0ICogZGF0YSBmb3IgZmxvYXQgYmFyc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgYXJyYXkgZGF0YSBwYXJzaW5nIHNpbmNlIHdlIHN1cHBvcnQgbWl4ZWQgcHJpbWl0aXZlL2FycmF5XG5cdCAqIGRhdGEgZm9yIGZsb2F0IGJhcnNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgb2JqZWN0IGRhdGEgcGFyc2luZyBzaW5jZSB3ZSBzdXBwb3J0IG1peGVkIHByaW1pdGl2ZS9hcnJheVxuXHQgKiB2YWx1ZS1zY2FsZSBkYXRhIGZvciBmbG9hdCBiYXJzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHBhcnNlZCA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBpdGVtLCBvYmo7XG4gICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvYmogPSBkYXRhW2ldO1xuICAgICAgaXRlbSA9IHt9O1xuICAgICAgaXRlbVtpU2NhbGUuYXhpc10gPSBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShvYmosIGlBeGlzS2V5KSwgaSk7XG4gICAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKHJlc29sdmVPYmplY3RLZXkob2JqLCB2QXhpc0tleSksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBzdXBlci51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBpZiAoY3VzdG9tICYmIHNjYWxlID09PSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSkge1xuICAgICAgLy8gZmxvYXQgYmFyOiBvbmx5IG9uZSBlbmQgb2YgdGhlIGJhciBpcyBjb25zaWRlcmVkIGJ5IGBzdXBlcmBcbiAgICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgY3VzdG9tLm1pbik7XG4gICAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIGN1c3RvbS5tYXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ8Ym9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzRmxvYXRCYXIoY3VzdG9tKVxuICAgICAgPyAnWycgKyBjdXN0b20uc3RhcnQgKyAnLCAnICsgY3VzdG9tLmVuZCArICddJ1xuICAgICAgOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuXG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5zdGFjayA9IHRoaXMuZ2V0RGF0YXNldCgpLnN0YWNrO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKG1ldGEuZGF0YSwgMCwgbWV0YS5kYXRhLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhiYXJzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2luZGV4LCBfY2FjaGVkTWV0YToge3ZTY2FsZX19ID0gdGhpcztcbiAgICBjb25zdCBiYXNlID0gdlNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB2U2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgcnVsZXIgPSB0aGlzLl9nZXRSdWxlcigpO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCB2cGl4ZWxzID0gcmVzZXQgfHwgaXNOdWxsT3JVbmRlZihwYXJzZWRbdlNjYWxlLmF4aXNdKSA/IHtiYXNlLCBoZWFkOiBiYXNlfSA6IHRoaXMuX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGkpO1xuICAgICAgY29uc3QgaXBpeGVscyA9IHRoaXMuX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGksIHJ1bGVyKTtcbiAgICAgIGNvbnN0IHN0YWNrID0gKHBhcnNlZC5fc3RhY2tzIHx8IHt9KVt2U2NhbGUuYXhpc107XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIGhvcml6b250YWwsXG4gICAgICAgIGJhc2U6IHZwaXhlbHMuYmFzZSxcbiAgICAgICAgZW5hYmxlQm9yZGVyUmFkaXVzOiAhc3RhY2sgfHwgaXNGbG9hdEJhcihwYXJzZWQuX2N1c3RvbSkgfHwgKGluZGV4ID09PSBzdGFjay5fdG9wIHx8IGluZGV4ID09PSBzdGFjay5fYm90dG9tKSxcbiAgICAgICAgeDogaG9yaXpvbnRhbCA/IHZwaXhlbHMuaGVhZCA6IGlwaXhlbHMuY2VudGVyLFxuICAgICAgICB5OiBob3Jpem9udGFsID8gaXBpeGVscy5jZW50ZXIgOiB2cGl4ZWxzLmhlYWQsXG4gICAgICAgIGhlaWdodDogaG9yaXpvbnRhbCA/IGlwaXhlbHMuc2l6ZSA6IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSksXG4gICAgICAgIHdpZHRoOiBob3Jpem9udGFsID8gTWF0aC5hYnModnBpeGVscy5zaXplKSA6IGlwaXhlbHMuc2l6ZVxuICAgICAgfTtcblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGJhcnNbaV0uYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBwcm9wZXJ0aWVzLm9wdGlvbnMgfHwgYmFyc1tpXS5vcHRpb25zO1xuICAgICAgc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpO1xuICAgICAgc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCBvcHRpb25zLCBydWxlci5yYXRpbyk7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYmFyc1tpXSwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2xhc3RdIC0gVGhlIGRhdGFzZXQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhSW5kZXhdIC0gVGhlIGRhdGEgaW5kZXggb2YgdGhlIHJ1bGVyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGxpc3Qgb2Ygc3RhY2sgSURzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tzKGxhc3QsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHtpU2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IGlTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0aGlzLl90eXBlKVxuICAgICAgLmZpbHRlcihtZXRhID0+IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmdyb3VwZWQpO1xuICAgIGNvbnN0IHN0YWNrZWQgPSBpU2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICAgIGNvbnN0IHN0YWNrcyA9IFtdO1xuXG4gICAgY29uc3Qgc2tpcE51bGwgPSAobWV0YSkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gbWV0YS5jb250cm9sbGVyLmdldFBhcnNlZChkYXRhSW5kZXgpO1xuICAgICAgY29uc3QgdmFsID0gcGFyc2VkICYmIHBhcnNlZFttZXRhLnZTY2FsZS5heGlzXTtcblxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IG1ldGEgb2YgbWV0YXNldHMpIHtcbiAgICAgIGlmIChkYXRhSW5kZXggIT09IHVuZGVmaW5lZCAmJiBza2lwTnVsbChtZXRhKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RhY2tlZCAgIHwgbWV0YS5zdGFja1xuICAgICAgLy8gICAgICAgICAgIHwgZm91bmQgfCBub3QgZm91bmQgfCB1bmRlZmluZWRcbiAgICAgIC8vIGZhbHNlICAgICB8ICAgeCAgIHwgICAgIHggICAgIHwgICAgIHhcbiAgICAgIC8vIHRydWUgICAgICB8ICAgICAgIHwgICAgIHggICAgIHxcbiAgICAgIC8vIHVuZGVmaW5lZCB8ICAgICAgIHwgICAgIHggICAgIHwgICAgIHhcbiAgICAgIGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGEuaW5kZXggPT09IGxhc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gc3RhY2tzPyB0aGF0IG1lYW5zIHRoZXJlIGlzIG5vIHZpc2libGUgZGF0YS4gTGV0J3Mgc3RpbGwgaW5pdGlhbGl6ZSBhbiBgdW5kZWZpbmVkYFxuICAgIC8vIHN0YWNrIHdoZXJlIHBvc3NpYmxlIGludmlzaWJsZSBiYXJzIHdpbGwgYmUgbG9jYXRlZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNjM2OFxuICAgIGlmICghc3RhY2tzLmxlbmd0aCkge1xuICAgICAgc3RhY2tzLnB1c2godW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSBudW1iZXIgb2Ygc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tDb3VudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGFja3ModW5kZWZpbmVkLCBpbmRleCkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrIGluZGV4IGZvciB0aGUgZ2l2ZW4gZGF0YXNldCBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFzZXRJbmRleF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gVGhlIHN0YWNrIG5hbWUgdG8gZmluZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHN0YWNrIGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG5hbWUsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCk7XG4gICAgY29uc3QgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgPyBzdGFja3MuaW5kZXhPZihuYW1lKVxuICAgICAgOiAtMTsgLy8gaW5kZXhPZiByZXR1cm5zIC0xIGlmIGVsZW1lbnQgaXMgbm90IHByZXNlbnRcblxuICAgIHJldHVybiAoaW5kZXggPT09IC0xKVxuICAgICAgPyBzdGFja3MubGVuZ3RoIC0gMVxuICAgICAgOiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJ1bGVyKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgcGl4ZWxzID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcGl4ZWxzLnB1c2goaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSlbaVNjYWxlLmF4aXNdLCBpKSk7XG4gICAgfVxuXG4gICAgY29uc3QgYmFyVGhpY2tuZXNzID0gb3B0cy5iYXJUaGlja25lc3M7XG4gICAgY29uc3QgbWluID0gYmFyVGhpY2tuZXNzIHx8IGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbixcbiAgICAgIHBpeGVscyxcbiAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXG4gICAgICBlbmQ6IGlTY2FsZS5fZW5kUGl4ZWwsXG4gICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgLy8gYmFyIHRoaWNrbmVzcyByYXRpbyB1c2VkIGZvciBub24tZ3JvdXBlZCBiYXJzXG4gICAgICByYXRpbzogYmFyVGhpY2tuZXNzID8gMSA6IG9wdHMuY2F0ZWdvcnlQZXJjZW50YWdlICogb3B0cy5iYXJQZXJjZW50YWdlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBOb3RlOiBwaXhlbCB2YWx1ZXMgYXJlIG5vdCBjbGFtcGVkIHRvIHRoZSBzY2FsZSBhcmVhLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGluZGV4KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiB7dlNjYWxlLCBfc3RhY2tlZCwgaW5kZXg6IGRhdGFzZXRJbmRleH0sIG9wdGlvbnM6IHtiYXNlOiBiYXNlVmFsdWUsIG1pbkJhckxlbmd0aH19ID0gdGhpcztcbiAgICBjb25zdCBhY3R1YWxCYXNlID0gYmFzZVZhbHVlIHx8IDA7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IGZsb2F0aW5nID0gaXNGbG9hdEJhcihjdXN0b20pO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgbGVuZ3RoID0gX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHZhbHVlO1xuICAgIGxldCBoZWFkLCBzaXplO1xuXG4gICAgaWYgKGxlbmd0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHN0YXJ0ID0gbGVuZ3RoIC0gdmFsdWU7XG4gICAgICBsZW5ndGggPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgIHZhbHVlID0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgbGVuZ3RoID0gY3VzdG9tLmJhckVuZCAtIGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIC8vIGJhcnMgY3Jvc3Npbmcgb3JpZ2luIGFyZSBub3Qgc3RhY2tlZFxuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IHZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAhaXNOdWxsT3JVbmRlZihiYXNlVmFsdWUpICYmICFmbG9hdGluZyA/IGJhc2VWYWx1ZSA6IHN0YXJ0O1xuICAgIGxldCBiYXNlID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnRWYWx1ZSk7XG5cbiAgICBpZiAodGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgIGhlYWQgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gbm90IHZpc2libGUsIG5vIGhlaWdodFxuICAgICAgaGVhZCA9IGJhc2U7XG4gICAgfVxuXG4gICAgc2l6ZSA9IGhlYWQgLSBiYXNlO1xuXG4gICAgaWYgKE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XG4gICAgICBzaXplID0gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpICogbWluQmFyTGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlID09PSBhY3R1YWxCYXNlKSB7XG4gICAgICAgIGJhc2UgLT0gc2l6ZSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwKTtcbiAgICAgIGNvbnN0IGVuZFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgxKTtcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGJhc2UgPSBNYXRoLm1heChNYXRoLm1pbihiYXNlLCBtYXgpLCBtaW4pO1xuICAgICAgaGVhZCA9IGJhc2UgKyBzaXplO1xuXG4gICAgICBpZiAoX3N0YWNrZWQgJiYgIWZsb2F0aW5nKSB7XG4gICAgICAgIC8vIHZpc3VhbCBkYXRhIGNvb3JkaW5hdGVzIGFmdGVyIGFwcGx5aW5nIG1pbkJhckxlbmd0aFxuICAgICAgICBwYXJzZWQuX3N0YWNrc1t2U2NhbGUuYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdID0gdlNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoaGVhZCkgLSB2U2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChiYXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoYWN0dWFsQmFzZSkpIHtcbiAgICAgIGNvbnN0IGhhbGZHcmlkID0gc2lnbihzaXplKSAqIHZTY2FsZS5nZXRMaW5lV2lkdGhGb3JWYWx1ZShhY3R1YWxCYXNlKSAvIDI7XG4gICAgICBiYXNlICs9IGhhbGZHcmlkO1xuICAgICAgc2l6ZSAtPSBoYWxmR3JpZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2l6ZSxcbiAgICAgIGJhc2UsXG4gICAgICBoZWFkLFxuICAgICAgY2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaW5kZXgsIHJ1bGVyKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBydWxlci5zY2FsZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNraXBOdWxsID0gb3B0aW9ucy5za2lwTnVsbDtcbiAgICBjb25zdCBtYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpO1xuICAgIGxldCBjZW50ZXIsIHNpemU7XG4gICAgaWYgKHJ1bGVyLmdyb3VwZWQpIHtcbiAgICAgIGNvbnN0IHN0YWNrQ291bnQgPSBza2lwTnVsbCA/IHRoaXMuX2dldFN0YWNrQ291bnQoaW5kZXgpIDogcnVsZXIuc3RhY2tDb3VudDtcbiAgICAgIGNvbnN0IHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuICAgICAgICA/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KVxuICAgICAgICA6IGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpO1xuXG4gICAgICBjb25zdCBzdGFja0luZGV4ID0gdGhpcy5fZ2V0U3RhY2tJbmRleCh0aGlzLmluZGV4LCB0aGlzLl9jYWNoZWRNZXRhLnN0YWNrLCBza2lwTnVsbCA/IGluZGV4IDogdW5kZWZpbmVkKTtcbiAgICAgIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgKHJhbmdlLmNodW5rICogc3RhY2tJbmRleCkgKyAocmFuZ2UuY2h1bmsgLyAyKTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJhbmdlLmNodW5rICogcmFuZ2UucmF0aW8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3Igbm9uLWdyb3VwZWQgYmFyIGNoYXJ0cywgZXhhY3QgcGl4ZWwgdmFsdWVzIGFyZSB1c2VkXG4gICAgICBjZW50ZXIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGluZGV4KVtzY2FsZS5heGlzXSwgaW5kZXgpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcnVsZXIubWluICogcnVsZXIucmF0aW8pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgY2VudGVyLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHJlY3RzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGlsZW4gPSByZWN0cy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmdldFBhcnNlZChpKVt2U2NhbGUuYXhpc10gIT09IG51bGwpIHtcbiAgICAgICAgcmVjdHNbaV0uZHJhdyh0aGlzLl9jdHgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge3ZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1YmJsZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2J1YmJsZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG5cbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnXVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgc2NhbGVzOiB7XG4gICAgICB4OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIHByaW1pdGl2ZSB2YWx1ZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cztcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBhcnJheXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbVsyXSwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBvYmplY3RzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbSAmJiBpdGVtLnIgJiYgK2l0ZW0uciwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgbGV0IG1heCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCB4ID0geFNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLngpO1xuICAgIGNvbnN0IHkgPSB5U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueSk7XG4gICAgY29uc3QgciA9IHBhcnNlZC5fY3VzdG9tO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArIChyID8gJywgJyArIHIgOiAnJykgKyAnKSdcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSAhcmVzZXQgJiYgdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IHJlc2V0ID8gaVNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0ID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW3ZBeGlzXSk7XG5cbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKTtcblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG5cbiAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgcHJvcGVydGllcy5vcHRpb25zLnJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBsZXQgdmFsdWVzID0gc3VwZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSk7XG5cbiAgICAvLyBJbiBjYXNlIHZhbHVlcyB3ZXJlIGNhY2hlZCAoYW5kIHRodXMgZnJvemVuKSwgd2UgbmVlZCB0byBjbG9uZSB0aGUgdmFsdWVzXG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICB2YWx1ZXMgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZXMsIHskc2hhcmVkOiBmYWxzZX0pO1xuICAgIH1cblxuICAgIC8vIEN1c3RvbSByYWRpdXMgcmVzb2x1dGlvblxuICAgIGNvbnN0IHJhZGl1cyA9IHZhbHVlcy5yYWRpdXM7XG4gICAgaWYgKG1vZGUgIT09ICdhY3RpdmUnKSB7XG4gICAgICB2YWx1ZXMucmFkaXVzID0gMDtcbiAgICB9XG4gICAgdmFsdWVzLnJhZGl1cyArPSB2YWx1ZU9yRGVmYXVsdChwYXJzZWQgJiYgcGFyc2VkLl9jdXN0b20sIHJhZGl1cyk7XG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge2lzT2JqZWN0LCByZXNvbHZlT2JqZWN0S2V5LCB0b1BlcmNlbnRhZ2UsIHRvRGltZW5zaW9uLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zLCBQSSwgVEFVLCBIQUxGX1BJLCBfYW5nbGVCZXR3ZWVufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuZnVuY3Rpb24gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCkge1xuICBsZXQgcmF0aW9YID0gMTtcbiAgbGV0IHJhdGlvWSA9IDE7XG4gIGxldCBvZmZzZXRYID0gMDtcbiAgbGV0IG9mZnNldFkgPSAwO1xuICAvLyBJZiB0aGUgY2hhcnQncyBjaXJjdW1mZXJlbmNlIGlzbid0IGEgZnVsbCBjaXJjbGUsIGNhbGN1bGF0ZSBzaXplIGFzIGEgcmF0aW8gb2YgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgYXJjXG4gIGlmIChjaXJjdW1mZXJlbmNlIDwgVEFVKSB7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHJvdGF0aW9uO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG4gICAgY29uc3Qgc3RhcnRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgZW5kWCA9IE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBlbmRZID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xuICAgIGNvbnN0IGNhbGNNYXggPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IDEgOiBNYXRoLm1heChhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBjYWxjTWluID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAtMSA6IE1hdGgubWluKGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFggPSBjYWxjTWF4KDAsIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWF4WSA9IGNhbGNNYXgoSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICBjb25zdCBtaW5YID0gY2FsY01pbihQSSwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtaW5ZID0gY2FsY01pbihQSSArIEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgcmF0aW9YID0gKG1heFggLSBtaW5YKSAvIDI7XG4gICAgcmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XG4gICAgb2Zmc2V0WCA9IC0obWF4WCArIG1pblgpIC8gMjtcbiAgICBvZmZzZXRZID0gLShtYXhZICsgbWluWSkgLyAyO1xuICB9XG4gIHJldHVybiB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb3VnaG51dENvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2RvdWdobnV0JztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICAvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgRG91Z2hudXRcbiAgICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgICAvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHNjYWxpbmcgdGhlIERvdWdobnV0IGZyb20gdGhlIGNlbnRyZVxuICAgICAgYW5pbWF0ZVNjYWxlOiBmYWxzZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWydjaXJjdW1mZXJlbmNlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAneCcsICd5JywgJ29mZnNldCcsICdib3JkZXJXaWR0aCcsICdzcGFjaW5nJ11cbiAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2hhcnQgdGhhdCB3ZSBjdXQgb3V0IG9mIHRoZSBtaWRkbGUuXG4gICAgY3V0b3V0OiAnNTAlJyxcblxuICAgIC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXG4gICAgcm90YXRpb246IDAsXG5cbiAgICAvLyBUaGUgdG90YWwgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2hhcnQuXG4gICAgY2lyY3VtZmVyZW5jZTogMzYwLFxuXG4gICAgLy8gVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY2hhcnRcbiAgICByYWRpdXM6ICcxMDAlJyxcblxuICAgIC8vIFNwYWNpbmcgYmV0d2VlbiBhcmNzXG4gICAgc3BhY2luZzogMCxcblxuICAgIGluZGV4QXhpczogJ3InLFxuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2JvcmRlckRhc2gnKSAmJiAhbmFtZS5zdGFydHNXaXRoKCdob3ZlckJvcmRlckRhc2gnKSxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgYXNwZWN0UmF0aW86IDEsXG5cbiAgICAvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcbiAgICBwbHVnaW5zOiB7XG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZSwgY29sb3J9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuXG4gICAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcblxuICAgICAgICAgICAgICAgICAgLy8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXG4gICAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuXG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxpbmtTY2FsZXMoKSB7fVxuXG4gIC8qKlxuXHQgKiBPdmVycmlkZSBkYXRhIHBhcnNpbmcsIHNpbmNlIHdlIGFyZSBub3QgdXNpbmcgc2NhbGVzXG5cdCAqL1xuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhc2V0KCkuZGF0YTtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcblxuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGdldHRlciA9IChpKSA9PiArZGF0YVtpXTtcblxuICAgICAgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBjb25zdCB7a2V5ID0gJ3ZhbHVlJ30gPSB0aGlzLl9wYXJzaW5nO1xuICAgICAgICBnZXR0ZXIgPSAoaSkgPT4gK3Jlc29sdmVPYmplY3RLZXkoZGF0YVtpXSwga2V5KTtcbiAgICAgIH1cblxuICAgICAgbGV0IGksIGlsZW47XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2ldID0gZ2V0dGVyKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLnJvdGF0aW9uIC0gOTApO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0Q2lyY3VtZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5jaXJjdW1mZXJlbmNlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgdGhlIG1heGltYWwgcm90YXRpb24gJiBjaXJjdW1mZXJlbmNlIGV4dGVudHNcblx0ICogYWNyb3NzIGFsbCB2aXNpYmxlIGRhdGFzZXRzLlxuXHQgKi9cbiAgX2dldFJvdGF0aW9uRXh0ZW50cygpIHtcbiAgICBsZXQgbWluID0gVEFVO1xuICAgIGxldCBtYXggPSAtVEFVO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkgJiYgdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpKS50eXBlID09PSB0aGlzLl90eXBlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gY29udHJvbGxlci5fZ2V0Um90YXRpb24oKTtcbiAgICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IGNvbnRyb2xsZXIuX2dldENpcmN1bWZlcmVuY2UoKTtcblxuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJvdGF0aW9uKTtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByb3RhdGlvbiArIGNpcmN1bWZlcmVuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByb3RhdGlvbjogbWluLFxuICAgICAgY2lyY3VtZmVyZW5jZTogbWF4IC0gbWluLFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGVcblx0ICovXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHtjaGFydEFyZWF9ID0gY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5nZXRNYXhCb3JkZXJXaWR0aCgpICsgdGhpcy5nZXRNYXhPZmZzZXQoYXJjcykgKyB0aGlzLm9wdGlvbnMuc3BhY2luZztcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoKE1hdGgubWluKGNoYXJ0QXJlYS53aWR0aCwgY2hhcnRBcmVhLmhlaWdodCkgLSBzcGFjaW5nKSAvIDIsIDApO1xuICAgIGNvbnN0IGN1dG91dCA9IE1hdGgubWluKHRvUGVyY2VudGFnZSh0aGlzLm9wdGlvbnMuY3V0b3V0LCBtYXhTaXplKSwgMSk7XG4gICAgY29uc3QgY2hhcnRXZWlnaHQgPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KHRoaXMuaW5kZXgpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbWF4aW1hbCByb3RhdGlvbiAmIGNpcmN1bWZlcmVuY2UgbGltaXRzLlxuICAgIC8vIElmIHdlIG9ubHkgY29uc2lkZXIgb3VyIGRhdGFzZXQsIHRoaXMgY2FuIGNhdXNlIHByb2JsZW1zIHdoZW4gdHdvIGRhdGFzZXRzXG4gICAgLy8gYXJlIGJvdGggbGVzcyB0aGFuIGEgY2lyY2xlIHdpdGggZGlmZmVyZW50IHJvdGF0aW9ucyAoc3RhcnRpbmcgYW5nbGVzKVxuICAgIGNvbnN0IHtjaXJjdW1mZXJlbmNlLCByb3RhdGlvbn0gPSB0aGlzLl9nZXRSb3RhdGlvbkV4dGVudHMoKTtcbiAgICBjb25zdCB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9ID0gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCk7XG4gICAgY29uc3QgbWF4V2lkdGggPSAoY2hhcnRBcmVhLndpZHRoIC0gc3BhY2luZykgLyByYXRpb1g7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gKGNoYXJ0QXJlYS5oZWlnaHQgLSBzcGFjaW5nKSAvIHJhdGlvWTtcbiAgICBjb25zdCBtYXhSYWRpdXMgPSBNYXRoLm1heChNYXRoLm1pbihtYXhXaWR0aCwgbWF4SGVpZ2h0KSAvIDIsIDApO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gdG9EaW1lbnNpb24odGhpcy5vcHRpb25zLnJhZGl1cywgbWF4UmFkaXVzKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG91dGVyUmFkaXVzICogY3V0b3V0LCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyB0aGlzLl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCk7XG4gICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WCAqIG91dGVyUmFkaXVzO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFkgKiBvdXRlclJhZGl1cztcblxuICAgIG1ldGEudG90YWwgPSB0aGlzLmNhbGN1bGF0ZVRvdGFsKCk7XG5cbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSBNYXRoLm1heCh0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogY2hhcnRXZWlnaHQsIDApO1xuXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgIGlmICgocmVzZXQgJiYgb3B0cy5hbmltYXRpb24uYW5pbWF0ZVJvdGF0ZSkgfHwgIXRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgfHwgbWV0YS5fcGFyc2VkW2ldID09PSBudWxsIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKG1ldGEuX3BhcnNlZFtpXSAqIGNpcmN1bWZlcmVuY2UgLyBUQVUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IGNlbnRlclggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG4gICAgY29uc3QgYW5pbWF0ZVNjYWxlID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGU7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5pbm5lclJhZGl1cztcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLm91dGVyUmFkaXVzO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBsZXQgc3RhcnRBbmdsZSA9IHRoaXMuX2dldFJvdGF0aW9uKCk7XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgc3RhcnRBbmdsZSArPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclggKyB0aGlzLm9mZnNldFgsXG4gICAgICAgIHk6IGNlbnRlclkgKyB0aGlzLm9mZnNldFksXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIGlubmVyUmFkaXVzXG4gICAgICB9O1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgc3RhcnRBbmdsZSArPSBjaXJjdW1mZXJlbmNlO1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVUb3RhbCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhRGF0YSA9IG1ldGEuZGF0YTtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG1ldGFEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG1ldGEuX3BhcnNlZFtpXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiAhaXNOYU4odmFsdWUpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgJiYgIW1ldGFEYXRhW2ldLmhpZGRlbikge1xuICAgICAgICB0b3RhbCArPSBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG5cbiAgY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSh2YWx1ZSkge1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5fY2FjaGVkTWV0YS50b3RhbDtcbiAgICBpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBUQVUgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XSwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuXG4gIGdldE1heEJvcmRlcldpZHRoKGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGV0IGksIGlsZW4sIG1ldGEsIGNvbnRyb2xsZXIsIG9wdGlvbnM7XG5cbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIC8vIEZpbmQgdGhlIG91dG1vc3QgdmlzaWJsZSBkYXRhc2V0XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICAgICAgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICAgICAgICBjb250cm9sbGVyID0gbWV0YS5jb250cm9sbGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9wdGlvbnMgPSBjb250cm9sbGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBpZiAob3B0aW9ucy5ib3JkZXJBbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMCwgb3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoIHx8IDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG5cbiAgZ2V0TWF4T2Zmc2V0KGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMub2Zmc2V0IHx8IDAsIG9wdGlvbnMuaG92ZXJPZmZzZXQgfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cblxuICAvKipcblx0ICogR2V0IHJhZGl1cyBsZW5ndGggb2Zmc2V0IG9mIHRoZSBkYXRhc2V0IGluIHJlbGF0aW9uIHRvIHRoZSB2aXNpYmxlIGRhdGFzZXRzIHdlaWdodHMuIFRoaXMgYWxsb3dzIGRldGVybWluaW5nIHRoZSBpbm5lciBhbmQgb3V0ZXIgcmFkaXVzIGNvcnJlY3RseVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJpbmdXZWlnaHRPZmZzZXQoZGF0YXNldEluZGV4KSB7XG4gICAgbGV0IHJpbmdXZWlnaHRPZmZzZXQgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICByaW5nV2VpZ2h0T2Zmc2V0ICs9IHRoaXMuX2dldFJpbmdXZWlnaHQoaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJpbmdXZWlnaHRPZmZzZXQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSaW5nV2VpZ2h0KGRhdGFzZXRJbmRleCkge1xuICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZU9yRGVmYXVsdCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS53ZWlnaHQsIDEpLCAwKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdW0gb2YgYWxsIHZpc2libGUgZGF0YSBzZXQgd2VpZ2h0cy5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHx8IDE7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge2lzTnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzLCBfc2NhbGVSYW5nZXNDaGFuZ2VkfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2xpbmUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcblxuICAgIHNob3dMaW5lOiB0cnVlLFxuICAgIHNwYW5HYXBzOiBmYWxzZSxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgc2NhbGVzOiB7XG4gICAgICBfaW5kZXhfOiB7XG4gICAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICB9LFxuICAgICAgX3ZhbHVlXzoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgIH0sXG4gICAgfVxuICB9O1xuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgZGF0YTogcG9pbnRzID0gW10sIF9kYXRhc2V0fSA9IG1ldGE7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG5cbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcblxuICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIExpbmVcbiAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG5cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICB9XG4gICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICBvcHRpb25zXG4gICAgfSwgbW9kZSk7XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgY291bnQ7XG4gICAgY29uc3QgcG9pbnRzQ291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0NvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG5cbiAgICAgIGlmIChpIDwgc3RhcnQgfHwgaSA+PSBlbmQpIHtcbiAgICAgICAgcHJvcGVydGllcy5za2lwID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG5cbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuZGF0YXNldC51cGRhdGVDb250cm9sUG9pbnRzKHRoaXMuY2hhcnQuY2hhcnRBcmVhLCBtZXRhLmlTY2FsZS5heGlzKTtcbiAgICBzdXBlci5kcmF3KCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zLCBQSSwgZm9ybWF0TnVtYmVyLCBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2xhckFyZWFDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdwb2xhckFyZWEnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgICAgYW5pbWF0ZVNjYWxlOiB0cnVlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJ11cbiAgICAgIH0sXG4gICAgfSxcbiAgICBpbmRleEF4aXM6ICdyJyxcbiAgICBzdGFydEFuZ2xlOiAwLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBhc3BlY3RSYXRpbzogMSxcblxuICAgIHBsdWdpbnM6IHtcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlLCBjb2xvcn19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuXG4gICAgICAgICAgICAgICAgICAvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cbiAgICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzY2FsZXM6IHtcbiAgICAgIHI6IHtcbiAgICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGNpcmN1bGFyOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRBbmdsZTogMFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG5cbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0uciwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgYXJjcyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIHRoaXMuX3VwZGF0ZVJhZGl1cygpO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldE1pbk1heCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuXG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCkucjtcblxuICAgICAgaWYgKCFpc05hTihwYXJzZWQpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGlmIChwYXJzZWQgPCByYW5nZS5taW4pIHtcbiAgICAgICAgICByYW5nZS5taW4gPSBwYXJzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VkID4gcmFuZ2UubWF4KSB7XG4gICAgICAgICAgcmFuZ2UubWF4ID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVSYWRpdXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBtaW5TaXplID0gTWF0aC5taW4oY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQsIGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wKTtcblxuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgobWluU2l6ZSAvIDIsIDApO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3B0cy5jdXRvdXRQZXJjZW50YWdlID8gKG91dGVyUmFkaXVzIC8gMTAwKSAqIChvcHRzLmN1dG91dFBlcmNlbnRhZ2UpIDogMSwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gY2hhcnQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xuXG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gKHJhZGl1c0xlbmd0aCAqIHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCBjZW50ZXJYID0gc2NhbGUueENlbnRlcjtcbiAgICBjb25zdCBjZW50ZXJZID0gc2NhbGUueUNlbnRlcjtcbiAgICBjb25zdCBkYXRhc2V0U3RhcnRBbmdsZSA9IHNjYWxlLmdldEluZGV4QW5nbGUoMCkgLSAwLjUgKiBQSTtcbiAgICBsZXQgYW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICBsZXQgaTtcblxuICAgIGNvbnN0IGRlZmF1bHRBbmdsZSA9IDM2MCAvIHRoaXMuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBhbmdsZSArPSB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBsZXQgc3RhcnRBbmdsZSA9IGFuZ2xlO1xuICAgICAgbGV0IGVuZEFuZ2xlID0gYW5nbGUgKyB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICAgIGxldCBvdXRlclJhZGl1cyA9IGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpID8gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSkucikgOiAwO1xuICAgICAgYW5nbGUgPSBlbmRBbmdsZTtcblxuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSkge1xuICAgICAgICAgIG91dGVyUmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XG4gICAgICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgeTogY2VudGVyWSxcbiAgICAgICAgaW5uZXJSYWRpdXM6IDAsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICBjb3VudFZpc2libGVFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIWlzTmFOKHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUFuZ2xlKGluZGV4LCBtb2RlLCBkZWZhdWx0QW5nbGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleClcbiAgICAgID8gdG9SYWRpYW5zKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkuYW5nbGUgfHwgZGVmYXVsdEFuZ2xlKVxuICAgICAgOiAwO1xuICB9XG59XG4iLCAiaW1wb3J0IERvdWdobnV0Q29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIuZG91Z2hudXQuanMnO1xuXG4vLyBQaWUgY2hhcnRzIGFyZSBEb3VnaG51dCBjaGFydCB3aXRoIGRpZmZlcmVudCBkZWZhdWx0c1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGllQ29udHJvbGxlciBleHRlbmRzIERvdWdobnV0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3BpZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLy8gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNoYXJ0IHRoYXQgd2UgY3V0IG91dCBvZiB0aGUgbWlkZGxlLlxuICAgIGN1dG91dDogMCxcblxuICAgIC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXG4gICAgcm90YXRpb246IDAsXG5cbiAgICAvLyBUaGUgdG90YWwgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2hhcnQuXG4gICAgY2lyY3VtZmVyZW5jZTogMzYwLFxuXG4gICAgLy8gVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY2hhcnRcbiAgICByYWRpdXM6ICcxMDAlJ1xuICB9O1xufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3JhZGFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gICAgaW5kZXhBeGlzOiAncicsXG4gICAgc2hvd0xpbmU6IHRydWUsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgZmlsbDogJ3N0YXJ0J1xuICAgICAgfVxuICAgIH0sXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIGFzcGVjdFJhdGlvOiAxLFxuXG4gICAgc2NhbGVzOiB7XG4gICAgICByOiB7XG4gICAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IHZTY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogdlNjYWxlLmdldExhYmVscygpW2luZGV4XSxcbiAgICAgIHZhbHVlOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgbGFiZWxzID0gbWV0YS5pU2NhbGUuZ2V0TGFiZWxzKCk7XG5cbiAgICAvLyBVcGRhdGUgTGluZVxuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgIC8vIEluIHJlc2l6ZSBtb2RlIG9ubHkgcG9pbnQgbG9jYXRpb25zIGNoYW5nZSwgc28gbm8gbmVlZCB0byBzZXQgdGhlIHBvaW50cyBvciBvcHRpb25zLlxuICAgIGlmIChtb2RlICE9PSAncmVzaXplJykge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBfbG9vcDogdHJ1ZSxcbiAgICAgICAgX2Z1bGxMb29wOiBsYWJlbHMubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHRoaXMuZ2V0UGFyc2VkKGkpLnIpO1xuXG4gICAgICBjb25zdCB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuICAgICAgY29uc3QgeSA9IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueTtcblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgYW5nbGU6IHBvaW50UG9zaXRpb24uYW5nbGUsXG4gICAgICAgIHNraXA6IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7aXNOdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMsIF9zY2FsZVJhbmdlc0NoYW5nZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2F0dGVyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnc2NhdHRlcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gICAgc2hvd0xpbmU6IGZhbHNlLFxuICAgIGZpbGw6IGZhbHNlXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuXG4gICAgaW50ZXJhY3Rpb246IHtcbiAgICAgIG1vZGU6ICdwb2ludCdcbiAgICB9LFxuXG4gICAgc2NhbGVzOiB7XG4gICAgICB4OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlOiAnKCcgKyB4ICsgJywgJyArIHkgKyAnKSdcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YTogcG9pbnRzID0gW119ID0gbWV0YTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcblxuICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuXG4gICAgaWYgKF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8xMTMzM1xuICAgICAgaWYgKCF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgX2RhdGFzZXR9ID0gbWV0YTtcblxuICAgICAgLy8gVXBkYXRlIExpbmVcbiAgICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcblxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgbW9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzExMzMzXG4gICAgICBkZWxldGUgbWV0YS5kYXRhc2V0O1xuICAgICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cblxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCB7c2hvd0xpbmV9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSAmJiBzaG93TGluZSkge1xuICAgICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSB0aGlzLmNoYXJ0LnJlZ2lzdHJ5LmdldEVsZW1lbnQoJ2xpbmUnKTtcbiAgICB9XG5cbiAgICBzdXBlci5hZGRFbGVtZW50cygpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcblxuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgKE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkpID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBsZXQgbWF4ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcblxuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxufVxuIiwgIi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5fYWRhcHRlcnNcbiAqIEBzaW5jZSAyLjguMFxuICogQHByaXZhdGVcbiAqL1xuXG5pbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRPcHRpb25zfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmV4cG9ydCB0eXBlIFRpbWVVbml0ID0gJ21pbGxpc2Vjb25kJyB8ICdzZWNvbmQnIHwgJ21pbnV0ZScgfCAnaG91cicgfCAnZGF5JyB8ICd3ZWVrJyB8ICdtb250aCcgfCAncXVhcnRlcicgfCAneWVhcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZUFkYXB0ZXI8VCBleHRlbmRzIEFueU9iamVjdCA9IEFueU9iamVjdD4ge1xuICByZWFkb25seSBvcHRpb25zOiBUO1xuICAvKipcbiAgICogV2lsbCBjYWxsZWQgd2l0aCBjaGFydCBvcHRpb25zIGFmdGVyIGFkYXB0ZXIgY3JlYXRpb24uXG4gICAqL1xuICBpbml0KHRoaXM6IERhdGVBZGFwdGVyPFQ+LCBjaGFydE9wdGlvbnM6IENoYXJ0T3B0aW9ucyk6IHZvaWQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbWFwIG9mIHRpbWUgZm9ybWF0cyBmb3IgdGhlIHN1cHBvcnRlZCBmb3JtYXR0aW5nIHVuaXRzIGRlZmluZWRcbiAgICogaW4gVW5pdCBhcyB3ZWxsIGFzICdkYXRldGltZScgcmVwcmVzZW50aW5nIGEgZGV0YWlsZWQgZGF0ZS90aW1lIHN0cmluZy5cbiAgICovXG4gIGZvcm1hdHModGhpczogRGF0ZUFkYXB0ZXI8VD4pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiBgdmFsdWVgIGFuZCByZXR1cm4gdGhlIGFzc29jaWF0ZWQgdGltZXN0YW1wLlxuICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gcGFyc2UgKHVzdWFsbHkgY29tZXMgZnJvbSB0aGUgZGF0YSlcbiAgICogQHBhcmFtIFtmb3JtYXRdIC0gdGhlIGV4cGVjdGVkIGRhdGEgZm9ybWF0XG4gICAqL1xuICBwYXJzZSh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdmFsdWU6IHVua25vd24sIGZvcm1hdD86IFRpbWVVbml0KTogbnVtYmVyIHwgbnVsbDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvcm1hdHRlZCBkYXRlIGluIHRoZSBzcGVjaWZpZWQgYGZvcm1hdGAgZm9yIGEgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgdGltZXN0YW1wIHRvIGZvcm1hdFxuICAgKiBAcGFyYW0gZm9ybWF0IC0gdGhlIGRhdGUvdGltZSB0b2tlblxuICAgKi9cbiAgZm9ybWF0KHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgZm9ybWF0OiBUaW1lVW5pdCk6IHN0cmluZztcbiAgLyoqXG4gICAqIEFkZHMgdGhlIHNwZWNpZmllZCBgYW1vdW50YCBvZiBgdW5pdGAgdG8gdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuICAgKiBAcGFyYW0gYW1vdW50IC0gdGhlIGFtb3VudCB0byBhZGRcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGFkZCh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdGltZXN0YW1wOiBudW1iZXIsIGFtb3VudDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCk6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBgdW5pdGAgYmV0d2VlbiB0aGUgZ2l2ZW4gdGltZXN0YW1wcy5cbiAgICogQHBhcmFtIGEgLSB0aGUgaW5wdXQgdGltZXN0YW1wIChyZWZlcmVuY2UpXG4gICAqIEBwYXJhbSBiIC0gdGhlIHRpbWVzdGFtcCB0byBzdWJ0cmFjdFxuICAgKiBAcGFyYW0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuICAgKi9cbiAgZGlmZih0aGlzOiBEYXRlQWRhcHRlcjxUPiwgYTogbnVtYmVyLCBiOiBudW1iZXIsIHVuaXQ6IFRpbWVVbml0KTogbnVtYmVyO1xuICAvKipcbiAgICogUmV0dXJucyBzdGFydCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICogQHBhcmFtIFt3ZWVrZGF5XSAtIHRoZSBJU08gZGF5IG9mIHRoZSB3ZWVrIHdpdGggMSBiZWluZyBNb25kYXlcbiAgICogYW5kIDcgYmVpbmcgU3VuZGF5IChvbmx5IG5lZWRlZCBpZiBwYXJhbSAqdW5pdCogaXMgYGlzb1dlZWtgKS5cbiAgICovXG4gIHN0YXJ0T2YodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCB8ICdpc29XZWVrJywgd2Vla2RheT86IG51bWJlcik6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHVybnMgZW5kIG9mIGB1bml0YCBmb3IgdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuICAgKiBAcGFyYW0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuICAgKi9cbiAgZW5kT2YodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCB8ICdpc29XZWVrJyk6IG51bWJlcjtcbn1cblxuZnVuY3Rpb24gYWJzdHJhY3Q8VCA9IHZvaWQ+KCk6IFQge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogQ2hlY2sgdGhhdCBhIGNvbXBsZXRlIGRhdGUgYWRhcHRlciBpcyBwcm92aWRlZC4nKTtcbn1cblxuLyoqXG4gKiBEYXRlIGFkYXB0ZXIgKGN1cnJlbnQgdXNlZCBieSB0aGUgdGltZSBzY2FsZSlcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlXG4gKiBAbWVtYmVyb2YgQ2hhcnQuX2FkYXB0ZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBEYXRlQWRhcHRlckJhc2UgaW1wbGVtZW50cyBEYXRlQWRhcHRlciB7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIGRlZmF1bHQgZGF0ZSBhZGFwdGVyIG1ldGhvZHMuXG4gICAqIEFjY2VwdHMgdHlwZSBwYXJhbWV0ZXIgdG8gZGVmaW5lIG9wdGlvbnMgdHlwZS5cbiAgICogQGV4YW1wbGVcbiAgICogQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlLm92ZXJyaWRlPHtteUFkYXB0ZXJPcHRpb246IHN0cmluZ30+KHtcbiAgICogICBpbml0KCkge1xuICAgKiAgICAgY29uc29sZS5sb2codGhpcy5vcHRpb25zLm15QWRhcHRlck9wdGlvbik7XG4gICAqICAgfVxuICAgKiB9KVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlPFQgZXh0ZW5kcyBBbnlPYmplY3QgPSBBbnlPYmplY3Q+KFxuICAgIG1lbWJlcnM6IFBhcnRpYWw8T21pdDxEYXRlQWRhcHRlcjxUPiwgJ29wdGlvbnMnPj5cbiAgKSB7XG4gICAgT2JqZWN0LmFzc2lnbihEYXRlQWRhcHRlckJhc2UucHJvdG90eXBlLCBtZW1iZXJzKTtcbiAgfVxuXG4gIHJlYWRvbmx5IG9wdGlvbnM6IEFueU9iamVjdDtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBbnlPYmplY3QpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICBpbml0KCkge31cblxuICBmb3JtYXRzKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgcGFyc2UoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBmb3JtYXQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGFkZCgpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgZGlmZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgc3RhcnRPZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgZW5kT2YoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9kYXRlOiBEYXRlQWRhcHRlckJhc2Vcbn07XG4iLCAiaW1wb3J0IHtfbG9va3VwQnlLZXksIF9ybG9va3VwQnlLZXl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7Z2V0UmVsYXRpdmVQb3NpdGlvbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge19hbmdsZUJldHdlZW4sIGdldEFuZ2xlRnJvbVBvaW50fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7e2F4aXM/OiBzdHJpbmcsIGludGVyc2VjdD86IGJvb2xlYW4sIGluY2x1ZGVJbnZpc2libGU/OiBib29sZWFufX0gSW50ZXJhY3Rpb25PcHRpb25zXG4gKiBAdHlwZWRlZiB7e2RhdGFzZXRJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBlbGVtZW50OiBpbXBvcnQoJy4vY29yZS5lbGVtZW50LmpzJykuZGVmYXVsdH19IEludGVyYWN0aW9uSXRlbVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuUG9pbnQgfSBQb2ludFxuICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRvIGJpbmFyeSBzZWFyY2ggd2hlbiBwb3NzaWJsZVxuICogQHBhcmFtIHtvYmplY3R9IG1ldGFzZXQgLSB0aGUgZGF0YXNldCBtZXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIHNob3VsZCB0aGUgZWxlbWVudCBpbnRlcnNlY3RcbiAqIEByZXR1cm5zIHt7bG86bnVtYmVyLCBoaTpudW1iZXJ9fSBpbmRpY2VzIHRvIHNlYXJjaCBkYXRhIGFycmF5IGJldHdlZW5cbiAqL1xuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKG1ldGFzZXQsIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpIHtcbiAgY29uc3Qge2NvbnRyb2xsZXIsIGRhdGEsIF9zb3J0ZWR9ID0gbWV0YXNldDtcbiAgY29uc3QgaVNjYWxlID0gY29udHJvbGxlci5fY2FjaGVkTWV0YS5pU2NhbGU7XG4gIGlmIChpU2NhbGUgJiYgYXhpcyA9PT0gaVNjYWxlLmF4aXMgJiYgYXhpcyAhPT0gJ3InICYmIF9zb3J0ZWQgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBsb29rdXBNZXRob2QgPSBpU2NhbGUuX3JldmVyc2VQaXhlbHMgPyBfcmxvb2t1cEJ5S2V5IDogX2xvb2t1cEJ5S2V5O1xuICAgIGlmICghaW50ZXJzZWN0KSB7XG4gICAgICByZXR1cm4gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIuX3NoYXJlZE9wdGlvbnMpIHtcbiAgICAgIC8vIF9zaGFyZWRPcHRpb25zIGluZGljYXRlcyB0aGF0IGVhY2ggZWxlbWVudCBoYXMgZXF1YWwgb3B0aW9ucyAtPiBlcXVhbCBwcm9wb3J0aW9uc1xuICAgICAgLy8gU28gd2UgY2FuIGRvIGEgcmFuZ2VkIGJpbmFyeSBzZWFyY2ggYmFzZWQgb24gdGhlIHJhbmdlIG9mIGZpcnN0IGVsZW1lbnQgYW5kXG4gICAgICAvLyBiZSBjb25maWRlbnQgdG8gZ2V0IHRoZSBmdWxsIHJhbmdlIG9mIGluZGljZXMgdGhhdCBjYW4gaW50ZXJzZWN0IHdpdGggdGhlIHZhbHVlLlxuICAgICAgY29uc3QgZWwgPSBkYXRhWzBdO1xuICAgICAgY29uc3QgcmFuZ2UgPSB0eXBlb2YgZWwuZ2V0UmFuZ2UgPT09ICdmdW5jdGlvbicgJiYgZWwuZ2V0UmFuZ2UoYXhpcyk7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgLSByYW5nZSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSArIHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHtsbzogc3RhcnQubG8sIGhpOiBlbmQuaGl9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEZWZhdWx0IHRvIGFsbCBlbGVtZW50cywgd2hlbiBiaW5hcnkgc2VhcmNoIGNhbiBub3QgYmUgdXNlZC5cbiAgcmV0dXJuIHtsbzogMCwgaGk6IGRhdGEubGVuZ3RoIC0gMX07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHNlbGVjdCBjYW5kaWRhdGUgZWxlbWVudHMgZm9yIGludGVyYWN0aW9uXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSB0aGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBmb3IgZWFjaCB2aXNpYmxlIGl0ZW1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBjb25zaWRlciBpbnRlcnNlY3RpbmcgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgaGFuZGxlciwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW2F4aXNdO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IHtpbmRleCwgZGF0YX0gPSBtZXRhc2V0c1tpXTtcbiAgICBjb25zdCB7bG8sIGhpfSA9IGJpbmFyeVNlYXJjaChtZXRhc2V0c1tpXSwgYXhpcywgdmFsdWUsIGludGVyc2VjdCk7XG4gICAgZm9yIChsZXQgaiA9IGxvOyBqIDw9IGhpOyArK2opIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkYXRhW2pdO1xuICAgICAgaWYgKCFlbGVtZW50LnNraXApIHtcbiAgICAgICAgaGFuZGxlcihlbGVtZW50LCBpbmRleCwgaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IGEgZGlzdGFuY2UgbWV0cmljIGZ1bmN0aW9uIGZvciB0d28gcG9pbnRzIGJhc2VkIG9uIHRoZVxuICogYXhpcyBtb2RlIHNldHRpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpIHtcbiAgY29uc3QgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcbiAgY29uc3QgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcblxuICByZXR1cm4gZnVuY3Rpb24ocHQxLCBwdDIpIHtcbiAgICBjb25zdCBkZWx0YVggPSB1c2VYID8gTWF0aC5hYnMocHQxLnggLSBwdDIueCkgOiAwO1xuICAgIGNvbnN0IGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIGV2ZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZpc2libGVdIC0gaW5jbHVkZSBpbnZpc2libGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNoYXJ0IGFyZWFcbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcblxuICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgY29uc3QgZXZhbHVhdGlvbkZ1bmMgPSBmdW5jdGlvbihlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFfaXNQb2ludEluQXJlYShlbGVtZW50LCBjaGFydC5jaGFydEFyZWEsIDApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH07XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMsIHRydWUpO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gZm9yIGEgcmFkaWFsIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGVzIGFsb25nIHdoaWNoIHRvIG1lYXN1cmUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGV9ID0gZWxlbWVudC5nZXRQcm9wcyhbJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlfSA9IGdldEFuZ2xlRnJvbVBvaW50KGVsZW1lbnQsIHt4OiBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55fSk7XG5cbiAgICBpZiAoX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gZm9yIGEgY2FydGVzaWFuIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGVzIGFsb25nIHdoaWNoIHRvIG1lYXN1cmUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUludmlzaWJsZV0gLSBpbmNsdWRlIGludmlzaWJsZSBwb2ludHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgY2hhcnQgYXJlYVxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBsZXQgaXRlbXMgPSBbXTtcbiAgY29uc3QgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcyk7XG4gIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3QgaW5SYW5nZSA9IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBpZiAoaW50ZXJzZWN0ICYmICFpblJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBwb2ludEluQXJlYSA9ICEhaW5jbHVkZUludmlzaWJsZSB8fCBjaGFydC5pc1BvaW50SW5BcmVhKGNlbnRlcik7XG4gICAgaWYgKCFwb2ludEluQXJlYSAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRpc3RhbmNlID0gZGlzdGFuY2VNZXRyaWMocG9zaXRpb24sIGNlbnRlcik7XG4gICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgIGl0ZW1zID0gW3tlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fV07XG4gICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICAvLyBDYW4gaGF2ZSBtdWx0aXBsZSBpdGVtcyBhdCB0aGUgc2FtZSBkaXN0YW5jZSBpbiB3aGljaCBjYXNlIHdlIHNvcnQgYnkgc2l6ZVxuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGNvbnNpZGVyaW5nIGFsbCB2aXNpYmxlIGl0ZW1zIGluIHRoZSBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhlcyBhbG9uZyB3aGljaCB0byBtZWFzdXJlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZpc2libGVdIC0gaW5jbHVkZSBpbnZpc2libGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNoYXJ0IGFyZWFcbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBheGlzID09PSAncicgJiYgIWludGVyc2VjdFxuICAgID8gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbilcbiAgICA6IGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbWF0Y2hpbmcgYWxvbmcgdGhlIGdpdmVuIFggb3IgWSBheGlzXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIHRvIG1hdGNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgcmFuZ2VNZXRob2QgPSBheGlzID09PSAneCcgPyAnaW5YUmFuZ2UnIDogJ2luWVJhbmdlJztcbiAgbGV0IGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpID0+IHtcbiAgICBpZiAoZWxlbWVudFtyYW5nZU1ldGhvZF0ocG9zaXRpb25bYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgICBpbnRlcnNlY3RzSXRlbSA9IGludGVyc2VjdHNJdGVtIHx8IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIElmIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBhbiBpbnRlcnNlY3QgYW5kIHdlIGRvbid0IGhhdmUgYW55IGl0ZW1zXG4gIC8vIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvbiwgcmV0dXJuIG5vdGhpbmdcbiAgaWYgKGludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIENvbnRhaW5zIGludGVyYWN0aW9uIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkludGVyYWN0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLy8gUGFydCBvZiB0aGUgcHVibGljIEFQSSB0byBmYWNpbGl0YXRlIGRldmVsb3BlcnMgY3JlYXRpbmcgdGhlaXIgb3duIG1vZGVzXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyxcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGRpZmZlcmVudCBtb2Rlc1xuICBtb2Rlczoge1xuICAgIC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXguIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBtb2RlIGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXggYXMgdGhhdCBpdGVtXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmluZGV4XG5cdFx0ICogQHNpbmNlIHYyLjQuMFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBpbmRleChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIC8vIERlZmF1bHQgYXhpcyBmb3IgaW5kZXggbW9kZSBpcyAneCcgdG8gbWF0Y2ggb2xkIGJlaGF2aW91clxuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgY29uc3QgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSlcbiAgICAgICAgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5mb3JFYWNoKChtZXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaXRlbXNbMF0uaW5kZXg7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBtZXRhLmRhdGFbaW5kZXhdO1xuXG4gICAgICAgIC8vIGRvbid0IGNvdW50IGl0ZW1zIHRoYXQgYXJlIHNraXBwZWQgKG51bGwgZGF0YSlcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleCwgaW5kZXh9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogUmV0dXJucyBpdGVtcyBpbiB0aGUgc2FtZSBkYXRhc2V0LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBpbiB0aGF0IGRhdGFzZXRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBkYXRhc2V0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGxldCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSA6XG4gICAgICAgIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZGF0YXNldEluZGV4ID0gaXRlbXNbMF0uZGF0YXNldEluZGV4O1xuICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5kYXRhO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKHtlbGVtZW50OiBkYXRhW2ldLCBkYXRhc2V0SW5kZXgsIGluZGV4OiBpfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiBQb2ludCBtb2RlIHJldHVybnMgYWxsIGVsZW1lbnRzIHRoYXQgaGl0IHRlc3QgYmFzZWQgb24gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdFx0ICogb2YgdGhlIGV2ZW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBwb2ludChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogbmVhcmVzdCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnQgY2xvc2VzdCB0byB0aGUgcG9pbnRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIG5lYXJlc3QoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogeCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeCBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnhcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgeChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneCcsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogeSBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeSBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnlcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgeShjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneScsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbn07XG4iLCAiaW1wb3J0IHtkZWZpbmVkLCBlYWNoLCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b1BhZGRpbmd9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5jb25zdCBTVEFUSUNfUE9TSVRJT05TID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcblxuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucG9zID09PSBwb3NpdGlvbik7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhhcnJheSwgYXhpcykge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gU1RBVElDX1BPU0lUSU9OUy5pbmRleE9mKHYucG9zKSA9PT0gLTEgJiYgdi5ib3guYXhpcyA9PT0gYXhpcyk7XG59XG5cbmZ1bmN0aW9uIHNvcnRCeVdlaWdodChhcnJheSwgcmV2ZXJzZSkge1xuICByZXR1cm4gYXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHYwID0gcmV2ZXJzZSA/IGIgOiBhO1xuICAgIGNvbnN0IHYxID0gcmV2ZXJzZSA/IGEgOiBiO1xuICAgIHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XG4gICAgICB2MC5pbmRleCAtIHYxLmluZGV4IDpcbiAgICAgIHYwLndlaWdodCAtIHYxLndlaWdodDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgYm94LCBwb3MsIHN0YWNrLCBzdGFja1dlaWdodDtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gKGJveGVzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBib3ggPSBib3hlc1tpXTtcbiAgICAoe3Bvc2l0aW9uOiBwb3MsIG9wdGlvbnM6IHtzdGFjaywgc3RhY2tXZWlnaHQgPSAxfX0gPSBib3gpO1xuICAgIGxheW91dEJveGVzLnB1c2goe1xuICAgICAgaW5kZXg6IGksXG4gICAgICBib3gsXG4gICAgICBwb3MsXG4gICAgICBob3Jpem9udGFsOiBib3guaXNIb3Jpem9udGFsKCksXG4gICAgICB3ZWlnaHQ6IGJveC53ZWlnaHQsXG4gICAgICBzdGFjazogc3RhY2sgJiYgKHBvcyArIHN0YWNrKSxcbiAgICAgIHN0YWNrV2VpZ2h0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxheW91dEJveGVzO1xufVxuXG5mdW5jdGlvbiBidWlsZFN0YWNrcyhsYXlvdXRzKSB7XG4gIGNvbnN0IHN0YWNrcyA9IHt9O1xuICBmb3IgKGNvbnN0IHdyYXAgb2YgbGF5b3V0cykge1xuICAgIGNvbnN0IHtzdGFjaywgcG9zLCBzdGFja1dlaWdodH0gPSB3cmFwO1xuICAgIGlmICghc3RhY2sgfHwgIVNUQVRJQ19QT1NJVElPTlMuaW5jbHVkZXMocG9zKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IF9zdGFjayA9IHN0YWNrc1tzdGFja10gfHwgKHN0YWNrc1tzdGFja10gPSB7Y291bnQ6IDAsIHBsYWNlZDogMCwgd2VpZ2h0OiAwLCBzaXplOiAwfSk7XG4gICAgX3N0YWNrLmNvdW50Kys7XG4gICAgX3N0YWNrLndlaWdodCArPSBzdGFja1dlaWdodDtcbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuXG4vKipcbiAqIHN0b3JlIGRpbWVuc2lvbnMgdXNlZCBpbnN0ZWFkIG9mIGF2YWlsYWJsZSBjaGFydEFyZWEgaW4gZml0Qm94ZXNcbiAqKi9cbmZ1bmN0aW9uIHNldExheW91dERpbXMobGF5b3V0cywgcGFyYW1zKSB7XG4gIGNvbnN0IHN0YWNrcyA9IGJ1aWxkU3RhY2tzKGxheW91dHMpO1xuICBjb25zdCB7dkJveE1heFdpZHRoLCBoQm94TWF4SGVpZ2h0fSA9IHBhcmFtcztcbiAgbGV0IGksIGlsZW4sIGxheW91dDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGxheW91dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gbGF5b3V0c1tpXTtcbiAgICBjb25zdCB7ZnVsbFNpemV9ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdO1xuICAgIGNvbnN0IGZhY3RvciA9IHN0YWNrICYmIGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodDtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGxheW91dC53aWR0aCA9IGZhY3RvciA/IGZhY3RvciAqIHZCb3hNYXhXaWR0aCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBoQm94TWF4SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXlvdXQud2lkdGggPSB2Qm94TWF4V2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gZmFjdG9yID8gZmFjdG9yICogaEJveE1heEhlaWdodCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVIZWlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0Qm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSB3cmFwQm94ZXMoYm94ZXMpO1xuICBjb25zdCBmdWxsU2l6ZSA9IHNvcnRCeVdlaWdodChsYXlvdXRCb3hlcy5maWx0ZXIod3JhcCA9PiB3cmFwLmJveC5mdWxsU2l6ZSksIHRydWUpO1xuICBjb25zdCBsZWZ0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdsZWZ0JyksIHRydWUpO1xuICBjb25zdCByaWdodCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAncmlnaHQnKSk7XG4gIGNvbnN0IHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xuICBjb25zdCBib3R0b20gPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2JvdHRvbScpKTtcbiAgY29uc3QgY2VudGVySG9yaXpvbnRhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3gnKTtcbiAgY29uc3QgY2VudGVyVmVydGljYWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd5Jyk7XG5cbiAgcmV0dXJuIHtcbiAgICBmdWxsU2l6ZSxcbiAgICBsZWZ0QW5kVG9wOiBsZWZ0LmNvbmNhdCh0b3ApLFxuICAgIHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoY2VudGVyVmVydGljYWwpLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKSxcbiAgICBjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcbiAgICB2ZXJ0aWNhbDogbGVmdC5jb25jYXQocmlnaHQpLmNvbmNhdChjZW50ZXJWZXJ0aWNhbCksXG4gICAgaG9yaXpvbnRhbDogdG9wLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsIGEsIGIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1heFBhZGRpbmdbYV0sIGNoYXJ0QXJlYVthXSkgKyBNYXRoLm1heChtYXhQYWRkaW5nW2JdLCBjaGFydEFyZWFbYl0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveFBhZGRpbmcpIHtcbiAgbWF4UGFkZGluZy50b3AgPSBNYXRoLm1heChtYXhQYWRkaW5nLnRvcCwgYm94UGFkZGluZy50b3ApO1xuICBtYXhQYWRkaW5nLmxlZnQgPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQsIGJveFBhZGRpbmcubGVmdCk7XG4gIG1heFBhZGRpbmcuYm90dG9tID0gTWF0aC5tYXgobWF4UGFkZGluZy5ib3R0b20sIGJveFBhZGRpbmcuYm90dG9tKTtcbiAgbWF4UGFkZGluZy5yaWdodCA9IE1hdGgubWF4KG1heFBhZGRpbmcucmlnaHQsIGJveFBhZGRpbmcucmlnaHQpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcykge1xuICBjb25zdCB7cG9zLCBib3h9ID0gbGF5b3V0O1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cbiAgLy8gZHluYW1pY2FsbHkgcGxhY2VkIGJveGVzIHNpemUgaXMgbm90IGNvbnNpZGVyZWRcbiAgaWYgKCFpc09iamVjdChwb3MpKSB7XG4gICAgaWYgKGxheW91dC5zaXplKSB7XG4gICAgICAvLyB0aGlzIGxheW91dCB3YXMgYWxyZWFkeSBjb3VudGVkIGZvciwgbGV0cyBmaXJzdCByZWR1Y2Ugb2xkIHNpemVcbiAgICAgIGNoYXJ0QXJlYVtwb3NdIC09IGxheW91dC5zaXplO1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtzaXplOiAwLCBjb3VudDogMX07XG4gICAgc3RhY2suc2l6ZSA9IE1hdGgubWF4KHN0YWNrLnNpemUsIGxheW91dC5ob3Jpem9udGFsID8gYm94LmhlaWdodCA6IGJveC53aWR0aCk7XG4gICAgbGF5b3V0LnNpemUgPSBzdGFjay5zaXplIC8gc3RhY2suY291bnQ7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gbGF5b3V0LnNpemU7XG4gIH1cblxuICBpZiAoYm94LmdldFBhZGRpbmcpIHtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveC5nZXRQYWRkaW5nKCkpO1xuICB9XG5cbiAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJXaWR0aCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ2xlZnQnLCAncmlnaHQnKSk7XG4gIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlckhlaWdodCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ3RvcCcsICdib3R0b20nKSk7XG4gIGNvbnN0IHdpZHRoQ2hhbmdlZCA9IG5ld1dpZHRoICE9PSBjaGFydEFyZWEudztcbiAgY29uc3QgaGVpZ2h0Q2hhbmdlZCA9IG5ld0hlaWdodCAhPT0gY2hhcnRBcmVhLmg7XG4gIGNoYXJ0QXJlYS53ID0gbmV3V2lkdGg7XG4gIGNoYXJ0QXJlYS5oID0gbmV3SGVpZ2h0O1xuXG4gIC8vIHJldHVybiBib29sZWFucyBvbiB0aGUgY2hhbmdlcyBwZXIgZGlyZWN0aW9uXG4gIHJldHVybiBsYXlvdXQuaG9yaXpvbnRhbFxuICAgID8ge3NhbWU6IHdpZHRoQ2hhbmdlZCwgb3RoZXI6IGhlaWdodENoYW5nZWR9XG4gICAgOiB7c2FtZTogaGVpZ2h0Q2hhbmdlZCwgb3RoZXI6IHdpZHRoQ2hhbmdlZH07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICBmdW5jdGlvbiB1cGRhdGVQb3MocG9zKSB7XG4gICAgY29uc3QgY2hhbmdlID0gTWF0aC5tYXgobWF4UGFkZGluZ1twb3NdIC0gY2hhcnRBcmVhW3Bvc10sIDApO1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGNoYW5nZTtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG4gIGNoYXJ0QXJlYS55ICs9IHVwZGF0ZVBvcygndG9wJyk7XG4gIGNoYXJ0QXJlYS54ICs9IHVwZGF0ZVBvcygnbGVmdCcpO1xuICB1cGRhdGVQb3MoJ3JpZ2h0Jyk7XG4gIHVwZGF0ZVBvcygnYm90dG9tJyk7XG59XG5cbmZ1bmN0aW9uIGdldE1hcmdpbnMoaG9yaXpvbnRhbCwgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICBmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgY29uc3QgbWFyZ2luID0ge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH07XG4gICAgcG9zaXRpb25zLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgbWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFyZ2luO1xuICB9XG5cbiAgcmV0dXJuIGhvcml6b250YWxcbiAgICA/IG1hcmdpbkZvclBvc2l0aW9ucyhbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICA6IG1hcmdpbkZvclBvc2l0aW9ucyhbJ3RvcCcsICdib3R0b20nXSk7XG59XG5cbmZ1bmN0aW9uIGZpdEJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHJlZml0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGxheW91dCwgYm94LCByZWZpdCwgY2hhbmdlZDtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoLCByZWZpdCA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBib3hlc1tpXTtcbiAgICBib3ggPSBsYXlvdXQuYm94O1xuXG4gICAgYm94LnVwZGF0ZShcbiAgICAgIGxheW91dC53aWR0aCB8fCBjaGFydEFyZWEudyxcbiAgICAgIGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsXG4gICAgICBnZXRNYXJnaW5zKGxheW91dC5ob3Jpem9udGFsLCBjaGFydEFyZWEpXG4gICAgKTtcbiAgICBjb25zdCB7c2FtZSwgb3RoZXJ9ID0gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpO1xuXG4gICAgLy8gRGltZW5zaW9ucyBjaGFuZ2VkIGFuZCB0aGVyZSB3ZXJlIG5vbiBmdWxsIHdpZHRoIGJveGVzIGJlZm9yZSB0aGlzXG4gICAgLy8gLT4gd2UgaGF2ZSB0byByZWZpdCB0aG9zZVxuICAgIHJlZml0IHw9IHNhbWUgJiYgcmVmaXRCb3hlcy5sZW5ndGg7XG5cbiAgICAvLyBDaGFydCBhcmVhIGNoYW5nZWQgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG90aGVyO1xuXG4gICAgaWYgKCFib3guZnVsbFNpemUpIHsgLy8gZnVsbFNpemUgYm94ZXMgZG9uJ3QgbmVlZCB0byBiZSByZS1maXR0ZWQgaW4gYW55IGNhc2VcbiAgICAgIHJlZml0Qm94ZXMucHVzaChsYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWZpdCAmJiBmaXRCb3hlcyhyZWZpdEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB8fCBjaGFuZ2VkO1xufVxuXG5mdW5jdGlvbiBzZXRCb3hEaW1zKGJveCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGJveC50b3AgPSB0b3A7XG4gIGJveC5sZWZ0ID0gbGVmdDtcbiAgYm94LnJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBib3guYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBib3gud2lkdGggPSB3aWR0aDtcbiAgYm94LmhlaWdodCA9IGhlaWdodDtcbn1cblxuZnVuY3Rpb24gcGxhY2VCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCB1c2VyUGFkZGluZyA9IHBhcmFtcy5wYWRkaW5nO1xuICBsZXQge3gsIHl9ID0gY2hhcnRBcmVhO1xuXG4gIGZvciAoY29uc3QgbGF5b3V0IG9mIGJveGVzKSB7XG4gICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtjb3VudDogMSwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDF9O1xuICAgIGNvbnN0IHdlaWdodCA9IChsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQpIHx8IDE7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGNoYXJ0QXJlYS53ICogd2VpZ2h0O1xuICAgICAgY29uc3QgaGVpZ2h0ID0gc3RhY2suc2l6ZSB8fCBib3guaGVpZ2h0O1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHkgPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHVzZXJQYWRkaW5nLmxlZnQsIHksIHBhcmFtcy5vdXRlcldpZHRoIC0gdXNlclBhZGRpbmcucmlnaHQgLSB1c2VyUGFkZGluZy5sZWZ0LCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIGNoYXJ0QXJlYS5sZWZ0ICsgc3RhY2sucGxhY2VkLCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geTtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSB3aWR0aDtcbiAgICAgIHkgPSBib3guYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBjaGFydEFyZWEuaCAqIHdlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gc3RhY2suc2l6ZSB8fCBib3gud2lkdGg7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeCA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgdXNlclBhZGRpbmcudG9wLCB3aWR0aCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gdXNlclBhZGRpbmcuYm90dG9tIC0gdXNlclBhZGRpbmcudG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCBjaGFydEFyZWEudG9wICsgc3RhY2sucGxhY2VkLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geDtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSBoZWlnaHQ7XG4gICAgICB4ID0gYm94LnJpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIGNoYXJ0QXJlYS54ID0geDtcbiAgY2hhcnRBcmVhLnkgPSB5O1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgTGF5b3V0SXRlbVxuICogQHR5cGVkZWYge29iamVjdH0gTGF5b3V0SXRlbVxuICogQHByb3Age3N0cmluZ30gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gaW4gdGhlIGNoYXJ0IGxheW91dC4gUG9zc2libGUgdmFsdWVzIGFyZVxuICogJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsIGFuZCAnY2hhcnRBcmVhJ1xuICogQHByb3Age251bWJlcn0gd2VpZ2h0IC0gVGhlIHdlaWdodCB1c2VkIHRvIHNvcnQgdGhlIGl0ZW0uIEhpZ2hlciB3ZWlnaHRzIGFyZSBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgY2hhcnQgYXJlYVxuICogQHByb3Age2Jvb2xlYW59IGZ1bGxTaXplIC0gaWYgdHJ1ZSwgYW5kIHRoZSBpdGVtIGlzIGhvcml6b250YWwsIHRoZW4gcHVzaCB2ZXJ0aWNhbCBib3hlcyBkb3duXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGlzSG9yaXpvbnRhbCAtIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGl0ZW0gaXMgaG9yaXpvbnRhbCAoaWUuIHRvcCBvciBib3R0b20pXG4gKiBAcHJvcCB7ZnVuY3Rpb259IHVwZGF0ZSAtIFRha2VzIHR3byBwYXJhbWV0ZXJzOiB3aWR0aCBhbmQgaGVpZ2h0LiBSZXR1cm5zIHNpemUgb2YgaXRlbVxuICogQHByb3Age2Z1bmN0aW9ufSBkcmF3IC0gRHJhd3MgdGhlIGVsZW1lbnRcbiAqIEBwcm9wIHtmdW5jdGlvbn0gW2dldFBhZGRpbmddIC0gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFkZGluZyBvbiB0aGUgZWRnZXNcbiAqIEBwcm9wIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGxlZnQgLSBMZWZ0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHRvcCAtIFRvcCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSByaWdodCAtIFJpZ2h0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IGJvdHRvbSAtIEJvdHRvbSBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKi9cblxuLy8gVGhlIGxheW91dCBzZXJ2aWNlIGlzIHZlcnkgc2VsZiBleHBsYW5hdG9yeS4gIEl0J3MgcmVzcG9uc2libGUgZm9yIHRoZSBsYXlvdXQgd2l0aGluIGEgY2hhcnQuXG4vLyBTY2FsZXMsIExlZ2VuZHMgYW5kIFBsdWdpbnMgYWxsIHJlbHkgb24gdGhlIGxheW91dCBzZXJ2aWNlIGFuZCBjYW4gZWFzaWx5IHJlZ2lzdGVyIHRvIGJlIHBsYWNlZCBhbnl3aGVyZSB0aGV5IG5lZWRcbi8vIEl0IGlzIHRoaXMgc2VydmljZSdzIHJlc3BvbnNpYmlsaXR5IG9mIGNhcnJ5aW5nIG91dCB0aGF0IGxheW91dC5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAvKipcblx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cblx0ICogQSBib3ggaXMgc2ltcGx5IGEgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCB0aGF0IHJlcXVpcmVzIGxheW91dC4gZWcuIFNjYWxlcywgTGVnZW5kLCBUaXRsZS5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gdXNlXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGFkZCB0byBiZSBsYWlkIG91dFxuXHQgKi9cbiAgYWRkQm94KGNoYXJ0LCBpdGVtKSB7XG4gICAgaWYgKCFjaGFydC5ib3hlcykge1xuICAgICAgY2hhcnQuYm94ZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIGl0ZW0gd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgIGl0ZW0uZnVsbFNpemUgPSBpdGVtLmZ1bGxTaXplIHx8IGZhbHNlO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuICAgIGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaXRlbS5fbGF5ZXJzID0gaXRlbS5fbGF5ZXJzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IDAsXG4gICAgICAgIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgICAgICAgaXRlbS5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH07XG5cbiAgICBjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuICB9LFxuXG4gIC8qKlxuXHQgKiBSZW1vdmUgYSBsYXlvdXRJdGVtIGZyb20gYSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byByZW1vdmUgdGhlIGJveCBmcm9tXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gbGF5b3V0SXRlbSAtIHRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsYXlvdXRcblx0ICovXG4gIHJlbW92ZUJveChjaGFydCwgbGF5b3V0SXRlbSkge1xuICAgIGNvbnN0IGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG5cdCAqIFNldHMgKG9yIHVwZGF0ZXMpIG9wdGlvbnMgb24gdGhlIGdpdmVuIGBpdGVtYC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgaW4gd2hpY2ggdGhlIGl0ZW0gbGl2ZXMgKG9yIHdpbGwgYmUgYWRkZWQgdG8pXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGNvbmZpZ3VyZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gdGhlIG5ldyBpdGVtIG9wdGlvbnMuXG5cdCAqL1xuICBjb25maWd1cmUoY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICBpdGVtLmZ1bGxTaXplID0gb3B0aW9ucy5mdWxsU2l6ZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpdGVtLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICB9LFxuXG4gIC8qKlxuXHQgKiBGaXRzIGJveGVzIG9mIHRoZSBnaXZlbiBjaGFydCBpbnRvIHRoZSBnaXZlbiBzaXplIGJ5IGhhdmluZyBlYWNoIGJveCBtZWFzdXJlIGl0c2VsZlxuXHQgKiB0aGVuIHJ1bm5pbmcgYSBmaXR0aW5nIGFsZ29yaXRobVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggdG8gZml0IGludG9cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgdG8gZml0IGludG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblBhZGRpbmcgLSBtaW5pbXVtIHBhZGRpbmcgcmVxdWlyZWQgZm9yIGVhY2ggc2lkZSBvZiBjaGFydCBhcmVhXG5cdCAqL1xuICB1cGRhdGUoY2hhcnQsIHdpZHRoLCBoZWlnaHQsIG1pblBhZGRpbmcpIHtcbiAgICBpZiAoIWNoYXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhjaGFydC5vcHRpb25zLmxheW91dC5wYWRkaW5nKTtcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gcGFkZGluZy53aWR0aCwgMCk7XG4gICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQsIDApO1xuICAgIGNvbnN0IGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XG4gICAgY29uc3QgdmVydGljYWxCb3hlcyA9IGJveGVzLnZlcnRpY2FsO1xuICAgIGNvbnN0IGhvcml6b250YWxCb3hlcyA9IGJveGVzLmhvcml6b250YWw7XG5cbiAgICAvLyBCZWZvcmUgYW55IGNoYW5nZXMgYXJlIG1hZGUsIG5vdGlmeSBib3hlcyB0aGF0IGFuIHVwZGF0ZSBpcyBhYm91dCB0byBiZWluZ1xuICAgIC8vIFRoaXMgaXMgdXNlZCB0byBjbGVhciBhbnkgY2FjaGVkIGRhdGEgKGUuZy4gc2NhbGUgbGltaXRzKVxuICAgIGVhY2goY2hhcnQuYm94ZXMsIGJveCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJveC5iZWZvcmVMYXlvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYm94LmJlZm9yZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRXNzZW50aWFsbHkgd2Ugbm93IGhhdmUgYW55IG51bWJlciBvZiBib3hlcyBvbiBlYWNoIG9mIHRoZSA0IHNpZGVzLlxuICAgIC8vIE91ciBjYW52YXMgbG9va3MgbGlrZSB0aGUgZm9sbG93aW5nLlxuICAgIC8vIFRoZSBhcmVhcyBMMSBhbmQgTDIgYXJlIHRoZSBsZWZ0IGF4ZXMuIFIxIGlzIHRoZSByaWdodCBheGlzLCBUMSBpcyB0aGUgdG9wIGF4aXMgYW5kXG4gICAgLy8gQjEgaXMgdGhlIGJvdHRvbSBheGlzXG4gICAgLy8gVGhlcmUgYXJlIGFsc28gNCBxdWFkcmFudC1saWtlIGxvY2F0aW9ucyAobGVmdCB0byByaWdodCBpbnN0ZWFkIG9mIGNsb2Nrd2lzZSkgcmVzZXJ2ZWQgZm9yIGNoYXJ0IG92ZXJsYXlzXG4gICAgLy8gVGhlc2UgbG9jYXRpb25zIGFyZSBzaW5nbGUtYm94IGxvY2F0aW9ucyBvbmx5LCB3aGVuIHRyeWluZyB0byByZWdpc3RlciBhIGNoYXJ0QXJlYSBsb2NhdGlvbiB0aGF0IGlzIGFscmVhZHkgdGFrZW4sXG4gICAgLy8gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgLy9cbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgVDEgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgVDIgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCBDMSB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDMiB8ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8IEwxIHwgTDIgfCAgICAgICAgICAgQ2hhcnRBcmVhIChDMCkgICAgICAgICAgICB8IFIxIHxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfCBDMyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDNCB8ICAgIHxcbiAgICAvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgQjEgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgQjIgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvL1xuXG4gICAgY29uc3QgdmlzaWJsZVZlcnRpY2FsQm94Q291bnQgPSB2ZXJ0aWNhbEJveGVzLnJlZHVjZSgodG90YWwsIHdyYXApID0+XG4gICAgICB3cmFwLmJveC5vcHRpb25zICYmIHdyYXAuYm94Lm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2UgPyB0b3RhbCA6IHRvdGFsICsgMSwgMCkgfHwgMTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgb3V0ZXJXaWR0aDogd2lkdGgsXG4gICAgICBvdXRlckhlaWdodDogaGVpZ2h0LFxuICAgICAgcGFkZGluZyxcbiAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgdkJveE1heFdpZHRoOiBhdmFpbGFibGVXaWR0aCAvIDIgLyB2aXNpYmxlVmVydGljYWxCb3hDb3VudCxcbiAgICAgIGhCb3hNYXhIZWlnaHQ6IGF2YWlsYWJsZUhlaWdodCAvIDJcbiAgICB9KTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgcGFkZGluZyk7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCB0b1BhZGRpbmcobWluUGFkZGluZykpO1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbWF4UGFkZGluZyxcbiAgICAgIHc6IGF2YWlsYWJsZVdpZHRoLFxuICAgICAgaDogYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgeDogcGFkZGluZy5sZWZ0LFxuICAgICAgeTogcGFkZGluZy50b3BcbiAgICB9LCBwYWRkaW5nKTtcblxuICAgIGNvbnN0IHN0YWNrcyA9IHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcblxuICAgIC8vIEZpcnN0IGZpdCB0aGUgZnVsbFNpemUgYm94ZXMsIHRvIHJlZHVjZSBwcm9iYWJpbGl0eSBvZiByZS1maXR0aW5nLlxuICAgIGZpdEJveGVzKGJveGVzLmZ1bGxTaXplLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcblxuICAgIC8vIFRoZW4gZml0IHZlcnRpY2FsIGJveGVzXG4gICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBUaGVuIGZpdCBob3Jpem9udGFsIGJveGVzXG4gICAgaWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykpIHtcbiAgICAgIC8vIGlmIHRoZSBhcmVhIGNoYW5nZWQsIHJlLWZpdCB2ZXJ0aWNhbCBib3hlc1xuICAgICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgfVxuXG4gICAgaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpO1xuXG4gICAgLy8gRmluYWxseSBwbGFjZSB0aGUgYm94ZXMgdG8gY29ycmVjdCBjb29yZGluYXRlc1xuICAgIHBsYWNlQm94ZXMoYm94ZXMubGVmdEFuZFRvcCwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBNb3ZlIHRvIG9wcG9zaXRlIHNpZGUgb2YgY2hhcnRcbiAgICBjaGFydEFyZWEueCArPSBjaGFydEFyZWEudztcbiAgICBjaGFydEFyZWEueSArPSBjaGFydEFyZWEuaDtcblxuICAgIHBsYWNlQm94ZXMoYm94ZXMucmlnaHRBbmRCb3R0b20sIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgY2hhcnQuY2hhcnRBcmVhID0ge1xuICAgICAgbGVmdDogY2hhcnRBcmVhLmxlZnQsXG4gICAgICB0b3A6IGNoYXJ0QXJlYS50b3AsXG4gICAgICByaWdodDogY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEudyxcbiAgICAgIGJvdHRvbTogY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5oLFxuICAgICAgaGVpZ2h0OiBjaGFydEFyZWEuaCxcbiAgICAgIHdpZHRoOiBjaGFydEFyZWEudyxcbiAgICB9O1xuXG4gICAgLy8gRmluYWxseSB1cGRhdGUgYm94ZXMgaW4gY2hhcnRBcmVhIChyYWRpYWwgc2NhbGUgZm9yIGV4YW1wbGUpXG4gICAgZWFjaChib3hlcy5jaGFydEFyZWEsIChsYXlvdXQpID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgICBPYmplY3QuYXNzaWduKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIGJveC51cGRhdGUoY2hhcnRBcmVhLncsIGNoYXJ0QXJlYS5oLCB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfSk7XG4gICAgfSk7XG4gIH1cbn07XG4iLCAiXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdGhhdCBhbGxvd3MgYWJzdHJhY3RpbmcgcGxhdGZvcm0gZGVwZW5kZW5jaWVzIGF3YXkgZnJvbSB0aGUgY2hhcnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VQbGF0Zm9ybSB7XG4gIC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgY29uc3RydWN0aW9uIHRpbWUsIHJldHVybnMgYSBjb250ZXh0MmQgaW5zdGFuY2UgaW1wbGVtZW50aW5nXG5cdCAqIHRoZSBbVzNDIENhbnZhcyAyRCBDb250ZXh0IEFQSSBzdGFuZGFyZF17QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC99LlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIGZyb20gd2hpY2ggdG8gYWNxdWlyZSBjb250ZXh0IChwbGF0Zm9ybSBzcGVjaWZpYylcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb10gLSBUaGUgY2hhcnQgb3B0aW9uc1xuXHQgKi9cbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgZGVzdHJ1Y3Rpb24gdGltZSwgcmVsZWFzZXMgYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHRvIHRoZSBjb250ZXh0XG5cdCAqIHByZXZpb3VzbHkgcmV0dXJuZWQgYnkgdGhlIGFjcXVpcmVDb250ZXh0KCkgbWV0aG9kLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjb250ZXh0MmQgaW5zdGFuY2Vcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1ldGhvZCBzdWNjZWVkZWQsIGVsc2UgZmFsc2Vcblx0ICovXG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZWdpc3RlcnMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBvbiB0aGUgZ2l2ZW4gY2hhcnQuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gQ2hhcnQgZnJvbSB3aGljaCB0byBsaXN0ZW4gZm9yIGV2ZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgQ2hhcnRFdmVudH0pIHR5cGUgdG8gbGlzdGVuIGZvclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIChhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzXG5cdCAqIHRoZSB7QGxpbmsgQ2hhcnRFdmVudH0gaW50ZXJmYWNlKSB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnMuXG5cdCAqL1xuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBDaGFydCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBDaGFydEV2ZW50fSkgdHlwZSB0byByZW1vdmVcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50IHRhcmdldC5cblx0ICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjdXJyZW50IGRldmljZVBpeGVsUmF0aW8gb2YgdGhlIGRldmljZSB0aGlzIHBsYXRmb3JtIGlzIGNvbm5lY3RlZCB0by5cblx0ICovXG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbWF4aW11bSBzaXplIGluIHBpeGVscyBvZiBnaXZlbiBjYW52YXMgZWxlbWVudC5cblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSAtIGNvbnRlbnQgd2lkdGggb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIC0gY29udGVudCBoZWlnaHQgb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb10gLSBhc3BlY3QgcmF0aW8gdG8gbWFpbnRhaW5cblx0ICovXG4gIGdldE1heGltdW1TaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCB8fCBlbGVtZW50LndpZHRoKTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IE1hdGguZmxvb3Iod2lkdGggLyBhc3BlY3RSYXRpbykgOiBoZWlnaHQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNhbnZhcyBpcyBhdHRhY2hlZCB0byB0aGUgcGxhdGZvcm0sIGZhbHNlIGlmIG5vdC5cblx0ICovXG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbmZpZyB3aXRoIHBsYXRmb3JtIHNwZWNpZmljIHJlcXVpcmVtZW50c1xuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29yZS9jb3JlLmNvbmZpZy5qcycpLmRlZmF1bHR9IGNvbmZpZ1xuICAgKi9cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgLy8gbm8tb3BcbiAgfVxufVxuIiwgIi8qKlxuICogUGxhdGZvcm0gZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gKG1pbmltYWwpLlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1OTEjaXNzdWVjb21tZW50LTMxOTU3NTkzOVxuICovXG5cbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcblxuLyoqXG4gKiBQbGF0Zm9ybSBjbGFzcyBmb3IgY2hhcnRzIHdpdGhvdXQgYWNjZXNzIHRvIHRoZSBET00gb3IgdG8gbWFueSBlbGVtZW50IHByb3BlcnRpZXNcbiAqIFRoaXMgcGxhdGZvcm0gaXMgdXNlZCBieSBkZWZhdWx0IGZvciBhbnkgY2hhcnQgcGFzc2VkIGFuIE9mZnNjcmVlbkNhbnZhcy5cbiAqIEBleHRlbmRzIEJhc2VQbGF0Zm9ybVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY1BsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoaXRlbSkge1xuICAgIC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcbiAgICAvLyBtZXRob2QsIGZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va2thcHNuZXIvQ2FudmFzQmxvY2tlclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG4gICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKSB8fCBudWxsO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcub3B0aW9ucy5hbmltYXRpb24gPSBmYWxzZTtcbiAgfVxufVxuIiwgIi8qKlxuICogQ2hhcnQuUGxhdGZvcm0gaW1wbGVtZW50YXRpb24gZm9yIHRhcmdldGluZyBhIHdlYiBicm93c2VyXG4gKi9cblxuaW1wb3J0IEJhc2VQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2UuanMnO1xuaW1wb3J0IHtfZ2V0UGFyZW50Tm9kZSwgZ2V0UmVsYXRpdmVQb3NpdGlvbiwgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucywgcmVhZFVzZWRTaXplLCBnZXRNYXhpbXVtU2l6ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge3Rocm90dGxlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5jb25zdCBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG5cbi8qKlxuICogRE9NIGV2ZW50IHR5cGVzIC0+IENoYXJ0LmpzIGV2ZW50IHR5cGVzLlxuICogTm90ZTogb25seSBldmVudHMgd2l0aCBkaWZmZXJlbnQgdHlwZXMgYXJlIG1hcHBlZC5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzXG4gKi9cbmNvbnN0IEVWRU5UX1RZUEVTID0ge1xuICB0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcbiAgdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG91Y2hlbmQ6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG4gIHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcbiAgcG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuICBwb2ludGVydXA6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuICBwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuXG5jb25zdCBpc051bGxPckVtcHR5ID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnO1xuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIHN0eWxlIGFuZCByZW5kZXIgc2l6ZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgY2FudmFzIGRpc3BsYXkgc2l6ZSxcbiAqIHNpbmNlIHJlc3BvbnNpdmVuZXNzIGlzIGhhbmRsZWQgYnkgdGhlIGNvbnRyb2xsZXIucmVzaXplKCkgbWV0aG9kLiBUaGUgY29uZmlnIGlzIHVzZWRcbiAqIHRvIGRldGVybWluZSB0aGUgYXNwZWN0IHJhdGlvIHRvIGFwcGx5IGluIGNhc2Ugbm8gZXhwbGljaXQgaGVpZ2h0IGhhcyBiZWVuIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb11cbiAqL1xuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gY2FudmFzLnN0eWxlO1xuXG4gIC8vIE5PVEUoU0IpIGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgIT09IGNhbnZhcy53aWR0aDogaW4gdGhlIGZpcnN0IGNhc2UgaXRcbiAgLy8gcmV0dXJucyBudWxsIG9yICcnIGlmIG5vIGV4cGxpY2l0IHZhbHVlIGhhcyBiZWVuIHNldCB0byB0aGUgY2FudmFzIGF0dHJpYnV0ZS5cbiAgY29uc3QgcmVuZGVySGVpZ2h0ID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gIGNvbnN0IHJlbmRlcldpZHRoID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcblxuICAvLyBDaGFydC5qcyBtb2RpZmllcyBzb21lIGNhbnZhcyB2YWx1ZXMgdGhhdCB3ZSB3YW50IHRvIHJlc3RvcmUgb24gZGVzdHJveVxuICBjYW52YXNbRVhQQU5ET19LRVldID0ge1xuICAgIGluaXRpYWw6IHtcbiAgICAgIGhlaWdodDogcmVuZGVySGVpZ2h0LFxuICAgICAgd2lkdGg6IHJlbmRlcldpZHRoLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogc3R5bGUuZGlzcGxheSxcbiAgICAgICAgaGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBzdHlsZS53aWR0aFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBGb3JjZSBjYW52YXMgdG8gZGlzcGxheSBhcyBibG9jayB0byBhdm9pZCBleHRyYSBzcGFjZSBjYXVzZWQgYnkgaW5saW5lXG4gIC8vIGVsZW1lbnRzLCB3aGljaCB3b3VsZCBpbnRlcmZlcmUgd2l0aCB0aGUgcmVzcG9uc2l2ZSByZXNpemUgcHJvY2Vzcy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI1MzhcbiAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgLy8gSW5jbHVkZSBwb3NzaWJsZSBib3JkZXJzIGluIHRoZSBzaXplXG4gIHN0eWxlLmJveFNpemluZyA9IHN0eWxlLmJveFNpemluZyB8fCAnYm9yZGVyLWJveCc7XG5cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVyV2lkdGgpKSB7XG4gICAgY29uc3QgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG4gICAgaWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVySGVpZ2h0KSkge1xuICAgIGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xuICAgICAgLy8gSWYgbm8gZXhwbGljaXQgcmVuZGVyIGhlaWdodCBhbmQgc3R5bGUgaGVpZ2h0LCBsZXQncyBhcHBseSB0aGUgYXNwZWN0IHJhdGlvLFxuICAgICAgLy8gd2hpY2ggb25lIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgYnV0IGFsc28gYnkgY2hhcnRzIGFzIGRlZmF1bHQgb3B0aW9uXG4gICAgICAvLyAoaS5lLiBvcHRpb25zLmFzcGVjdFJhdGlvKS4gSWYgbm90IHNwZWNpZmllZCwgdXNlIGNhbnZhcyBhc3BlY3QgcmF0aW8gb2YgMi5cbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoYXNwZWN0UmF0aW8gfHwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG4gICAgICBpZiAoZGlzcGxheUhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYW52YXM7XG59XG5cbi8vIERlZmF1bHQgcGFzc2l2ZSB0byB0cnVlIGFzIGV4cGVjdGVkIGJ5IENocm9tZSBmb3IgJ3RvdWNoc3RhcnQnIGFuZCAndG91Y2hlbmQnIGV2ZW50cy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80Mjg3XG5jb25zdCBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcblxuZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKGNoYXJ0ICYmIGNoYXJ0LmNhbnZhcykge1xuICAgIGNoYXJ0LmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuICBjb25zdCB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgY29uc3Qge3gsIHl9ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgY2hhcnQsXG4gICAgbmF0aXZlOiBldmVudCxcbiAgICB4OiB4ICE9PSB1bmRlZmluZWQgPyB4IDogbnVsbCxcbiAgICB5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9kZUxpc3RDb250YWlucyhub2RlTGlzdCwgY2FudmFzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTGlzdCkge1xuICAgIGlmIChub2RlID09PSBjYW52YXMgfHwgbm9kZS5jb250YWlucyhjYW52YXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQXR0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGV0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciAmJiAhbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuY29uc3QgZHJwTGlzdGVuaW5nQ2hhcnRzID0gbmV3IE1hcCgpO1xubGV0IG9sZERldmljZVBpeGVsUmF0aW8gPSAwO1xuXG5mdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGlmIChkcHIgPT09IG9sZERldmljZVBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmZvckVhY2goKHJlc2l6ZSwgY2hhcnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IGRwcikge1xuICAgICAgcmVzaXplKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSkge1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxuICBkcnBMaXN0ZW5pbmdDaGFydHMuc2V0KGNoYXJ0LCByZXNpemUpO1xufVxuXG5mdW5jdGlvbiB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KSB7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVzaXplID0gdGhyb3R0bGVkKCh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICBsaXN0ZW5lcih3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAodyA8IGNvbnRhaW5lci5jbGllbnRXaWR0aCkge1xuICAgICAgLy8gSWYgdGhlIGNvbnRhaW5lciBzaXplIHNocmFuayBkdXJpbmcgY2hhcnQgcmVzaXplLCBsZXQncyBhc3N1bWVcbiAgICAgIC8vIHNjcm9sbGJhciBhcHBlYXJlZC4gU28gd2UgcmVzaXplIGFnYWluIHdpdGggdGhlIHNjcm9sbGJhciB2aXNpYmxlIC1cbiAgICAgIC8vIGVmZmVjdGl2ZWx5IG1ha2luZyBjaGFydCBzbWFsbGVyIGFuZCB0aGUgc2Nyb2xsYmFyIGhpZGRlbiBhZ2Fpbi5cbiAgICAgIC8vIEJlY2F1c2Ugd2UgYXJlIGluc2lkZSBgdGhyb3R0bGVkYCwgYW5kIGN1cnJlbnRseSBgdGlja2luZ2AsIHNjcm9sbFxuICAgICAgLy8gZXZlbnRzIGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIHdob2xlIDIgcmVzaXplIHByb2Nlc3MuXG4gICAgICAvLyBJZiB3ZSBhc3N1bWVkIHdyb25nIGFuZCBzb21ldGhpbmcgZWxzZSBoYXBwZW5lZCwgd2UgYXJlIHJlc2l6aW5nXG4gICAgICAvLyB0d2ljZSBpbiBhIGZyYW1lIChwb3RlbnRpYWwgcGVyZm9ybWFuY2UgaXNzdWUpXG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSwgd2luZG93KTtcblxuICAvLyBAdHMtaWdub3JlIHVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzc4NjEgaW1wbGVtZW50ZWRcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgIGNvbnN0IHdpZHRoID0gZW50cnkuY29udGVudFJlY3Qud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZW50cnkuY29udGVudFJlY3QuaGVpZ2h0O1xuICAgIC8vIFdoZW4gaXRzIGNvbnRhaW5lcidzIGRpc3BsYXkgaXMgc2V0IHRvICdub25lJyB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCBhXG4gICAgLy8gc2l6ZSBvZiAoMCwgMCksIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGNoYXJ0IHRvIGxvc2UgaXRzIG9yaWdpbmFsIGhlaWdodCwgc28gc2tpcFxuICAgIC8vIHJlc2l6aW5nIGluIHN1Y2ggY2FzZS5cbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKTtcbiAgbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSk7XG5cbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIG9ic2VydmVyKSB7XG4gIGlmIChvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcm94eUFuZExpc3RlbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBwcm94eSA9IHRocm90dGxlZCgoZXZlbnQpID0+IHtcbiAgICAvLyBUaGlzIGNhc2UgY2FuIG9jY3VyIGlmIHRoZSBjaGFydCBpcyBkZXN0cm95ZWQgd2hpbGUgd2FpdGluZ1xuICAgIC8vIGZvciB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHRvIG9jY3VyLiBXZSBwcmV2ZW50IGNyYXNoZXMgYnkgY2hlY2tpbmdcbiAgICAvLyBmb3IgYSBkZXN0cm95ZWQgY2hhcnRcbiAgICBpZiAoY2hhcnQuY3R4ICE9PSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG4gICAgfVxuICB9LCBjaGFydCk7XG5cbiAgYWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG5cbiAgcmV0dXJuIHByb3h5O1xufVxuXG4vKipcbiAqIFBsYXRmb3JtIGNsYXNzIGZvciBjaGFydHMgdGhhdCBjYW4gYWNjZXNzIHRoZSBET00gYW5kIGdsb2JhbCB3aW5kb3cvZG9jdW1lbnQgcHJvcGVydGllc1xuICogQGV4dGVuZHMgQmFzZVBsYXRmb3JtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvbVBsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dXG5cdCAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfVxuXHQgKi9cbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICAgIC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcbiAgICAvLyBtZXRob2QsIGZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va2thcHNuZXIvQ2FudmFzQmxvY2tlclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCAmJiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIC8vIGBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50L0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRGAgZmFpbHMgd2hlbiB0aGUgY2FudmFzIGlzXG4gICAgLy8gaW5zaWRlIGFuIGlmcmFtZSBvciB3aGVuIHJ1bm5pbmcgaW4gYSBwcm90ZWN0ZWQgZW52aXJvbm1lbnQuIFdlIGNvdWxkIGd1ZXNzIHRoZVxuICAgIC8vIHR5cGVzIGZyb20gdGhlaXIgdG9TdHJpbmcoKSB2YWx1ZSBidXQgbGV0J3Mga2VlcCB0aGluZ3MgZmxleGlibGUgYW5kIGFzc3VtZSBpdCdzXG4gICAgLy8gYSBzdWZmaWNpZW50IGNvbmRpdGlvbiBpZiB0aGUgY2FudmFzIGhhcyBhIGNvbnRleHQyRCB3aGljaCBoYXMgY2FudmFzIGFzIGBjYW52YXNgLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zODg3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxMDJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDE1MlxuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBjYW52YXMpIHtcbiAgICAgIC8vIExvYWQgcGxhdGZvcm0gcmVzb3VyY2VzIG9uIGZpcnN0IGNoYXJ0IGNyZWF0aW9uLCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvXG4gICAgICAvLyBpbXBvcnQgdGhlIGxpYnJhcnkgYmVmb3JlIHNldHRpbmcgcGxhdGZvcm0gb3B0aW9ucy5cbiAgICAgIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbyk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxuXHQgKi9cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgIGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG4gICAgWydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgc3R5bGUgPSBpbml0aWFsLnN0eWxlIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNhbnZhcy5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICB9KTtcblxuICAgIC8vIFRoZSBjYW52YXMgcmVuZGVyIHNpemUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWQgKGFuZCB0aHVzIHRoZSBzdGF0ZSBzdGFjayBkaXNjYXJkZWQpLFxuICAgIC8vIHdlIGNhbid0IHVzZSBzYXZlKCkgYW5kIHJlc3RvcmUoKSB0byByZXN0b3JlIHRoZSBpbml0aWFsIHN0YXRlLiBTbyBtYWtlIHN1cmUgdGhhdCBhdFxuICAgIC8vIGxlYXN0IHRoZSBjYW52YXMgY29udGV4dCBpcyByZXNldCB0byB0aGUgZGVmYXVsdCBzdGF0ZSBieSBzZXR0aW5nIHRoZSBjYW52YXMgd2lkdGguXG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTA1MjUvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG5cbiAgICBkZWxldGUgY2FudmFzW0VYUEFORE9fS0VZXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lclxuXHQgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBDYW4gaGF2ZSBvbmx5IG9uZSBsaXN0ZW5lciBwZXIgdHlwZSwgc28gbWFrZSBzdXJlIHByZXZpb3VzIGlzIHJlbW92ZWRcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpO1xuXG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogY3JlYXRlQXR0YWNoT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IGNyZWF0ZURldGFjaE9ic2VydmVyLFxuICAgICAgcmVzaXplOiBjcmVhdGVSZXNpemVPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IGNyZWF0ZVByb3h5QW5kTGlzdGVuO1xuICAgIHByb3hpZXNbdHlwZV0gPSBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSkge1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgcHJveHkgPSBwcm94aWVzW3R5cGVdO1xuXG4gICAgaWYgKCFwcm94eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogcmVsZWFzZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgcmVtb3ZlTGlzdGVuZXI7XG4gICAgaGFuZGxlcihjaGFydCwgdHlwZSwgcHJveHkpO1xuICAgIHByb3hpZXNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gLSBjb250ZW50IHdpZHRoIG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSAtIGNvbnRlbnQgaGVpZ2h0IG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dIC0gYXNwZWN0IHJhdGlvIHRvIG1haW50YWluXG5cdCAqL1xuICBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgcmV0dXJuIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKi9cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIHJldHVybiAhIShjb250YWluZXIgJiYgY29udGFpbmVyLmlzQ29ubmVjdGVkKTtcbiAgfVxufVxuIiwgImltcG9ydCB7X2lzRG9tU3VwcG9ydGVkfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcbmltcG9ydCBCYXNpY1BsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzaWMuanMnO1xuaW1wb3J0IERvbVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uZG9tLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIF9kZXRlY3RQbGF0Zm9ybShjYW52YXMpIHtcbiAgaWYgKCFfaXNEb21TdXBwb3J0ZWQoKSB8fCAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSkge1xuICAgIHJldHVybiBCYXNpY1BsYXRmb3JtO1xuICB9XG4gIHJldHVybiBEb21QbGF0Zm9ybTtcbn1cblxuZXhwb3J0IHtCYXNlUGxhdGZvcm0sIEJhc2ljUGxhdGZvcm0sIERvbVBsYXRmb3JtfTtcbiIsICJpbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7UG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQgdHlwZSB7QW5pbWF0aW9ufSBmcm9tICcuLi90eXBlcy9hbmltYXRpb24uanMnO1xuaW1wb3J0IHtpc051bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50PFQgPSBBbnlPYmplY3QsIE8gPSBBbnlPYmplY3Q+IHtcblxuICBzdGF0aWMgZGVmYXVsdHMgPSB7fTtcbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB1bmRlZmluZWQ7XG5cbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIGFjdGl2ZSA9IGZhbHNlO1xuICBvcHRpb25zOiBPO1xuICAkYW5pbWF0aW9uczogUmVjb3JkPGtleW9mIFQsIEFuaW1hdGlvbj47XG5cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pOiBQb2ludCB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9IGFzIFBvaW50O1xuICB9XG5cbiAgaGFzVmFsdWUoKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHRoaXMueCkgJiYgaXNOdW1iZXIodGhpcy55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IG9yIGZpbmFsIHZhbHVlIG9mIGVhY2ggcHJvcC4gQ2FuIHJldHVybiBleHRyYSBwcm9wZXJ0aWVzICh3aG9sZSBvYmplY3QpLlxuICAgKiBAcGFyYW0gcHJvcHMgLSBwcm9wZXJ0aWVzIHRvIGdldFxuICAgKiBAcGFyYW0gW2ZpbmFsXSAtIGdldCB0aGUgZmluYWwgdmFsdWUgKGFuaW1hdGlvbiB0YXJnZXQpXG4gICAqL1xuICBnZXRQcm9wczxQIGV4dGVuZHMgKGtleW9mIFQpW10+KHByb3BzOiBQLCBmaW5hbD86IGJvb2xlYW4pOiBQaWNrPFQsIFBbbnVtYmVyXT47XG4gIGdldFByb3BzPFAgZXh0ZW5kcyBzdHJpbmc+KHByb3BzOiBQW10sIGZpbmFsPzogYm9vbGVhbik6IFBhcnRpYWw8UmVjb3JkPFAsIHVua25vd24+PjtcbiAgZ2V0UHJvcHMocHJvcHM6IHN0cmluZ1tdLCBmaW5hbD86IGJvb2xlYW4pOiBQYXJ0aWFsPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGlmICghZmluYWwgfHwgIWFuaW1zKSB7XG4gICAgICAvLyBsZXQncyBub3QgY3JlYXRlIGFuIG9iamVjdCwgaWYgbm90IG5lZWRlZFxuICAgICAgcmV0dXJuIHRoaXMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgfVxuICAgIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcbiAgICBwcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICByZXRbcHJvcF0gPSBhbmltc1twcm9wXSAmJiBhbmltc1twcm9wXS5hY3RpdmUoKSA/IGFuaW1zW3Byb3BdLl90byA6IHRoaXNbcHJvcCBhcyBzdHJpbmddO1xuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge19mYWN0b3JpemV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYge3t2YWx1ZTpudW1iZXIgfCBzdHJpbmcsIGxhYmVsPzpzdHJpbmcsIG1ham9yPzpib29sZWFuLCAkY29udGV4dD86YW55fX0gVGlja1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIHN1YnNldCBvZiB0aWNrcyB0byBiZSBwbG90dGVkIHRvIGF2b2lkIG92ZXJsYXBwaW5nIGxhYmVscy5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0fSBzY2FsZVxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcmV0dXJuIHtUaWNrW119XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXV0b1NraXAoc2NhbGUsIHRpY2tzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gc2NhbGUub3B0aW9ucy50aWNrcztcbiAgY29uc3QgZGV0ZXJtaW5lZE1heFRpY2tzID0gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpO1xuICBjb25zdCB0aWNrc0xpbWl0ID0gTWF0aC5taW4odGlja09wdHMubWF4VGlja3NMaW1pdCB8fCBkZXRlcm1pbmVkTWF4VGlja3MsIGRldGVybWluZWRNYXhUaWNrcyk7XG4gIGNvbnN0IG1ham9ySW5kaWNlcyA9IHRpY2tPcHRzLm1ham9yLmVuYWJsZWQgPyBnZXRNYWpvckluZGljZXModGlja3MpIDogW107XG4gIGNvbnN0IG51bU1ham9ySW5kaWNlcyA9IG1ham9ySW5kaWNlcy5sZW5ndGg7XG4gIGNvbnN0IGZpcnN0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBjb25zdCBsYXN0ID0gbWFqb3JJbmRpY2VzW251bU1ham9ySW5kaWNlcyAtIDFdO1xuICBjb25zdCBuZXdUaWNrcyA9IFtdO1xuXG4gIC8vIElmIHRoZXJlIGFyZSB0b28gbWFueSBtYWpvciB0aWNrcyB0byBkaXNwbGF5IHRoZW0gYWxsXG4gIGlmIChudW1NYWpvckluZGljZXMgPiB0aWNrc0xpbWl0KSB7XG4gICAgc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgbnVtTWFqb3JJbmRpY2VzIC8gdGlja3NMaW1pdCk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG5cbiAgY29uc3Qgc3BhY2luZyA9IGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCk7XG5cbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IDApIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBhdmdNYWpvclNwYWNpbmcgPSBudW1NYWpvckluZGljZXMgPiAxID8gTWF0aC5yb3VuZCgobGFzdCAtIGZpcnN0KSAvIChudW1NYWpvckluZGljZXMgLSAxKSkgOiBudWxsO1xuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyAwIDogZmlyc3QgLSBhdmdNYWpvclNwYWNpbmcsIGZpcnN0KTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbnVtTWFqb3JJbmRpY2VzIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9ySW5kaWNlc1tpXSwgbWFqb3JJbmRpY2VzW2kgKyAxXSk7XG4gICAgfVxuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBsYXN0LCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyB0aWNrcy5sZW5ndGggOiBsYXN0ICsgYXZnTWFqb3JTcGFjaW5nKTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cbiAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcpO1xuICByZXR1cm4gbmV3VGlja3M7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZU1heFRpY2tzKHNjYWxlKSB7XG4gIGNvbnN0IG9mZnNldCA9IHNjYWxlLm9wdGlvbnMub2Zmc2V0O1xuICBjb25zdCB0aWNrTGVuZ3RoID0gc2NhbGUuX3RpY2tTaXplKCk7XG4gIGNvbnN0IG1heFNjYWxlID0gc2NhbGUuX2xlbmd0aCAvIHRpY2tMZW5ndGggKyAob2Zmc2V0ID8gMCA6IDEpO1xuICBjb25zdCBtYXhDaGFydCA9IHNjYWxlLl9tYXhMZW5ndGggLyB0aWNrTGVuZ3RoO1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1pbihtYXhTY2FsZSwgbWF4Q2hhcnQpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBtYWpvckluZGljZXNcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHRpY2tzTGltaXRcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KSB7XG4gIGNvbnN0IGV2ZW5NYWpvclNwYWNpbmcgPSBnZXRFdmVuU3BhY2luZyhtYWpvckluZGljZXMpO1xuICBjb25zdCBzcGFjaW5nID0gdGlja3MubGVuZ3RoIC8gdGlja3NMaW1pdDtcblxuICAvLyBJZiB0aGUgbWFqb3IgdGlja3MgYXJlIGV2ZW5seSBzcGFjZWQgYXBhcnQsIHBsYWNlIHRoZSBtaW5vciB0aWNrc1xuICAvLyBzbyB0aGF0IHRoZXkgZGl2aWRlIHRoZSBtYWpvciB0aWNrcyBpbnRvIGV2ZW4gY2h1bmtzXG4gIGlmICghZXZlbk1ham9yU3BhY2luZykge1xuICAgIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbiAgfVxuXG4gIGNvbnN0IGZhY3RvcnMgPSBfZmFjdG9yaXplKGV2ZW5NYWpvclNwYWNpbmcpO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGZhY3RvcnMubGVuZ3RoIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgIGNvbnN0IGZhY3RvciA9IGZhY3RvcnNbaV07XG4gICAgaWYgKGZhY3RvciA+IHNwYWNpbmcpIHtcbiAgICAgIHJldHVybiBmYWN0b3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqL1xuZnVuY3Rpb24gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIGlmICh0aWNrc1tpXS5tYWpvcikge1xuICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcGFyYW0ge1RpY2tbXX0gbmV3VGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyW119IG1ham9ySW5kaWNlc1xuICogQHBhcmFtIHtudW1iZXJ9IHNwYWNpbmdcbiAqL1xuZnVuY3Rpb24gc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgc3BhY2luZykge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbmV4dCA9IG1ham9ySW5kaWNlc1swXTtcbiAgbGV0IGk7XG5cbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgZm9yIChpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBtYWpvckluZGljZXNbY291bnQgKiBzcGFjaW5nXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEBwYXJhbSB7VGlja1tdfSBuZXdUaWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHNwYWNpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWFqb3JTdGFydF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWFqb3JFbmRdXG4gKi9cbmZ1bmN0aW9uIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvclN0YXJ0LCBtYWpvckVuZCkge1xuICBjb25zdCBzdGFydCA9IHZhbHVlT3JEZWZhdWx0KG1ham9yU3RhcnQsIDApO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbih2YWx1ZU9yRGVmYXVsdChtYWpvckVuZCwgdGlja3MubGVuZ3RoKSwgdGlja3MubGVuZ3RoKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IGxlbmd0aCwgaSwgbmV4dDtcblxuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBpZiAobWFqb3JFbmQpIHtcbiAgICBsZW5ndGggPSBtYWpvckVuZCAtIG1ham9yU3RhcnQ7XG4gICAgc3BhY2luZyA9IGxlbmd0aCAvIE1hdGguZmxvb3IobGVuZ3RoIC8gc3BhY2luZyk7XG4gIH1cblxuICBuZXh0ID0gc3RhcnQ7XG5cbiAgd2hpbGUgKG5leHQgPCAwKSB7XG4gICAgY291bnQrKztcbiAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gIH1cblxuICBmb3IgKGkgPSBNYXRoLm1heChzdGFydCwgMCk7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBhcnJcbiAqL1xuZnVuY3Rpb24gZ2V0RXZlblNwYWNpbmcoYXJyKSB7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpLCBkaWZmO1xuXG4gIGlmIChsZW4gPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChkaWZmID0gYXJyWzBdLCBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFycltpXSAtIGFycltpIC0gMV0gIT09IGRpZmYpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYWxpZ25QaXhlbCwgX21lYXN1cmVUZXh0LCByZW5kZXJUZXh0LCBjbGlwQXJlYSwgdW5jbGlwQXJlYX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGwsIGVhY2gsIGZpbml0ZU9yRGVmYXVsdCwgaXNBcnJheSwgaXNGaW5pdGUsIGlzTnVsbE9yVW5kZWYsIGlzT2JqZWN0LCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0RlZ3JlZXMsIHRvUmFkaWFucywgX2ludDE2UmFuZ2UsIF9saW1pdFZhbHVlLCBIQUxGX1BJfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19hbGlnblN0YXJ0RW5kLCBfdG9MZWZ0UmlnaHRDZW50ZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCB0b0ZvbnQsIHRvUGFkZGluZywgX2FkZEdyYWNlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2F1dG9Ta2lwfSBmcm9tICcuL2NvcmUuc2NhbGUuYXV0b3NraXAuanMnO1xuXG5jb25zdCByZXZlcnNlQWxpZ24gPSAoYWxpZ24pID0+IGFsaWduID09PSAnbGVmdCcgPyAncmlnaHQnIDogYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiBhbGlnbjtcbmNvbnN0IG9mZnNldEZyb21FZGdlID0gKHNjYWxlLCBlZGdlLCBvZmZzZXQpID0+IGVkZ2UgPT09ICd0b3AnIHx8IGVkZ2UgPT09ICdsZWZ0JyA/IHNjYWxlW2VkZ2VdICsgb2Zmc2V0IDogc2NhbGVbZWRnZV0gLSBvZmZzZXQ7XG5jb25zdCBnZXRUaWNrc0xpbWl0ID0gKHRpY2tzTGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSA9PiBNYXRoLm1pbihtYXhUaWNrc0xpbWl0IHx8IHRpY2tzTGVuZ3RoLCB0aWNrc0xlbmd0aCk7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnQgfSBDaGFydFxuICogQHR5cGVkZWYge3t2YWx1ZTpudW1iZXIgfCBzdHJpbmcsIGxhYmVsPzpzdHJpbmcsIG1ham9yPzpib29sZWFuLCAkY29udGV4dD86YW55fX0gVGlja1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBhcnJheSBjb250YWluaW5nIG51bUl0ZW1zIGZyb20gYXJyXG4gKiBAcGFyYW0ge2FueVtdfSBhcnJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1JdGVtc1xuICovXG5mdW5jdGlvbiBzYW1wbGUoYXJyLCBudW1JdGVtcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgaW5jcmVtZW50ID0gYXJyLmxlbmd0aCAvIG51bUl0ZW1zO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBsZW47IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgcmVzdWx0LnB1c2goYXJyW01hdGguZmxvb3IoaSldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb2Zmc2V0R3JpZExpbmVzXG4gKi9cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUudGlja3MubGVuZ3RoO1xuICBjb25zdCB2YWxpZEluZGV4ID0gTWF0aC5taW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICBjb25zdCBzdGFydCA9IHNjYWxlLl9zdGFydFBpeGVsO1xuICBjb25zdCBlbmQgPSBzY2FsZS5fZW5kUGl4ZWw7XG4gIGNvbnN0IGVwc2lsb24gPSAxZS02OyAvLyAxZS02IGlzIG1hcmdpbiBpbiBwaXhlbHMgZm9yIGFjY3VtdWxhdGVkIGVycm9yLlxuICBsZXQgbGluZVZhbHVlID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXgpO1xuICBsZXQgb2Zmc2V0O1xuXG4gIGlmIChvZmZzZXRHcmlkTGluZXMpIHtcbiAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICBvZmZzZXQgPSBNYXRoLm1heChsaW5lVmFsdWUgLSBzdGFydCwgZW5kIC0gbGluZVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBvZmZzZXQgPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCAtIDEpKSAvIDI7XG4gICAgfVxuICAgIGxpbmVWYWx1ZSArPSB2YWxpZEluZGV4IDwgaW5kZXggPyBvZmZzZXQgOiAtb2Zmc2V0O1xuXG4gICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBpZiB0aGUgcGl4ZWwgaXMgb3V0IG9mIHRoZSByYW5nZVxuICAgIGlmIChsaW5lVmFsdWUgPCBzdGFydCAtIGVwc2lsb24gfHwgbGluZVZhbHVlID4gZW5kICsgZXBzaWxvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZVZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjYWNoZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcbiAgZWFjaChjYWNoZXMsIChjYWNoZSkgPT4ge1xuICAgIGNvbnN0IGdjID0gY2FjaGUuZ2M7XG4gICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICAgIGxldCBpO1xuICAgIGlmIChnY0xlbiA+IGxlbmd0aCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyArK2kpIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlLmRhdGFbZ2NbaV1dO1xuICAgICAgfVxuICAgICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZHJhd1RpY2tzID8gb3B0aW9ucy50aWNrTGVuZ3RoIDogMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRUaXRsZUhlaWdodChvcHRpb25zLCBmYWxsYmFjaykge1xuICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgY29uc3QgZm9udCA9IHRvRm9udChvcHRpb25zLmZvbnQsIGZhbGxiYWNrKTtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkob3B0aW9ucy50ZXh0KSA/IG9wdGlvbnMudGV4dC5sZW5ndGggOiAxO1xuXG4gIHJldHVybiAobGluZXMgKiBmb250LmxpbmVIZWlnaHQpICsgcGFkZGluZy5oZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlQ29udGV4dChwYXJlbnQsIHNjYWxlKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHNjYWxlLFxuICAgIHR5cGU6ICdzY2FsZSdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpY2tDb250ZXh0KHBhcmVudCwgaW5kZXgsIHRpY2spIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdGljayxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAndGljaydcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSB7XG4gIC8qKiBAdHlwZSB7Q2FudmFzVGV4dEFsaWdufSAqL1xuICBsZXQgcmV0ID0gX3RvTGVmdFJpZ2h0Q2VudGVyKGFsaWduKTtcbiAgaWYgKChyZXZlcnNlICYmIHBvc2l0aW9uICE9PSAncmlnaHQnKSB8fCAoIXJldmVyc2UgJiYgcG9zaXRpb24gPT09ICdyaWdodCcpKSB7XG4gICAgcmV0ID0gcmV2ZXJzZUFsaWduKHJldCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gdGl0bGVBcmdzKHNjYWxlLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbikge1xuICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBjaGFydH0gPSBzY2FsZTtcbiAgY29uc3Qge2NoYXJ0QXJlYSwgc2NhbGVzfSA9IGNoYXJ0O1xuICBsZXQgcm90YXRpb24gPSAwO1xuICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuXG4gIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSkge1xuICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG5cbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVZID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVZID0gKGNoYXJ0QXJlYS5ib3R0b20gKyBjaGFydEFyZWEudG9wKSAvIDIgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWSA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWCA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVYID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgIHJvdGF0aW9uID0gcG9zaXRpb24gPT09ICdsZWZ0JyA/IC1IQUxGX1BJIDogSEFMRl9QSTtcbiAgfVxuICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2FsZSBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5pZCA9IGNmZy5pZDtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzLnR5cGUgPSBjZmcudHlwZTtcbiAgICAvKiogQHR5cGUge2FueX0gKi9cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovXG4gICAgdGhpcy5jdHggPSBjZmcuY3R4O1xuICAgIC8qKiBAdHlwZSB7Q2hhcnR9ICovXG4gICAgdGhpcy5jaGFydCA9IGNmZy5jaGFydDtcblxuICAgIC8vIGltcGxlbWVudHMgYm94XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHNjYWxlLXNwZWNpZmljIHByb3BlcnRpZXNcbiAgICAvKiogQHR5cGUge3N0cmluZz19ICovXG4gICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyPX0gKi9cbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5taW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtUaWNrW119ICovXG4gICAgdGhpcy50aWNrcyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7b2JqZWN0W118bnVsbH0gKi9cbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICAvKiogQHR5cGUge29iamVjdFtdfG51bGx9ICovXG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtvYmplY3R8bnVsbH0gKi9cbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX21heExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbG9uZ2VzdFRleHRDYWNoZSA9IHt9O1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fZW5kUGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZXJNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdXNlck1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IDA7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge2FueX0gb3B0aW9uc1xuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuXG4gICAgdGhpcy5heGlzID0gb3B0aW9ucy5heGlzO1xuXG4gICAgLy8gcGFyc2UgbWluL21heCB2YWx1ZSwgc28gd2UgY2FuIHByb3Blcmx5IGRldGVybWluZSBtaW4vbWF4IGZvciBvdGhlciBzY2FsZXNcbiAgICB0aGlzLl91c2VyTWluID0gdGhpcy5wYXJzZShvcHRpb25zLm1pbik7XG4gICAgdGhpcy5fdXNlck1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5tYXgpO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNaW4pO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNYXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGEgc3VwcG9ydGVkIGlucHV0IHZhbHVlIHRvIGludGVybmFsIHJlcHJlc2VudGF0aW9uLlxuXHQgKiBAcGFyYW0geyp9IHJhd1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gcmF3O1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXIsIG1pbkRlZmluZWQ6IGJvb2xlYW4sIG1heERlZmluZWQ6IGJvb2xlYW59fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAzLjBcblx0ICovXG4gIGdldFVzZXJCb3VuZHMoKSB7XG4gICAgbGV0IHtfdXNlck1pbiwgX3VzZXJNYXgsIF9zdWdnZXN0ZWRNaW4sIF9zdWdnZXN0ZWRNYXh9ID0gdGhpcztcbiAgICBfdXNlck1pbiA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfdXNlck1heCA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWluID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1heCA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgX3N1Z2dlc3RlZE1pbiksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgX3N1Z2dlc3RlZE1heCksXG4gICAgICBtaW5EZWZpbmVkOiBpc0Zpbml0ZShfdXNlck1pbiksXG4gICAgICBtYXhEZWZpbmVkOiBpc0Zpbml0ZShfdXNlck1heClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuU3RhY2tcblx0ICogQHJldHVybiB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgZ2V0TWluTWF4KGNhblN0YWNrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHJhbmdlO1xuXG4gICAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHttaW4sIG1heH07XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHJhbmdlID0gbWV0YXNbaV0uY29udHJvbGxlci5nZXRNaW5NYXgodGhpcywgY2FuU3RhY2spO1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcmFuZ2UubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJhbmdlLm1heCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIG1pbiA8PSBtYXggd2hlbiBvbmx5IG1pbiBvciBtYXggaXMgZGVmaW5lZCBieSB1c2VyIGFuZCB0aGUgZGF0YSBpcyBvdXRzaWRlIHRoYXQgcmFuZ2VcbiAgICBtaW4gPSBtYXhEZWZpbmVkICYmIG1pbiA+IG1heCA/IG1heCA6IG1pbjtcbiAgICBtYXggPSBtaW5EZWZpbmVkICYmIG1pbiA+IG1heCA/IG1pbiA6IG1heDtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChtaW4sIGZpbml0ZU9yRGVmYXVsdChtYXgsIG1pbikpLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQobWF4LCBmaW5pdGVPckRlZmF1bHQobWluLCBtYXgpKVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogR2V0IHRoZSBwYWRkaW5nIG5lZWRlZCBmb3IgdGhlIHNjYWxlXG5cdCAqIEByZXR1cm4ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCBib3R0b206IG51bWJlciwgcmlnaHQ6IG51bWJlcn19IHRoZSBuZWNlc3NhcnkgcGFkZGluZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgZ2V0UGFkZGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5wYWRkaW5nTGVmdCB8fCAwLFxuICAgICAgdG9wOiB0aGlzLnBhZGRpbmdUb3AgfHwgMCxcbiAgICAgIHJpZ2h0OiB0aGlzLnBhZGRpbmdSaWdodCB8fCAwLFxuICAgICAgYm90dG9tOiB0aGlzLnBhZGRpbmdCb3R0b20gfHwgMFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc2NhbGUgdGljayBvYmplY3RzXG5cdCAqIEByZXR1cm4ge1RpY2tbXX1cblx0ICogQHNpbmNlIDIuN1xuXHQgKi9cbiAgZ2V0VGlja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7c3RyaW5nW119XG5cdCAqL1xuICBnZXRMYWJlbHMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHMgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KCcuLi90eXBlcy5qcycpLkxhYmVsSXRlbVtdfVxuICAgKi9cbiAgZ2V0TGFiZWxJdGVtcyhjaGFydEFyZWEgPSB0aGlzLmNoYXJ0LmNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGFiZWxJdGVtcyB8fCAodGhpcy5fbGFiZWxJdGVtcyA9IHRoaXMuX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIC8vIFdoZW4gYSBuZXcgbGF5b3V0IGlzIGNyZWF0ZWQsIHJlc2V0IHRoZSBkYXRhIGxpbWl0cyBjYWNoZVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gIH1cblxuICAvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxuICAvLyBBbnkgZnVuY3Rpb24gZGVmaW5lZCBoZXJlIGlzIGluaGVyaXRlZCBieSBhbGwgc2NhbGUgdHlwZXMuXG4gIC8vIEFueSBmdW5jdGlvbiBjYW4gYmUgZXh0ZW5kZWQgYnkgdGhlIHNjYWxlIHR5cGVcblxuICBiZWZvcmVVcGRhdGUoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXaWR0aCAtIHRoZSBtYXggd2lkdGggaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhIZWlnaHQgLSB0aGUgbWF4IGhlaWdodCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIHJpZ2h0OiBudW1iZXJ9fSBtYXJnaW5zIC0gdGhlIHNwYWNlIGJldHdlZW4gdGhlIGVkZ2Ugb2YgdGhlIG90aGVyIHNjYWxlcyBhbmQgZWRnZSBvZiB0aGUgY2hhcnRcblx0ICogICBUaGlzIHNwYWNlIGNvbWVzIGZyb20gdHdvIHNvdXJjZXM6XG5cdCAqICAgICAtIHBhZGRpbmcgLSBzcGFjZSB0aGF0J3MgcmVxdWlyZWQgdG8gc2hvdyB0aGUgbGFiZWxzIGF0IHRoZSBlZGdlcyBvZiB0aGUgc2NhbGVcblx0ICogICAgIC0gdGhpY2tuZXNzIG9mIHNjYWxlcyBvciBsZWdlbmRzIGluIGFub3RoZXIgb3JpZW50YXRpb25cblx0ICovXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvLCBncmFjZSwgdGlja3M6IHRpY2tPcHRzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzYW1wbGVTaXplID0gdGlja09wdHMuc2FtcGxlU2l6ZTtcblxuICAgIC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG4gICAgdGhpcy5iZWZvcmVVcGRhdGUoKTtcblxuICAgIC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSwgbWFyZ2lucyk7XG5cbiAgICB0aGlzLnRpY2tzID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcblxuICAgIC8vIERpbWVuc2lvbnNcbiAgICB0aGlzLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyB0aGlzLndpZHRoICsgbWFyZ2lucy5sZWZ0ICsgbWFyZ2lucy5yaWdodFxuICAgICAgOiB0aGlzLmhlaWdodCArIG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b207XG5cbiAgICAvLyBEYXRhIG1pbi9tYXhcbiAgICBpZiAoIXRoaXMuX2RhdGFMaW1pdHNDYWNoZWQpIHtcbiAgICAgIHRoaXMuYmVmb3JlRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmFmdGVyRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5fcmFuZ2UgPSBfYWRkR3JhY2UodGhpcywgZ3JhY2UsIGJlZ2luQXRaZXJvKTtcbiAgICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuYmVmb3JlQnVpbGRUaWNrcygpO1xuXG4gICAgdGhpcy50aWNrcyA9IHRoaXMuYnVpbGRUaWNrcygpIHx8IFtdO1xuXG4gICAgLy8gQWxsb3cgbW9kaWZpY2F0aW9uIG9mIHRpY2tzIGluIGNhbGxiYWNrLlxuICAgIHRoaXMuYWZ0ZXJCdWlsZFRpY2tzKCk7XG5cbiAgICAvLyBDb21wdXRlIHRpY2sgcm90YXRpb24gYW5kIGZpdCB1c2luZyBhIHNhbXBsZWQgc3Vic2V0IG9mIGxhYmVsc1xuICAgIC8vIFdlIGdlbmVyYWxseSBkb24ndCBuZWVkIHRvIGNvbXB1dGUgdGhlIHNpemUgb2YgZXZlcnkgc2luZ2xlIGxhYmVsIGZvciBkZXRlcm1pbmluZyBzY2FsZSBzaXplXG4gICAgY29uc3Qgc2FtcGxpbmdFbmFibGVkID0gc2FtcGxlU2l6ZSA8IHRoaXMudGlja3MubGVuZ3RoO1xuICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHNhbXBsaW5nRW5hYmxlZCA/IHNhbXBsZSh0aGlzLnRpY2tzLCBzYW1wbGVTaXplKSA6IHRoaXMudGlja3MpO1xuXG4gICAgLy8gY29uZmlndXJlIGlzIGNhbGxlZCB0d2ljZSwgb25jZSBoZXJlLCBvbmNlIGZyb20gY29yZS5jb250cm9sbGVyLnVwZGF0ZUxheW91dC5cbiAgICAvLyBIZXJlIHdlIGhhdmVuJ3QgYmVlbiBwb3NpdGlvbmVkIHlldCwgYnV0IGRpbWVuc2lvbnMgYXJlIGNvcnJlY3QuXG4gICAgLy8gVmFyaWFibGVzIHNldCBpbiBjb25maWd1cmUgYXJlIG5lZWRlZCBmb3IgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgYW5kXG4gICAgLy8gaXQncyBvayB0aGF0IGNvb3JkaW5hdGVzIGFyZSBub3QgY29ycmVjdCB0aGVyZSwgb25seSBkaW1lbnNpb25zIG1hdHRlci5cbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuXG4gICAgLy8gVGljayBSb3RhdGlvblxuICAgIHRoaXMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpOyAvLyBQcmVjb25kaXRpb25zOiBudW1iZXIgb2YgdGlja3MgYW5kIHNpemVzIG9mIGxhcmdlc3QgbGFiZWxzIG11c3QgYmUgY2FsY3VsYXRlZCBiZWZvcmVoYW5kXG4gICAgdGhpcy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcblxuICAgIC8vIEF1dG8tc2tpcFxuICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmICh0aWNrT3B0cy5hdXRvU2tpcCB8fCB0aWNrT3B0cy5zb3VyY2UgPT09ICdhdXRvJykpIHtcbiAgICAgIHRoaXMudGlja3MgPSBhdXRvU2tpcCh0aGlzLCB0aGlzLnRpY2tzKTtcbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgICAgdGhpcy5hZnRlckF1dG9Ta2lwKCk7XG4gICAgfVxuXG4gICAgaWYgKHNhbXBsaW5nRW5hYmxlZCkge1xuICAgICAgLy8gR2VuZXJhdGUgbGFiZWxzIHVzaW5nIGFsbCBub24tc2tpcHBlZCB0aWNrc1xuICAgICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHModGhpcy50aWNrcyk7XG4gICAgfVxuXG4gICAgdGhpcy5iZWZvcmVGaXQoKTtcbiAgICB0aGlzLmZpdCgpOyAvLyBQcmVjb25kaXRpb25zOiBsYWJlbCByb3RhdGlvbiBhbmQgbGFiZWwgc2l6ZXMgbXVzdCBiZSBjYWxjdWxhdGVkIGJlZm9yZWhhbmRcbiAgICB0aGlzLmFmdGVyRml0KCk7XG5cbiAgICAvLyBJTVBPUlRBTlQ6IGFmdGVyIHRoaXMgcG9pbnQsIHdlIGNvbnNpZGVyIHRoYXQgYHRoaXMudGlja3NgIHdpbGwgTkVWRVIgY2hhbmdlIVxuXG4gICAgdGhpcy5hZnRlclVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBsZXQgcmV2ZXJzZVBpeGVscyA9IHRoaXMub3B0aW9ucy5yZXZlcnNlO1xuICAgIGxldCBzdGFydFBpeGVsLCBlbmRQaXhlbDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy5sZWZ0O1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy50b3A7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMuYm90dG9tO1xuICAgICAgLy8gYnkgZGVmYXVsdCB2ZXJ0aWNhbCBzY2FsZXMgYXJlIGZyb20gYm90dG9tIHRvIHRvcCwgc28gcGl4ZWxzIGFyZSByZXZlcnNlZFxuICAgICAgcmV2ZXJzZVBpeGVscyA9ICFyZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFBpeGVsID0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9lbmRQaXhlbCA9IGVuZFBpeGVsO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSByZXZlcnNlUGl4ZWxzO1xuICAgIHRoaXMuX2xlbmd0aCA9IGVuZFBpeGVsIC0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9hbGlnblRvUGl4ZWxzID0gdGhpcy5vcHRpb25zLmFsaWduVG9QaXhlbHM7XG4gIH1cblxuICBhZnRlclVwZGF0ZSgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vXG5cbiAgYmVmb3JlU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgLy8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgLy8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IDA7XG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcblxuICAgICAgLy8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG4gICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHBhZGRpbmdcbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSAwO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xuICB9XG4gIGFmdGVyU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cblxuICBfY2FsbEhvb2tzKG5hbWUpIHtcbiAgICB0aGlzLmNoYXJ0Lm5vdGlmeVBsdWdpbnMobmFtZSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNhbGwodGhpcy5vcHRpb25zW25hbWVdLCBbdGhpc10pO1xuICB9XG5cbiAgLy8gRGF0YSBsaW1pdHNcbiAgYmVmb3JlRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZURhdGFMaW1pdHMnKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge31cbiAgYWZ0ZXJEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJEYXRhTGltaXRzJyk7XG4gIH1cblxuICAvL1xuICBiZWZvcmVCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlQnVpbGRUaWNrcycpO1xuICB9XG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX0gdGhlIHRpY2tzXG5cdCAqL1xuICBidWlsZFRpY2tzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBhZnRlckJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckJ1aWxkVGlja3MnKTtcbiAgfVxuXG4gIGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgLyoqXG5cdCAqIENvbnZlcnQgdGlja3MgdG8gbGFiZWwgc3RyaW5nc1xuXHQgKiBAcGFyYW0ge1RpY2tbXX0gdGlja3Ncblx0ICovXG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSBjYWxsKHRpY2tPcHRzLmNhbGxiYWNrLCBbdGljay52YWx1ZSwgaSwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cblxuICAvL1xuXG4gIGJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IG51bVRpY2tzID0gZ2V0VGlja3NMaW1pdCh0aGlzLnRpY2tzLmxlbmd0aCwgb3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0KTtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XG4gICAgY29uc3QgbWF4Um90YXRpb24gPSB0aWNrT3B0cy5tYXhSb3RhdGlvbjtcbiAgICBsZXQgbGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgIGxldCB0aWNrV2lkdGgsIG1heEhlaWdodCwgbWF4TGFiZWxEaWFnb25hbDtcblxuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIXRpY2tPcHRzLmRpc3BsYXkgfHwgbWluUm90YXRpb24gPj0gbWF4Um90YXRpb24gfHwgbnVtVGlja3MgPD0gMSB8fCAhdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBtYXhMYWJlbFdpZHRoID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG4gICAgY29uc3QgbWF4TGFiZWxIZWlnaHQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0O1xuXG4gICAgLy8gRXN0aW1hdGUgdGhlIHdpZHRoIG9mIGVhY2ggZ3JpZCBiYXNlZCBvbiB0aGUgY2FudmFzIHdpZHRoLCB0aGUgbWF4aW11bVxuICAgIC8vIGxhYmVsIHdpZHRoIGFuZCB0aGUgbnVtYmVyIG9mIHRpY2sgaW50ZXJ2YWxzXG4gICAgY29uc3QgbWF4V2lkdGggPSBfbGltaXRWYWx1ZSh0aGlzLmNoYXJ0LndpZHRoIC0gbWF4TGFiZWxXaWR0aCwgMCwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGlja1dpZHRoID0gb3B0aW9ucy5vZmZzZXQgPyB0aGlzLm1heFdpZHRoIC8gbnVtVGlja3MgOiBtYXhXaWR0aCAvIChudW1UaWNrcyAtIDEpO1xuXG4gICAgLy8gQWxsb3cgMyBwaXhlbHMgeDIgcGFkZGluZyBlaXRoZXIgc2lkZSBmb3IgbGFiZWwgcmVhZGFiaWxpdHlcbiAgICBpZiAobWF4TGFiZWxXaWR0aCArIDYgPiB0aWNrV2lkdGgpIHtcbiAgICAgIHRpY2tXaWR0aCA9IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gKG9wdGlvbnMub2Zmc2V0ID8gMC41IDogMSkpO1xuICAgICAgbWF4SGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpXG5cdFx0XHRcdC0gdGlja09wdHMucGFkZGluZyAtIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMudGl0bGUsIHRoaXMuY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIG1heExhYmVsRGlhZ29uYWwgPSBNYXRoLnNxcnQobWF4TGFiZWxXaWR0aCAqIG1heExhYmVsV2lkdGggKyBtYXhMYWJlbEhlaWdodCAqIG1heExhYmVsSGVpZ2h0KTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSB0b0RlZ3JlZXMoTWF0aC5taW4oXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZSgobGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIDYpIC8gdGlja1dpZHRoLCAtMSwgMSkpLFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4SGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKSAtIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhMYWJlbEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSlcbiAgICAgICkpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IE1hdGgubWF4KG1pblJvdGF0aW9uLCBNYXRoLm1pbihtYXhSb3RhdGlvbiwgbGFiZWxSb3RhdGlvbikpO1xuICAgIH1cblxuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG4gIH1cbiAgYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBhZnRlckF1dG9Ta2lwKCkge31cblxuICAvL1xuXG4gIGJlZm9yZUZpdCgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG4gIH1cbiAgZml0KCkge1xuICAgIC8vIFJlc2V0XG4gICAgY29uc3QgbWluU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcblxuICAgIGNvbnN0IHtjaGFydCwgb3B0aW9uczoge3RpY2tzOiB0aWNrT3B0cywgdGl0bGU6IHRpdGxlT3B0cywgZ3JpZDogZ3JpZE9wdHN9fSA9IHRoaXM7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMuX2lzVmlzaWJsZSgpO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG5cbiAgICBpZiAoZGlzcGxheSkge1xuICAgICAgY29uc3QgdGl0bGVIZWlnaHQgPSBnZXRUaXRsZUhlaWdodCh0aXRsZU9wdHMsIGNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIG1pblNpemUud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuICAgICAgICBtaW5TaXplLndpZHRoID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIERvbid0IGJvdGhlciBmaXR0aW5nIHRoZSB0aWNrcyBpZiB3ZSBhcmUgbm90IHNob3dpbmcgdGhlIGxhYmVsc1xuICAgICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgdGhpcy50aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qge2ZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3R9ID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgICAgICBjb25zdCB0aWNrUGFkZGluZyA9IHRpY2tPcHRzLnBhZGRpbmcgKiAyO1xuICAgICAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcblxuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIC8vIEEgaG9yaXpvbnRhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIGhlaWdodC5cbiAgICAgICAgICBjb25zdCBsYWJlbEhlaWdodCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBzaW4gKiB3aWRlc3Qud2lkdGggKyBjb3MgKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICBtaW5TaXplLmhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBtaW5TaXplLmhlaWdodCArIGxhYmVsSGVpZ2h0ICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBIHZlcnRpY2FsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgd2lkdGguIExhYmVscyBhcmUgdGhlXG4gICAgICAgIC8vIGRvbWluYW50IGZhY3RvciBoZXJlLCBzbyBnZXQgdGhhdCBsZW5ndGggZmlyc3QgYW5kIGFjY291bnQgZm9yIHBhZGRpbmdcbiAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGlja09wdHMubWlycm9yID8gMCA6IGNvcyAqIHdpZGVzdC53aWR0aCArIHNpbiAqIGhpZ2hlc3QuaGVpZ2h0O1xuXG4gICAgICAgICAgbWluU2l6ZS53aWR0aCA9IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIG1pblNpemUud2lkdGggKyBsYWJlbFdpZHRoICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVNYXJnaW5zKCk7XG5cbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSB0aGlzLl9tYXJnaW5zLmxlZnQgLSB0aGlzLl9tYXJnaW5zLnJpZ2h0O1xuICAgICAgdGhpcy5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IG1pblNpemUud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LmhlaWdodCAtIHRoaXMuX21hcmdpbnMudG9wIC0gdGhpcy5fbWFyZ2lucy5ib3R0b207XG4gICAgfVxuICB9XG5cbiAgX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKSB7XG4gICAgY29uc3Qge3RpY2tzOiB7YWxpZ24sIHBhZGRpbmd9LCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaXNSb3RhdGVkID0gdGhpcy5sYWJlbFJvdGF0aW9uICE9PSAwO1xuICAgIGNvbnN0IGxhYmVsc0JlbG93VGlja3MgPSBwb3NpdGlvbiAhPT0gJ3RvcCcgJiYgdGhpcy5heGlzID09PSAneCc7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gdGhpcy5sZWZ0O1xuICAgICAgY29uc3Qgb2Zmc2V0UmlnaHQgPSB0aGlzLnJpZ2h0IC0gdGhpcy5nZXRQaXhlbEZvclRpY2sodGhpcy50aWNrcy5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBwYWRkaW5nTGVmdCA9IDA7XG4gICAgICBsZXQgcGFkZGluZ1JpZ2h0ID0gMDtcblxuICAgICAgLy8gRW5zdXJlIHRoYXQgb3VyIHRpY2tzIGFyZSBhbHdheXMgaW5zaWRlIHRoZSBjYW52YXMuIFdoZW4gcm90YXRlZCwgdGlja3MgYXJlIHJpZ2h0IGFsaWduZWRcbiAgICAgIC8vIHdoaWNoIG1lYW5zIHRoYXQgdGhlIHJpZ2h0IHBhZGRpbmcgaXMgZG9taW5hdGVkIGJ5IHRoZSBmb250IGhlaWdodFxuICAgICAgaWYgKGlzUm90YXRlZCkge1xuICAgICAgICBpZiAobGFiZWxzQmVsb3dUaWNrcykge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gY29zICogZmlyc3Qud2lkdGg7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gc2luICogbGFzdC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBzaW4gKiBmaXJzdC5oZWlnaHQ7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gY29zICogbGFzdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aCAvIDI7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGggLyAyO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGp1c3QgcGFkZGluZyB0YWtpbmcgaW50byBhY2NvdW50IGNoYW5nZXMgaW4gb2Zmc2V0c1xuICAgICAgdGhpcy5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KChwYWRkaW5nTGVmdCAtIG9mZnNldExlZnQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldExlZnQpLCAwKTtcbiAgICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRSaWdodCksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0IC8gMjtcbiAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0IC8gMjtcblxuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSAwO1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0O1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcCArIHBhZGRpbmc7XG4gICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tICsgcGFkZGluZztcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIG1hcmdpbnMgYW5kIHBhZGRpbmcgaW50ZXJhY3Rpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaGFuZGxlTWFyZ2lucygpIHtcbiAgICBpZiAodGhpcy5fbWFyZ2lucykge1xuICAgICAgdGhpcy5fbWFyZ2lucy5sZWZ0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nTGVmdCwgdGhpcy5fbWFyZ2lucy5sZWZ0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMudG9wID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nVG9wLCB0aGlzLl9tYXJnaW5zLnRvcCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nUmlnaHQsIHRoaXMuX21hcmdpbnMucmlnaHQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy5ib3R0b20gPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdCb3R0b20sIHRoaXMuX21hcmdpbnMuYm90dG9tKTtcbiAgICB9XG4gIH1cblxuICBhZnRlckZpdCgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlckZpdCwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vIFNoYXJlZCBNZXRob2RzXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHtheGlzLCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgYXhpcyA9PT0gJ3gnO1xuICB9XG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaXNGdWxsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZ1bGxTaXplO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRpY2tzKSB7XG4gICAgdGhpcy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcblxuICAgIHRoaXMuZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKTtcblxuICAgIC8vIFRpY2tzIHNob3VsZCBiZSBza2lwcGVkIHdoZW4gY2FsbGJhY2sgcmV0dXJucyBudWxsIG9yIHVuZGVmLCBzbyBsZXRzIHJlbW92ZSB0aG9zZS5cbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih0aWNrc1tpXS5sYWJlbCkpIHtcbiAgICAgICAgdGlja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBpbGVuLS07XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7eyBmaXJzdDogb2JqZWN0LCBsYXN0OiBvYmplY3QsIHdpZGVzdDogb2JqZWN0LCBoaWdoZXN0OiBvYmplY3QsIHdpZHRoczogQXJyYXksIGhlaWdodHM6IGFycmF5IH19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxTaXplcygpIHtcbiAgICBsZXQgbGFiZWxTaXplcyA9IHRoaXMuX2xhYmVsU2l6ZXM7XG5cbiAgICBpZiAoIWxhYmVsU2l6ZXMpIHtcbiAgICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlja3Muc2FtcGxlU2l6ZTtcbiAgICAgIGxldCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgICBpZiAoc2FtcGxlU2l6ZSA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgICB0aWNrcyA9IHNhbXBsZSh0aWNrcywgc2FtcGxlU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBsYWJlbFNpemVzID0gdGhpcy5fY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIHRpY2tzLmxlbmd0aCwgdGhpcy5vcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQpO1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbFNpemVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMge3dpZHRoLCBoZWlnaHQsIG9mZnNldH0gb2JqZWN0cyBmb3IgdGhlIGZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3QgdGlja1xuXHQgKiBsYWJlbHMgd2hlcmUgb2Zmc2V0IGluZGljYXRlcyB0aGUgYW5jaG9yIHBvaW50IG9mZnNldCBmcm9tIHRoZSB0b3AgaW4gcGl4ZWxzLlxuXHQgKiBAcmV0dXJuIHt7IGZpcnN0OiBvYmplY3QsIGxhc3Q6IG9iamVjdCwgd2lkZXN0OiBvYmplY3QsIGhpZ2hlc3Q6IG9iamVjdCwgd2lkdGhzOiBBcnJheSwgaGVpZ2h0czogYXJyYXkgfX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgbGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSB7XG4gICAgY29uc3Qge2N0eCwgX2xvbmdlc3RUZXh0Q2FjaGU6IGNhY2hlc30gPSB0aGlzO1xuICAgIGNvbnN0IHdpZHRocyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodHMgPSBbXTtcbiAgICBjb25zdCBpbmNyZW1lbnQgPSBNYXRoLmZsb29yKGxlbmd0aCAvIGdldFRpY2tzTGltaXQobGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSk7XG4gICAgbGV0IHdpZGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGhpZ2hlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBpLCBqLCBqbGVuLCBsYWJlbCwgdGlja0ZvbnQsIGZvbnRTdHJpbmcsIGNhY2hlLCBsaW5lSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBuZXN0ZWRMYWJlbDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgICBsYWJlbCA9IHRpY2tzW2ldLmxhYmVsO1xuICAgICAgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgY3R4LmZvbnQgPSBmb250U3RyaW5nID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgY2FjaGUgPSBjYWNoZXNbZm9udFN0cmluZ10gPSBjYWNoZXNbZm9udFN0cmluZ10gfHwge2RhdGE6IHt9LCBnYzogW119O1xuICAgICAgbGluZUhlaWdodCA9IHRpY2tGb250LmxpbmVIZWlnaHQ7XG4gICAgICB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICAvLyBVbmRlZmluZWQgbGFiZWxzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKGxhYmVsKSAmJiAhaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIGxhYmVsKTtcbiAgICAgICAgaGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0J3MgbWVhc3VyZSBlYWNoIGVsZW1lbnRcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVsLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIG5lc3RlZExhYmVsID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChsYWJlbFtqXSk7XG4gICAgICAgICAgLy8gVW5kZWZpbmVkIGxhYmVscyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobmVzdGVkTGFiZWwpICYmICFpc0FycmF5KG5lc3RlZExhYmVsKSkge1xuICAgICAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIG5lc3RlZExhYmVsKTtcbiAgICAgICAgICAgIGhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2lkdGhzLnB1c2god2lkdGgpO1xuICAgICAgaGVpZ2h0cy5wdXNoKGhlaWdodCk7XG4gICAgICB3aWRlc3RMYWJlbFNpemUgPSBNYXRoLm1heCh3aWR0aCwgd2lkZXN0TGFiZWxTaXplKTtcbiAgICAgIGhpZ2hlc3RMYWJlbFNpemUgPSBNYXRoLm1heChoZWlnaHQsIGhpZ2hlc3RMYWJlbFNpemUpO1xuICAgIH1cbiAgICBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCk7XG5cbiAgICBjb25zdCB3aWRlc3QgPSB3aWR0aHMuaW5kZXhPZih3aWRlc3RMYWJlbFNpemUpO1xuICAgIGNvbnN0IGhpZ2hlc3QgPSBoZWlnaHRzLmluZGV4T2YoaGlnaGVzdExhYmVsU2l6ZSk7XG5cbiAgICBjb25zdCB2YWx1ZUF0ID0gKGlkeCkgPT4gKHt3aWR0aDogd2lkdGhzW2lkeF0gfHwgMCwgaGVpZ2h0OiBoZWlnaHRzW2lkeF0gfHwgMH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0OiB2YWx1ZUF0KDApLFxuICAgICAgbGFzdDogdmFsdWVBdChsZW5ndGggLSAxKSxcbiAgICAgIHdpZGVzdDogdmFsdWVBdCh3aWRlc3QpLFxuICAgICAgaGlnaGVzdDogdmFsdWVBdChoaWdoZXN0KSxcbiAgICAgIHdpZHRocyxcbiAgICAgIGhlaWdodHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgbGFiZWwgdG8gZGlzcGxheSBpbiB0aGUgdG9vbHRpcCBmb3IgdGhlIGdpdmVuIHZhbHVlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgZ2l2ZW4gZGF0YSBwb2ludC4gVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlLCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgZGF0YSB2YWx1ZSBmcm9tIGEgZ2l2ZW4gcGl4ZWwuIFRoaXMgaXMgdGhlIGludmVyc2Ugb2YgZ2V0UGl4ZWxGb3JWYWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSB0aWNrIGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBnZXR0aW5nIHRoZSBwaXhlbCBsb2NhdGlvbiBvZiBhIHBlcmNlbnRhZ2Ugb2Ygc2NhbGVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yRGVjaW1hbChkZWNpbWFsKSB7XG4gICAgaWYgKHRoaXMuX3JldmVyc2VQaXhlbHMpIHtcbiAgICAgIGRlY2ltYWwgPSAxIC0gZGVjaW1hbDtcbiAgICB9XG5cbiAgICBjb25zdCBwaXhlbCA9IHRoaXMuX3N0YXJ0UGl4ZWwgKyBkZWNpbWFsICogdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiBfaW50MTZSYW5nZSh0aGlzLl9hbGlnblRvUGl4ZWxzID8gX2FsaWduUGl4ZWwodGhpcy5jaGFydCwgcGl4ZWwsIDApIDogcGl4ZWwpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gKHBpeGVsIC0gdGhpcy5fc3RhcnRQaXhlbCkgLyB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZGVjaW1hbCA6IGRlY2ltYWw7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgcGl4ZWwgZm9yIHRoZSBtaW5pbXVtIGNoYXJ0IHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRCYXNlVmFsdWUoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG5cbiAgICByZXR1cm4gbWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcbiAgICAgIG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG4gICAgICAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3MgfHwgW107XG5cbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICAgIHJldHVybiB0aWNrLiRjb250ZXh0IHx8XG5cdFx0XHRcdCh0aWNrLiRjb250ZXh0ID0gY3JlYXRlVGlja0NvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCB0aWNrKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVNjYWxlQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF90aWNrU2l6ZSgpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcblxuICAgIC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgYnkgbGFiZWwgaW4gYXhpcyBkaXJlY3Rpb24uXG4gICAgY29uc3Qgcm90ID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90KSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG5cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcbiAgICBjb25zdCB3ID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoICsgcGFkZGluZyA6IDA7XG4gICAgY29uc3QgaCA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XG5cbiAgICAvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGZvciAxIHRpY2sgaW4gYXhpcyBkaXJlY3Rpb24uXG4gICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpblxuICAgICAgOiBoICogc2luIDwgdyAqIGNvcyA/IGggLyBjb3MgOiB3IC8gc2luO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaXNWaXNpYmxlKCkge1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLm9wdGlvbnMuZGlzcGxheTtcblxuICAgIGlmIChkaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiAhIWRpc3BsYXk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7Z3JpZCwgcG9zaXRpb24sIGJvcmRlcn0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG9mZnNldCA9IGdyaWQub2Zmc2V0O1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tzTGVuZ3RoID0gdGlja3MubGVuZ3RoICsgKG9mZnNldCA/IDEgOiAwKTtcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWQpO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG5cbiAgICBjb25zdCBib3JkZXJPcHRzID0gYm9yZGVyLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlck9wdHMuZGlzcGxheSA/IGJvcmRlck9wdHMud2lkdGggOiAwO1xuICAgIGNvbnN0IGF4aXNIYWxmV2lkdGggPSBheGlzV2lkdGggLyAyO1xuICAgIGNvbnN0IGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xuICAgICAgcmV0dXJuIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgYXhpc1dpZHRoKTtcbiAgICB9O1xuICAgIGxldCBib3JkZXJWYWx1ZSwgaSwgbGluZVZhbHVlLCBhbGlnbmVkTGluZVZhbHVlO1xuICAgIGxldCB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuYm90dG9tKTtcbiAgICAgIHR5MSA9IHRoaXMuYm90dG9tIC0gdGw7XG4gICAgICB0eTIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnRvcCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy50b3ApO1xuICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgeTIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5ib3R0b20pIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHRoaXMudG9wICsgdGw7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5yaWdodCk7XG4gICAgICB0eDEgPSB0aGlzLnJpZ2h0IC0gdGw7XG4gICAgICB0eDIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmxlZnQpICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmxlZnQpO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEucmlnaHQpIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHRoaXMubGVmdCArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMiArIDAuNSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0eTEgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cblxuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdHgxIC0gdGw7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfVxuXG4gICAgY29uc3QgbGltaXQgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQsIHRpY2tzTGVuZ3RoKTtcbiAgICBjb25zdCBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRpY2tzTGVuZ3RoIC8gbGltaXQpKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGlja3NMZW5ndGg7IGkgKz0gc3RlcCkge1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChpKTtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXhCb3JkZXIgPSBib3JkZXIuc2V0Q29udGV4dChjb250ZXh0KTtcblxuICAgICAgY29uc3QgbGluZVdpZHRoID0gb3B0c0F0SW5kZXgubGluZVdpZHRoO1xuICAgICAgY29uc3QgbGluZUNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBib3JkZXJEYXNoID0gb3B0c0F0SW5kZXhCb3JkZXIuZGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleEJvcmRlci5kYXNoT2Zmc2V0O1xuXG4gICAgICBjb25zdCB0aWNrV2lkdGggPSBvcHRzQXRJbmRleC50aWNrV2lkdGg7XG4gICAgICBjb25zdCB0aWNrQ29sb3IgPSBvcHRzQXRJbmRleC50aWNrQ29sb3I7XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoIHx8IFtdO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaE9mZnNldDtcblxuICAgICAgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZSh0aGlzLCBpLCBvZmZzZXQpO1xuXG4gICAgICAvLyBTa2lwIGlmIHRoZSBwaXhlbCBpcyBvdXQgb2YgdGhlIHJhbmdlXG4gICAgICBpZiAobGluZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGFsaWduZWRMaW5lVmFsdWUgPSBfYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICB0eDEsXG4gICAgICAgIHR5MSxcbiAgICAgICAgdHgyLFxuICAgICAgICB0eTIsXG4gICAgICAgIHgxLFxuICAgICAgICB5MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkyLFxuICAgICAgICB3aWR0aDogbGluZVdpZHRoLFxuICAgICAgICBjb2xvcjogbGluZUNvbG9yLFxuICAgICAgICBib3JkZXJEYXNoLFxuICAgICAgICBib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICB0aWNrV2lkdGgsXG4gICAgICAgIHRpY2tDb2xvcixcbiAgICAgICAgdGlja0JvcmRlckRhc2gsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSB0aWNrc0xlbmd0aDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IGJvcmRlclZhbHVlO1xuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IG9wdGlvblRpY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3Qge2FsaWduLCBjcm9zc0FsaWduLCBwYWRkaW5nLCBtaXJyb3J9ID0gb3B0aW9uVGlja3M7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IGhUaWNrQW5kUGFkZGluZyA9IG1pcnJvciA/IC1wYWRkaW5nIDogdGlja0FuZFBhZGRpbmc7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdGljaywgbGFiZWwsIHgsIHksIHRleHRBbGlnbiwgcGl4ZWwsIGZvbnQsIGxpbmVIZWlnaHQsIGxpbmVDb3VudCwgdGV4dE9mZnNldDtcbiAgICBsZXQgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICB5ID0gdGhpcy5ib3R0b20gLSBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHkgPSB0aGlzLnRvcCArIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeSA9ICgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMikgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeSA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHggPSAoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpIC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHggPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKS50ZXh0QWxpZ247XG4gICAgfVxuXG4gICAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG5cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gb3B0aW9uVGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaSkpO1xuICAgICAgcGl4ZWwgPSB0aGlzLmdldFBpeGVsRm9yVGljayhpKSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuICAgICAgZm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBsaW5lSGVpZ2h0ID0gZm9udC5saW5lSGVpZ2h0O1xuICAgICAgbGluZUNvdW50ID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbC5sZW5ndGggOiAxO1xuICAgICAgY29uc3QgaGFsZkNvdW50ID0gbGluZUNvdW50IC8gMjtcbiAgICAgIGNvbnN0IGNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBzdHJva2VDb2xvciA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgbGV0IHRpY2tUZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgeCA9IHBpeGVsO1xuXG4gICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1saW5lQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmVseS1pZlxuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAtIGxpbmVDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICB0ZXh0T2Zmc2V0ICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3RhdGlvbiAhPT0gMCAmJiAhb3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgICB4ICs9IChsaW5lSGVpZ2h0IC8gMikgKiBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgPSBwaXhlbDtcbiAgICAgICAgdGV4dE9mZnNldCA9ICgxIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgfVxuXG4gICAgICBsZXQgYmFja2Ryb3A7XG5cbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjb25zdCBsYWJlbFBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbGFiZWxTaXplcy5oZWlnaHRzW2ldO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGxhYmVsU2l6ZXMud2lkdGhzW2ldO1xuXG4gICAgICAgIGxldCB0b3AgPSB0ZXh0T2Zmc2V0IC0gbGFiZWxQYWRkaW5nLnRvcDtcbiAgICAgICAgbGV0IGxlZnQgPSAwIC0gbGFiZWxQYWRkaW5nLmxlZnQ7XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2lubmVyJzpcbiAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFja2Ryb3AgPSB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoICsgbGFiZWxQYWRkaW5nLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgbGFiZWxQYWRkaW5nLmhlaWdodCxcblxuICAgICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZvbnQsXG4gICAgICAgIHRleHRPZmZzZXQsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICBzdHJva2VDb2xvcixcbiAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgICB0ZXh0QWxpZ246IHRpY2tUZXh0QWxpZ24sXG4gICAgICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgICAgIHRyYW5zbGF0aW9uOiBbeCwgeV0sXG4gICAgICAgICAgYmFja2Ryb3AsXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIF9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3N9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuXG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG5cbiAgICBsZXQgYWxpZ24gPSAnY2VudGVyJztcblxuICAgIGlmICh0aWNrcy5hbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgIGFsaWduID0gJ3JpZ2h0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICBhbGlnbiA9ICdpbm5lcic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsaWduO1xuICB9XG5cbiAgX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiB7Y3Jvc3NBbGlnbiwgbWlycm9yLCBwYWRkaW5nfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCB3aWRlc3QgPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcblxuICAgIGxldCB0ZXh0QWxpZ247XG4gICAgbGV0IHg7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5yaWdodCArIHBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCArPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0IC0gdGlja0FuZFBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCA9IHRoaXMubGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCAtPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyB0aWNrQW5kUGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSB3aWRlc3QgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCA9IHRoaXMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICByZXR1cm4ge3RleHRBbGlnbiwgeH07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxBcmVhKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGlja3MubWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHJldHVybiB7dG9wOiAwLCBsZWZ0OiB0aGlzLmxlZnQsIGJvdHRvbTogY2hhcnQuaGVpZ2h0LCByaWdodDogdGhpcy5yaWdodH07XG4gICAgfSBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIHt0b3A6IHRoaXMudG9wLCBsZWZ0OiAwLCBib3R0b206IHRoaXMuYm90dG9tLCByaWdodDogY2hhcnQud2lkdGh9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7YmFja2dyb3VuZENvbG9yfSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0fSA9IHRoaXM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TGluZVdpZHRoRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhZ3JpZC5kaXNwbGF5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IGluZGV4ID0gdGlja3MuZmluZEluZGV4KHQgPT4gdC52YWx1ZSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBvcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgcmV0dXJuIG9wdHMubGluZVdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3R3JpZChjaGFydEFyZWEpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9ncmlkTGluZUl0ZW1zIHx8ICh0aGlzLl9ncmlkTGluZUl0ZW1zID0gdGhpcy5fY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBjb25zdCBkcmF3TGluZSA9IChwMSwgcDIsIHN0eWxlKSA9PiB7XG4gICAgICBpZiAoIXN0eWxlLndpZHRoIHx8ICFzdHlsZS5jb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2goc3R5bGUuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0O1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcblxuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChncmlkLmRyYXdPbkNoYXJ0QXJlYSkge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0ueDEsIHk6IGl0ZW0ueTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0ueDIsIHk6IGl0ZW0ueTJ9LFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JpZC5kcmF3VGlja3MpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MSwgeTogaXRlbS50eTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0udHgyLCB5OiBpdGVtLnR5Mn0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbG9yOiBpdGVtLnRpY2tDb2xvcixcbiAgICAgICAgICAgICAgd2lkdGg6IGl0ZW0udGlja1dpZHRoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoOiBpdGVtLnRpY2tCb3JkZXJEYXNoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBpdGVtLnRpY2tCb3JkZXJEYXNoT2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3Qm9yZGVyKCkge1xuICAgIGNvbnN0IHtjaGFydCwgY3R4LCBvcHRpb25zOiB7Ym9yZGVyLCBncmlkfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBib3JkZXIuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gYm9yZGVyLmRpc3BsYXkgPyBib3JkZXJPcHRzLndpZHRoIDogMDtcbiAgICBpZiAoIWF4aXNXaWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0TGluZVdpZHRoID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgwKSkubGluZVdpZHRoO1xuICAgIGNvbnN0IGJvcmRlclZhbHVlID0gdGhpcy5fYm9yZGVyVmFsdWU7XG4gICAgbGV0IHgxLCB4MiwgeTEsIHkyO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHgxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMubGVmdCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB4MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnJpZ2h0LCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeTEgPSB5MiA9IGJvcmRlclZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB5MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnRvcCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB5MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHgxID0geDIgPSBib3JkZXJWYWx1ZTtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyT3B0cy53aWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJPcHRzLmNvbG9yO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3TGFiZWxzKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuXG4gICAgaWYgKCFvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG5cbiAgICBjb25zdCBhcmVhID0gdGhpcy5fY29tcHV0ZUxhYmVsQXJlYSgpO1xuICAgIGlmIChhcmVhKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5nZXRMYWJlbEl0ZW1zKGNoYXJ0QXJlYSk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCByZW5kZXJUZXh0T3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gaXRlbS5mb250O1xuICAgICAgY29uc3QgbGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgY29uc3QgeSA9IGl0ZW0udGV4dE9mZnNldDtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsYWJlbCwgMCwgeSwgdGlja0ZvbnQsIHJlbmRlclRleHRPcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoYXJlYSkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge3Bvc2l0aW9uLCB0aXRsZSwgcmV2ZXJzZX19ID0gdGhpcztcblxuICAgIGlmICghdGl0bGUuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbnQgPSB0b0ZvbnQodGl0bGUuZm9udCk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZS5wYWRkaW5nKTtcbiAgICBjb25zdCBhbGlnbiA9IHRpdGxlLmFsaWduO1xuICAgIGxldCBvZmZzZXQgPSBmb250LmxpbmVIZWlnaHQgLyAyO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBwb3NpdGlvbiA9PT0gJ2NlbnRlcicgfHwgaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy5ib3R0b207XG4gICAgICBpZiAoaXNBcnJheSh0aXRsZS50ZXh0KSkge1xuICAgICAgICBvZmZzZXQgKz0gZm9udC5saW5lSGVpZ2h0ICogKHRpdGxlLnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLnRvcDtcbiAgICB9XG5cbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aXRsZUFyZ3ModGhpcywgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlLnRleHQsIDAsIDAsIGZvbnQsIHtcbiAgICAgIGNvbG9yOiB0aXRsZS5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxuXG4gIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9sYXllcnMoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0eiA9IG9wdHMudGlja3MgJiYgb3B0cy50aWNrcy56IHx8IDA7XG4gICAgY29uc3QgZ3ogPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmdyaWQgJiYgb3B0cy5ncmlkLnosIC0xKTtcbiAgICBjb25zdCBieiA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuYm9yZGVyICYmIG9wdHMuYm9yZGVyLnosIDApO1xuXG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCB0aGlzLmRyYXcgIT09IFNjYWxlLnByb3RvdHlwZS5kcmF3KSB7XG4gICAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBkcmF3IGhhcyBiZWVuIG92ZXJyaWRkZW4gYnkgY3VzdG9tIHNjYWxlXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogdHosXG4gICAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgICB0aGlzLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt7XG4gICAgICB6OiBneixcbiAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgICAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogYnosXG4gICAgICBkcmF3OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IHR6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHZpc2libGUgZGF0YXNldCBtZXRhcyB0aGF0IGFyZSBhdHRhY2hlZCB0byB0aGlzIHNjYWxlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gLSBpZiBzcGVjaWZpZWQsIGFsc28gZmlsdGVyIGJ5IGRhdGFzZXQgdHlwZVxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpIHtcbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGF4aXNJRCA9IHRoaXMuYXhpcyArICdBeGlzSUQnO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgICAgaWYgKG1ldGFbYXhpc0lEXSA9PT0gdGhpcy5pZCAmJiAoIXR5cGUgfHwgbWV0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHJldHVybiB7b2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG4gXHQgKi9cbiAgX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaW5kZXgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgcmV0dXJuIHRvRm9udChvcHRzLmZvbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9tYXhEaWdpdHMoKSB7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLmxpbmVIZWlnaHQ7XG4gICAgcmV0dXJuICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0KSAvIGZvbnRTaXplO1xuICB9XG59XG4iLCAiaW1wb3J0IHttZXJnZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQgZGVmYXVsdHMsIHtvdmVycmlkZXN9IGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tpZDogc3RyaW5nLCBkZWZhdWx0czogYW55LCBvdmVycmlkZXM/OiBhbnksIGRlZmF1bHRSb3V0ZXM6IGFueX19IElDaGFydENvbXBvbmVudFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR5cGVkUmVnaXN0cnkge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBzY29wZSwgb3ZlcnJpZGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5pdGVtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBpc0ZvclR5cGUodHlwZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbCh0aGlzLnR5cGUucHJvdG90eXBlLCB0eXBlLnByb3RvdHlwZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtJQ2hhcnRDb21wb25lbnR9IGl0ZW1cblx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIHNjb3BlIHdoZXJlIGl0ZW1zIGRlZmF1bHRzIHdlcmUgcmVnaXN0ZXJlZCB0by5cblx0ICovXG4gIHJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpdGVtKTtcbiAgICBsZXQgcGFyZW50U2NvcGU7XG5cbiAgICBpZiAoaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIHBhcmVudCBpcyByZWdpc3RlcmVkIGFuZCBub3RlIHRoZSBzY29wZSB3aGVyZSBpdHMgZGVmYXVsdHMgYXJlLlxuICAgICAgcGFyZW50U2NvcGUgPSB0aGlzLnJlZ2lzdGVyKHByb3RvKTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZSArICcuJyArIGlkO1xuXG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGFzcyBkb2VzIG5vdCBoYXZlIGlkOiAnICsgaXRlbSk7XG4gICAgfVxuXG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICAvLyBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG5cbiAgICBpdGVtc1tpZF0gPSBpdGVtO1xuICAgIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgZGVmYXVsdHMub3ZlcnJpZGUoaXRlbS5pZCwgaXRlbS5vdmVycmlkZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBzY29wZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge29iamVjdD99XG5cdCAqL1xuICBnZXQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc1tpZF07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtJQ2hhcnRDb21wb25lbnR9IGl0ZW1cblx0ICovXG4gIHVucmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlO1xuXG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICBkZWxldGUgaXRlbXNbaWRdO1xuICAgIH1cblxuICAgIGlmIChzY29wZSAmJiBpZCBpbiBkZWZhdWx0c1tzY29wZV0pIHtcbiAgICAgIGRlbGV0ZSBkZWZhdWx0c1tzY29wZV1baWRdO1xuICAgICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlc1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRlZmF1bHRzIGFuZCBrZWVwIGV4aXN0aW5nIGRlZmF1bHRzXG4gIGNvbnN0IGl0ZW1EZWZhdWx0cyA9IG1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtcbiAgICBwYXJlbnRTY29wZSA/IGRlZmF1bHRzLmdldChwYXJlbnRTY29wZSkgOiB7fSxcbiAgICBkZWZhdWx0cy5nZXQoc2NvcGUpLFxuICAgIGl0ZW0uZGVmYXVsdHNcbiAgXSk7XG5cbiAgZGVmYXVsdHMuc2V0KHNjb3BlLCBpdGVtRGVmYXVsdHMpO1xuXG4gIGlmIChpdGVtLmRlZmF1bHRSb3V0ZXMpIHtcbiAgICByb3V0ZURlZmF1bHRzKHNjb3BlLCBpdGVtLmRlZmF1bHRSb3V0ZXMpO1xuICB9XG5cbiAgaWYgKGl0ZW0uZGVzY3JpcHRvcnMpIHtcbiAgICBkZWZhdWx0cy5kZXNjcmliZShzY29wZSwgaXRlbS5kZXNjcmlwdG9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcm91dGVEZWZhdWx0cyhzY29wZSwgcm91dGVzKSB7XG4gIE9iamVjdC5rZXlzKHJvdXRlcykuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlQYXJ0cyA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgY29uc3Qgc291cmNlTmFtZSA9IHByb3BlcnR5UGFydHMucG9wKCk7XG4gICAgY29uc3Qgc291cmNlU2NvcGUgPSBbc2NvcGVdLmNvbmNhdChwcm9wZXJ0eVBhcnRzKS5qb2luKCcuJyk7XG4gICAgY29uc3QgcGFydHMgPSByb3V0ZXNbcHJvcGVydHldLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgdGFyZ2V0TmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlID0gcGFydHMuam9pbignLicpO1xuICAgIGRlZmF1bHRzLnJvdXRlKHNvdXJjZVNjb3BlLCBzb3VyY2VOYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0lDaGFydENvbXBvbmVudChwcm90bykge1xuICByZXR1cm4gJ2lkJyBpbiBwcm90byAmJiAnZGVmYXVsdHMnIGluIHByb3RvO1xufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4vY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQgVHlwZWRSZWdpc3RyeSBmcm9tICcuL2NvcmUudHlwZWRSZWdpc3RyeS5qcyc7XG5pbXBvcnQge2VhY2gsIGNhbGxiYWNrIGFzIGNhbGwsIF9jYXBpdGFsaXplfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydGVkIGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29udHJvbGxlcnMgPSBuZXcgVHlwZWRSZWdpc3RyeShEYXRhc2V0Q29udHJvbGxlciwgJ2RhdGFzZXRzJywgdHJ1ZSk7XG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KEVsZW1lbnQsICdlbGVtZW50cycpO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KE9iamVjdCwgJ3BsdWdpbnMnKTtcbiAgICB0aGlzLnNjYWxlcyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KFNjYWxlLCAnc2NhbGVzJyk7XG4gICAgLy8gT3JkZXIgaXMgaW1wb3J0YW50LCBTY2FsZSBoYXMgRWxlbWVudCBpbiBwcm90b3R5cGUgY2hhaW4sXG4gICAgLy8gc28gU2NhbGVzIG11c3QgYmUgYmVmb3JlIEVsZW1lbnRzLiBQbHVnaW5zIGFyZSBhIGZhbGxiYWNrLCBzbyBub3QgbGlzdGVkIGhlcmUuXG4gICAgdGhpcy5fdHlwZWRSZWdpc3RyaWVzID0gW3RoaXMuY29udHJvbGxlcnMsIHRoaXMuc2NhbGVzLCB0aGlzLmVsZW1lbnRzXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0ICovXG4gIGFkZCguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuXG4gIHJlbW92ZSguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn0gYXJnc1xuXHQgKi9cbiAgYWRkQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIEVsZW1lbnR9IGFyZ3Ncblx0ICovXG4gIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgYWRkUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBTY2FsZX0gYXJnc1xuXHQgKi9cbiAgYWRkU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge3R5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn1cblx0ICovXG4gIGdldENvbnRyb2xsZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmNvbnRyb2xsZXJzLCAnY29udHJvbGxlcicpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIEVsZW1lbnR9XG5cdCAqL1xuICBnZXRFbGVtZW50KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5lbGVtZW50cywgJ2VsZW1lbnQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge29iamVjdH1cblx0ICovXG4gIGdldFBsdWdpbihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMucGx1Z2lucywgJ3BsdWdpbicpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIFNjYWxlfVxuXHQgKi9cbiAgZ2V0U2NhbGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnNjYWxlcywgJ3NjYWxlJyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIERhdGFzZXRDb250cm9sbGVyfSBhcmdzXG5cdCAqL1xuICByZW1vdmVDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBFbGVtZW50fSBhcmdzXG5cdCAqL1xuICByZW1vdmVFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIFNjYWxlfSBhcmdzXG5cdCAqL1xuICByZW1vdmVTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9lYWNoKG1ldGhvZCwgYXJncywgdHlwZWRSZWdpc3RyeSkge1xuICAgIFsuLi5hcmdzXS5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICBjb25zdCByZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShhcmcpO1xuICAgICAgaWYgKHR5cGVkUmVnaXN0cnkgfHwgcmVnLmlzRm9yVHlwZShhcmcpIHx8IChyZWcgPT09IHRoaXMucGx1Z2lucyAmJiBhcmcuaWQpKSB7XG4gICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCByZWcsIGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYW5kbGUgbG9vcGFibGUgYXJnc1xuICAgICAgICAvLyBVc2UgY2FzZTpcbiAgICAgICAgLy8gIGltcG9ydCAqIGFzIHBsdWdpbnMgZnJvbSAnLi9wbHVnaW5zLmpzJztcbiAgICAgICAgLy8gIENoYXJ0LnJlZ2lzdGVyKHBsdWdpbnMpO1xuICAgICAgICBlYWNoKGFyZywgaXRlbSA9PiB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1peGVkIHR5cGVzIGluIHRoZSBsb29wYWJsZSwgbWFrZSBzdXJlIHRob3NlIGFyZVxuICAgICAgICAgIC8vIHJlZ2lzdGVyZWQgaW4gY29ycmVjdCByZWdpc3RyeVxuICAgICAgICAgIC8vIFVzZSBjYXNlOiAodHJlZW1hcCBleHBvcnRpbmcgY29udHJvbGxlciwgZWxlbWVudHMgZXRjKVxuICAgICAgICAgIC8vICBpbXBvcnQgKiBhcyB0cmVlbWFwIGZyb20gJ2NoYXJ0anMtY2hhcnQtdHJlZW1hcC5qcyc7XG4gICAgICAgICAgLy8gIENoYXJ0LnJlZ2lzdGVyKHRyZWVtYXApO1xuXG4gICAgICAgICAgY29uc3QgaXRlbVJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGl0ZW0pO1xuICAgICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCBpdGVtUmVnLCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9leGVjKG1ldGhvZCwgcmVnaXN0cnksIGNvbXBvbmVudCkge1xuICAgIGNvbnN0IGNhbWVsTWV0aG9kID0gX2NhcGl0YWxpemUobWV0aG9kKTtcbiAgICBjYWxsKGNvbXBvbmVudFsnYmVmb3JlJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7IC8vIGJlZm9yZVJlZ2lzdGVyIC8gYmVmb3JlVW5yZWdpc3RlclxuICAgIHJlZ2lzdHJ5W21ldGhvZF0oY29tcG9uZW50KTtcbiAgICBjYWxsKGNvbXBvbmVudFsnYWZ0ZXInICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTsgLy8gYWZ0ZXJSZWdpc3RlciAvIGFmdGVyVW5yZWdpc3RlclxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmVnaXN0cnlGb3JUeXBlKHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3R5cGVkUmVnaXN0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVnID0gdGhpcy5fdHlwZWRSZWdpc3RyaWVzW2ldO1xuICAgICAgaWYgKHJlZy5pc0ZvclR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlZztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcGx1Z2lucyBpcyB0aGUgZmFsbGJhY2sgcmVnaXN0cnlcbiAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0KGlkLCB0eXBlZFJlZ2lzdHJ5LCB0eXBlKSB7XG4gICAgY29uc3QgaXRlbSA9IHR5cGVkUmVnaXN0cnkuZ2V0KGlkKTtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGlkICsgJ1wiIGlzIG5vdCBhIHJlZ2lzdGVyZWQgJyArIHR5cGUgKyAnLicpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG59XG5cbi8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGRlZmF1bHQgLyogI19fUFVSRV9fICovIG5ldyBSZWdpc3RyeSgpO1xuIiwgImltcG9ydCByZWdpc3RyeSBmcm9tICcuL2NvcmUucmVnaXN0cnkuanMnO1xuaW1wb3J0IHtjYWxsYmFjayBhcyBjYWxsQ2FsbGJhY2ssIGlzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3BsdWdpbnMvcGx1Z2luLnRvb2x0aXAuanMnKS5kZWZhdWx0IH0gVG9vbHRpcFxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGZpbHRlckNhbGxiYWNrXG4gKiBAcGFyYW0ge3twbHVnaW46IG9iamVjdCwgb3B0aW9uczogb2JqZWN0fX0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdXG4gKiBAcGFyYW0ge2FycmF5fSBbYXJyYXldXG4gKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGx1Z2luU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXQgPSBbXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDYWxscyBlbmFibGVkIHBsdWdpbnMgZm9yIGBjaGFydGAgb24gdGhlIHNwZWNpZmllZCBob29rIGFuZCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHQgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFzIHNvb24gYXMgYSBwbHVnaW4gZXhwbGljaXRseSByZXR1cm5zIGZhbHNlLiBUaGVcblx0ICogcmV0dXJuZWQgdmFsdWUgY2FuIGJlIHVzZWQsIGZvciBpbnN0YW5jZSwgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IGFjdGlvbi5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UgZm9yIHdoaWNoIHBsdWdpbnMgc2hvdWxkIGJlIGNhbGxlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvb2sgLSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIG1ldGhvZCB0byBjYWxsIChlLmcuICdiZWZvcmVVcGRhdGUnKS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFthcmdzXSAtIEV4dHJhIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgaG9vayBjYWxsLlxuICAgKiBAcGFyYW0ge2ZpbHRlckNhbGxiYWNrfSBbZmlsdGVyXSAtIEZpbHRlcmluZyBmdW5jdGlvbiBmb3IgbGltaXRpbmcgd2hpY2ggcGx1Z2lucyBhcmUgbm90aWZpZWRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHQgKi9cbiAgbm90aWZ5KGNoYXJ0LCBob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICBpZiAoaG9vayA9PT0gJ2JlZm9yZUluaXQnKSB7XG4gICAgICB0aGlzLl9pbml0ID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHRydWUpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAnaW5zdGFsbCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gZmlsdGVyID8gdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpLmZpbHRlcihmaWx0ZXIpIDogdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpO1xuXG4gICAgaWYgKGhvb2sgPT09ICdhZnRlckRlc3Ryb3knKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCAnc3RvcCcpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAndW5pbnN0YWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKSB7XG4gICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHBsdWdpbltob29rXTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtjaGFydCwgYXJncywgZGVzY3JpcHRvci5vcHRpb25zXTtcbiAgICAgIGlmIChjYWxsQ2FsbGJhY2sobWV0aG9kLCBwYXJhbXMsIHBsdWdpbikgPT09IGZhbHNlICYmIGFyZ3MuY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbnZhbGlkYXRlKCkge1xuICAgIC8vIFdoZW4gcGx1Z2lucyBhcmUgcmVnaXN0ZXJlZCwgdGhlcmUgaXMgdGhlIHBvc3NpYmlsaXR5IG9mIGEgZG91YmxlXG4gICAgLy8gaW52YWxpZGF0ZSBzaXR1YXRpb24uIEluIHRoaXMgY2FzZSwgd2Ugb25seSB3YW50IHRvIGludmFsaWRhdGUgb25jZS5cbiAgICAvLyBJZiB3ZSBpbnZhbGlkYXRlIG11bHRpcGxlIHRpbWVzLCB0aGUgYF9vbGRDYWNoZWAgaXMgbG9zdCBhbmQgYWxsIG9mIHRoZVxuICAgIC8vIHBsdWdpbnMgYXJlIHJlc3RhcnRlZCB3aXRob3V0IGJlaW5nIGNvcnJlY3RseSBzdG9wcGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvODE0N1xuICAgIGlmICghaXNOdWxsT3JVbmRlZih0aGlzLl9jYWNoZSkpIHtcbiAgICAgIHRoaXMuX29sZENhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICB0aGlzLl9jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kZXNjcmlwdG9ycyhjaGFydCkge1xuICAgIGlmICh0aGlzLl9jYWNoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgIH1cblxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGUgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCk7XG5cbiAgICB0aGlzLl9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9XG5cbiAgX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBhbGwpIHtcbiAgICBjb25zdCBjb25maWcgPSBjaGFydCAmJiBjaGFydC5jb25maWc7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZhbHVlT3JEZWZhdWx0KGNvbmZpZy5vcHRpb25zICYmIGNvbmZpZy5vcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgICBjb25zdCBwbHVnaW5zID0gYWxsUGx1Z2lucyhjb25maWcpO1xuICAgIC8vIG9wdGlvbnMgPT09IGZhbHNlID0+IGFsbCBwbHVnaW5zIGFyZSBkaXNhYmxlZFxuICAgIHJldHVybiBvcHRpb25zID09PSBmYWxzZSAmJiAhYWxsID8gW10gOiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgcGx1Z2lucywgb3B0aW9ucywgYWxsKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCkge1xuICAgIGNvbnN0IHByZXZpb3VzRGVzY3JpcHRvcnMgPSB0aGlzLl9vbGRDYWNoZSB8fCBbXTtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5wbHVnaW4uaWQgPT09IHkucGx1Z2luLmlkKSk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYocHJldmlvdXNEZXNjcmlwdG9ycywgZGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0b3AnKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihkZXNjcmlwdG9ycywgcHJldmlvdXNEZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RhcnQnKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUuY29uZmlnLmpzJykuZGVmYXVsdH0gY29uZmlnXG4gKi9cbmZ1bmN0aW9uIGFsbFBsdWdpbnMoY29uZmlnKSB7XG4gIGNvbnN0IGxvY2FsSWRzID0ge307XG4gIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnBsdWdpbnMuaXRlbXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBwbHVnaW5zLnB1c2gocmVnaXN0cnkuZ2V0UGx1Z2luKGtleXNbaV0pKTtcbiAgfVxuXG4gIGNvbnN0IGxvY2FsID0gY29uZmlnLnBsdWdpbnMgfHwgW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwbHVnaW4gPSBsb2NhbFtpXTtcblxuICAgIGlmIChwbHVnaW5zLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcbiAgICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgbG9jYWxJZHNbcGx1Z2luLmlkXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtwbHVnaW5zLCBsb2NhbElkc307XG59XG5cbmZ1bmN0aW9uIGdldE9wdHMob3B0aW9ucywgYWxsKSB7XG4gIGlmICghYWxsICYmIG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB7cGx1Z2lucywgbG9jYWxJZHN9LCBvcHRpb25zLCBhbGwpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBjaGFydC5nZXRDb250ZXh0KCk7XG5cbiAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IG9wdHMgPSBnZXRPcHRzKG9wdGlvbnNbaWRdLCBhbGwpO1xuICAgIGlmIChvcHRzID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgcGx1Z2luLFxuICAgICAgb3B0aW9uczogcGx1Z2luT3B0cyhjaGFydC5jb25maWcsIHtwbHVnaW4sIGxvY2FsOiBsb2NhbElkc1tpZF19LCBvcHRzLCBjb250ZXh0KVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGx1Z2luT3B0cyhjb25maWcsIHtwbHVnaW4sIGxvY2FsfSwgb3B0cywgY29udGV4dCkge1xuICBjb25zdCBrZXlzID0gY29uZmlnLnBsdWdpblNjb3BlS2V5cyhwbHVnaW4pO1xuICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKG9wdHMsIGtleXMpO1xuICBpZiAobG9jYWwgJiYgcGx1Z2luLmRlZmF1bHRzKSB7XG4gICAgLy8gbWFrZSBzdXJlIHBsdWdpbiBkZWZhdWx0cyBhcmUgaW4gc2NvcGVzIGZvciBsb2NhbCAobm90IHJlZ2lzdGVyZWQpIHBsdWdpbnNcbiAgICBzY29wZXMucHVzaChwbHVnaW4uZGVmYXVsdHMpO1xuICB9XG4gIHJldHVybiBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBbJyddLCB7XG4gICAgLy8gVGhlc2UgYXJlIGp1c3QgZGVmYXVsdHMgdGhhdCBwbHVnaW5zIGNhbiBvdmVycmlkZVxuICAgIHNjcmlwdGFibGU6IGZhbHNlLFxuICAgIGluZGV4YWJsZTogZmFsc2UsXG4gICAgYWxsS2V5czogdHJ1ZVxuICB9KTtcbn1cbiIsICJpbXBvcnQgZGVmYXVsdHMsIHtvdmVycmlkZXMsIGRlc2NyaXB0b3JzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHttZXJnZUlmLCByZXNvbHZlT2JqZWN0S2V5LCBpc0FycmF5LCBpc0Z1bmN0aW9uLCB2YWx1ZU9yRGVmYXVsdCwgaXNPYmplY3R9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7X2F0dGFjaENvbnRleHQsIF9jcmVhdGVSZXNvbHZlciwgX2Rlc2NyaXB0b3JzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29uZmlnLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRhdGFzZXREZWZhdWx0cyA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9O1xuICBjb25zdCBkYXRhc2V0T3B0aW9ucyA9IChvcHRpb25zLmRhdGFzZXRzIHx8IHt9KVt0eXBlXSB8fCB7fTtcbiAgcmV0dXJuIGRhdGFzZXRPcHRpb25zLmluZGV4QXhpcyB8fCBvcHRpb25zLmluZGV4QXhpcyB8fCBkYXRhc2V0RGVmYXVsdHMuaW5kZXhBeGlzIHx8ICd4Jztcbn1cblxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChpZCwgaW5kZXhBeGlzKSB7XG4gIGxldCBheGlzID0gaWQ7XG4gIGlmIChpZCA9PT0gJ19pbmRleF8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcztcbiAgfSBlbHNlIGlmIChpZCA9PT0gJ192YWx1ZV8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICB9XG4gIHJldHVybiBheGlzO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGluZGV4QXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gaW5kZXhBeGlzID8gJ19pbmRleF8nIDogJ192YWx1ZV8nO1xufVxuXG5mdW5jdGlvbiBpZE1hdGNoZXNBeGlzKGlkKSB7XG4gIGlmIChpZCA9PT0gJ3gnIHx8IGlkID09PSAneScgfHwgaWQgPT09ICdyJykge1xuICAgIHJldHVybiBpZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBheGlzRnJvbVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgcmV0dXJuICd4JztcbiAgfVxuICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHJldHVybiAneSc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZUF4aXMoaWQsIC4uLnNjYWxlT3B0aW9ucykge1xuICBpZiAoaWRNYXRjaGVzQXhpcyhpZCkpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgZm9yIChjb25zdCBvcHRzIG9mIHNjYWxlT3B0aW9ucykge1xuICAgIGNvbnN0IGF4aXMgPSBvcHRzLmF4aXNcbiAgICAgIHx8IGF4aXNGcm9tUG9zaXRpb24ob3B0cy5wb3NpdGlvbilcbiAgICAgIHx8IGlkLmxlbmd0aCA+IDEgJiYgaWRNYXRjaGVzQXhpcyhpZFswXS50b0xvd2VyQ2FzZSgpKTtcbiAgICBpZiAoYXhpcykge1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRldGVybWluZSB0eXBlIG9mICcke2lkfScgYXhpcy4gUGxlYXNlIHByb3ZpZGUgJ2F4aXMnIG9yICdwb3NpdGlvbicgb3B0aW9uLmApO1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzRnJvbURhdGFzZXQoaWQsIGF4aXMsIGRhdGFzZXQpIHtcbiAgaWYgKGRhdGFzZXRbYXhpcyArICdBeGlzSUQnXSA9PT0gaWQpIHtcbiAgICByZXR1cm4ge2F4aXN9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJpZXZlQXhpc0Zyb21EYXRhc2V0cyhpZCwgY29uZmlnKSB7XG4gIGlmIChjb25maWcuZGF0YSAmJiBjb25maWcuZGF0YS5kYXRhc2V0cykge1xuICAgIGNvbnN0IGJvdW5kRHMgPSBjb25maWcuZGF0YS5kYXRhc2V0cy5maWx0ZXIoKGQpID0+IGQueEF4aXNJRCA9PT0gaWQgfHwgZC55QXhpc0lEID09PSBpZCk7XG4gICAgaWYgKGJvdW5kRHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZ2V0QXhpc0Zyb21EYXRhc2V0KGlkLCAneCcsIGJvdW5kRHNbMF0pIHx8IGdldEF4aXNGcm9tRGF0YXNldChpZCwgJ3knLCBib3VuZERzWzBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucykge1xuICBjb25zdCBjaGFydERlZmF1bHRzID0gb3ZlcnJpZGVzW2NvbmZpZy50eXBlXSB8fCB7c2NhbGVzOiB7fX07XG4gIGNvbnN0IGNvbmZpZ1NjYWxlcyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuICBjb25zdCBjaGFydEluZGV4QXhpcyA9IGdldEluZGV4QXhpcyhjb25maWcudHlwZSwgb3B0aW9ucyk7XG4gIGNvbnN0IHNjYWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gRmlyc3QgZmlndXJlIG91dCBmaXJzdCBzY2FsZSBpZCdzIHBlciBheGlzLlxuICBPYmplY3Qua2V5cyhjb25maWdTY2FsZXMpLmZvckVhY2goaWQgPT4ge1xuICAgIGNvbnN0IHNjYWxlQ29uZiA9IGNvbmZpZ1NjYWxlc1tpZF07XG4gICAgaWYgKCFpc09iamVjdChzY2FsZUNvbmYpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgSW52YWxpZCBzY2FsZSBjb25maWd1cmF0aW9uIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgaWYgKHNjYWxlQ29uZi5fcHJveHkpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYElnbm9yaW5nIHJlc29sdmVyIHBhc3NlZCBhcyBvcHRpb25zIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlQ29uZiwgcmV0cmlldmVBeGlzRnJvbURhdGFzZXRzKGlkLCBjb25maWcpLCBkZWZhdWx0cy5zY2FsZXNbc2NhbGVDb25mLnR5cGVdKTtcbiAgICBjb25zdCBkZWZhdWx0SWQgPSBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGNoYXJ0SW5kZXhBeGlzKTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gY2hhcnREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgc2NhbGVzW2lkXSA9IG1lcmdlSWYoT2JqZWN0LmNyZWF0ZShudWxsKSwgW3theGlzfSwgc2NhbGVDb25mLCBkZWZhdWx0U2NhbGVPcHRpb25zW2F4aXNdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJZF1dKTtcbiAgfSk7XG5cbiAgLy8gVGhlbiBtZXJnZSBkYXRhc2V0IGRlZmF1bHRzIHRvIHNjYWxlIGNvbmZpZ3NcbiAgY29uZmlnLmRhdGEuZGF0YXNldHMuZm9yRWFjaChkYXRhc2V0ID0+IHtcbiAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IGNvbmZpZy50eXBlO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKTtcbiAgICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBvdmVycmlkZXNbdHlwZV0gfHwge307XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGRhdGFzZXREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgT2JqZWN0LmtleXMoZGVmYXVsdFNjYWxlT3B0aW9ucykuZm9yRWFjaChkZWZhdWx0SUQgPT4ge1xuICAgICAgY29uc3QgYXhpcyA9IGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoZGVmYXVsdElELCBpbmRleEF4aXMpO1xuICAgICAgY29uc3QgaWQgPSBkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gfHwgYXhpcztcbiAgICAgIHNjYWxlc1tpZF0gPSBzY2FsZXNbaWRdIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBtZXJnZUlmKHNjYWxlc1tpZF0sIFt7YXhpc30sIGNvbmZpZ1NjYWxlc1tpZF0sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElEXV0pO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBhcHBseSBzY2FsZSBkZWZhdWx0cywgaWYgbm90IG92ZXJyaWRkZW4gYnkgZGF0YXNldCBkZWZhdWx0c1xuICBPYmplY3Qua2V5cyhzY2FsZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCBzY2FsZSA9IHNjYWxlc1trZXldO1xuICAgIG1lcmdlSWYoc2NhbGUsIFtkZWZhdWx0cy5zY2FsZXNbc2NhbGUudHlwZV0sIGRlZmF1bHRzLnNjYWxlXSk7XG4gIH0pO1xuXG4gIHJldHVybiBzY2FsZXM7XG59XG5cbmZ1bmN0aW9uIGluaXRPcHRpb25zKGNvbmZpZykge1xuICBjb25zdCBvcHRpb25zID0gY29uZmlnLm9wdGlvbnMgfHwgKGNvbmZpZy5vcHRpb25zID0ge30pO1xuXG4gIG9wdGlvbnMucGx1Z2lucyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMucGx1Z2lucywge30pO1xuICBvcHRpb25zLnNjYWxlcyA9IG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEoZGF0YSkge1xuICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgZGF0YS5kYXRhc2V0cyA9IGRhdGEuZGF0YXNldHMgfHwgW107XG4gIGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIGNvbmZpZy5kYXRhID0gaW5pdERhdGEoY29uZmlnLmRhdGEpO1xuXG4gIGluaXRPcHRpb25zKGNvbmZpZyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cblxuY29uc3Qga2V5Q2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBrZXlzQ2FjaGVkID0gbmV3IFNldCgpO1xuXG5mdW5jdGlvbiBjYWNoZWRLZXlzKGNhY2hlS2V5LCBnZW5lcmF0ZSkge1xuICBsZXQga2V5cyA9IGtleUNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICgha2V5cykge1xuICAgIGtleXMgPSBnZW5lcmF0ZSgpO1xuICAgIGtleUNhY2hlLnNldChjYWNoZUtleSwga2V5cyk7XG4gICAga2V5c0NhY2hlZC5hZGQoa2V5cyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmNvbnN0IGFkZElmRm91bmQgPSAoc2V0LCBvYmosIGtleSkgPT4ge1xuICBjb25zdCBvcHRzID0gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSk7XG4gIGlmIChvcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXQuYWRkKG9wdHMpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25maWcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgPSBpbml0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fc2NvcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgZ2V0IHBsYXRmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGxhdGZvcm07XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnR5cGU7XG4gIH1cblxuICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgdGhpcy5fY29uZmlnLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5kYXRhO1xuICB9XG5cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuX2NvbmZpZy5kYXRhID0gaW5pdERhdGEoZGF0YSk7XG4gIH1cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLm9wdGlvbnM7XG4gIH1cblxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5fY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbHVnaW5zO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX2NvbmZpZztcbiAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICBpbml0T3B0aW9ucyhjb25maWcpO1xuICB9XG5cbiAgY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLl9zY29wZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbiBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgZGF0YXNldCBvcHRpb25zLlxuICAgKiBUaGVzZSBrZXlzIGRvIG5vdCBpbmNsdWRlIHRoZSBkYXRhc2V0IGl0c2VsZiwgYmVjYXVzZSBpdCBpcyBub3QgdW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFzZXRUeXBlXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdW119XG4gICAqL1xuICBkYXRhc2V0U2NvcGVLZXlzKGRhdGFzZXRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoZGF0YXNldFR5cGUsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbiBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgZGF0YXNldCBhbmltYXRpb24gb3B0aW9ucy5cbiAgICogVGhlc2Uga2V5cyBkbyBub3QgaW5jbHVkZSB0aGUgZGF0YXNldCBpdHNlbGYsIGJlY2F1c2UgaXQgaXMgbm90IHVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0VHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNpdGlvblxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgdHJhbnNpdGlvbikge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9uLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgKCkgPT4gW1xuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICAgIGB0cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgXSxcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmUgdXNlZCBmb3IgbG9va2luZyB1cCB0aGUgYGFuaW1hdGlvbnNgIGFuZCBgYW5pbWF0aW9uYCBrZXlzXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAgICcnXG4gICAgICAgIF1cbiAgICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbnMgc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIGVsZW1lbnQgb3B0aW9ucyB0aGF0IGJlbG9uZ1xuICAgKiB0byBhbiBkYXRhc2V0LiBUaGVzZSBrZXlzIGRvIG5vdCBpbmNsdWRlIHRoZSBkYXRhc2V0IGl0c2VsZiwgYmVjYXVzZSBpdFxuICAgKiBpcyBub3QgdW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFzZXRUeXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50VHlwZVxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZGF0YXNldEVsZW1lbnRTY29wZUtleXMoZGF0YXNldFR5cGUsIGVsZW1lbnRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LSR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS5lbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgIGBlbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgICcnXG4gICAgICBdXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9ucyBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgcGx1Z2luIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7e2lkOiBzdHJpbmcsIGFkZGl0aW9uYWxPcHRpb25TY29wZXM/OiBzdHJpbmdbXX19IHBsdWdpblxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgcGx1Z2luU2NvcGVLZXlzKHBsdWdpbikge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7dHlwZX0tcGx1Z2luLSR7aWR9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBwbHVnaW5zLiR7aWR9YCxcbiAgICAgICAgLi4ucGx1Z2luLmFkZGl0aW9uYWxPcHRpb25TY29wZXMgfHwgW10sXG4gICAgICBdXSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKSB7XG4gICAgY29uc3QgX3Njb3BlQ2FjaGUgPSB0aGlzLl9zY29wZUNhY2hlO1xuICAgIGxldCBjYWNoZSA9IF9zY29wZUNhY2hlLmdldChtYWluU2NvcGUpO1xuICAgIGlmICghY2FjaGUgfHwgcmVzZXRDYWNoZSkge1xuICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICBfc2NvcGVDYWNoZS5zZXQobWFpblNjb3BlLCBjYWNoZSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgb2JqZWN0cyBmcm9tIG9wdGlvbnMgYW5kIGRlZmF1bHRzIGZvciBvcHRpb24gdmFsdWUgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtvYmplY3R9IG1haW5TY29wZSAtIFRoZSBtYWluIHNjb3BlIG9iamVjdCBmb3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdW119IGtleUxpc3RzIC0gVGhlIGFycmF5cyBvZiBrZXlzIGluIHJlc29sdXRpb24gb3JkZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVzZXRDYWNoZV0gLSByZXNldCB0aGUgY2FjaGUgZm9yIHRoaXMgbWFpblNjb3BlXG4gICAqL1xuICBnZXRPcHRpb25TY29wZXMobWFpblNjb3BlLCBrZXlMaXN0cywgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5TGlzdHMpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NvcGVzID0gbmV3IFNldCgpO1xuXG4gICAga2V5TGlzdHMuZm9yRWFjaChrZXlzID0+IHtcbiAgICAgIGlmIChtYWluU2NvcGUpIHtcbiAgICAgICAgc2NvcGVzLmFkZChtYWluU2NvcGUpO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBtYWluU2NvcGUsIGtleSkpO1xuICAgICAgfVxuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3B0aW9ucywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvdmVycmlkZXNbdHlwZV0gfHwge30sIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVmYXVsdHMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVzY3JpcHRvcnMsIGtleSkpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5mcm9tKHNjb3Blcyk7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXJyYXkucHVzaChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICB9XG4gICAgaWYgKGtleXNDYWNoZWQuaGFzKGtleUxpc3RzKSkge1xuICAgICAgY2FjaGUuc2V0KGtleUxpc3RzLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb24gc2NvcGVzIGZvciByZXNvbHZpbmcgY2hhcnQgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAgICovXG4gIGNoYXJ0T3B0aW9uU2NvcGVzKCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG5cbiAgICByZXR1cm4gW1xuICAgICAgb3B0aW9ucyxcbiAgICAgIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSxcbiAgICAgIGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9LCAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvODUzMVxuICAgICAge3R5cGV9LFxuICAgICAgZGVmYXVsdHMsXG4gICAgICBkZXNjcmlwdG9yc1xuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3RbXX0gc2NvcGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IG5hbWVzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFtwcmVmaXhlc11cbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKi9cbiAgcmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10pIHtcbiAgICBjb25zdCByZXN1bHQgPSB7JHNoYXJlZDogdHJ1ZX07XG4gICAgY29uc3Qge3Jlc29sdmVyLCBzdWJQcmVmaXhlc30gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICBsZXQgb3B0aW9ucyA9IHJlc29sdmVyO1xuICAgIGlmIChuZWVkQ29udGV4dChyZXNvbHZlciwgbmFtZXMpKSB7XG4gICAgICByZXN1bHQuJHNoYXJlZCA9IGZhbHNlO1xuICAgICAgY29udGV4dCA9IGlzRnVuY3Rpb24oY29udGV4dCkgPyBjb250ZXh0KCkgOiBjb250ZXh0O1xuICAgICAgLy8gc3ViUmVzb2x2ZXIgaXMgcGFzc2VkIHRvIHNjcmlwdGFibGUgb3B0aW9ucy4gSXQgc2hvdWxkIG5vdCByZXNvbHZlIHRvIGhvdmVyIG9wdGlvbnMuXG4gICAgICBjb25zdCBzdWJSZXNvbHZlciA9IHRoaXMuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBzdWJQcmVmaXhlcyk7XG4gICAgICBvcHRpb25zID0gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHN1YlJlc29sdmVyKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3RbXX0gc2NvcGVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3ByZWZpeGVzXVxuICAgKiBAcGFyYW0ge3tzY3JpcHRhYmxlOiBib29sZWFuLCBpbmRleGFibGU6IGJvb2xlYW4sIGFsbEtleXM/OiBib29sZWFufX0gW2Rlc2NyaXB0b3JEZWZhdWx0c11cbiAgICovXG4gIGNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddLCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcbiAgICBjb25zdCB7cmVzb2x2ZXJ9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbnRleHQpXG4gICAgICA/IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCB1bmRlZmluZWQsIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgICAgIDogcmVzb2x2ZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVzb2x2ZXIocmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcykge1xuICBsZXQgY2FjaGUgPSByZXNvbHZlckNhY2hlLmdldChzY29wZXMpO1xuICBpZiAoIWNhY2hlKSB7XG4gICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgcmVzb2x2ZXJDYWNoZS5zZXQoc2NvcGVzLCBjYWNoZSk7XG4gIH1cbiAgY29uc3QgY2FjaGVLZXkgPSBwcmVmaXhlcy5qb2luKCk7XG4gIGxldCBjYWNoZWQgPSBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWNhY2hlZCkge1xuICAgIGNvbnN0IHJlc29sdmVyID0gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGNhY2hlZCA9IHtcbiAgICAgIHJlc29sdmVyLFxuICAgICAgc3ViUHJlZml4ZXM6IHByZWZpeGVzLmZpbHRlcihwID0+ICFwLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2hvdmVyJykpXG4gICAgfTtcbiAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGNhY2hlZCk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlZDtcbn1cblxuY29uc3QgaGFzRnVuY3Rpb24gPSB2YWx1ZSA9PiBpc09iamVjdCh2YWx1ZSlcbiAgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLnNvbWUoKGtleSkgPT4gaXNGdW5jdGlvbih2YWx1ZVtrZXldKSk7XG5cbmZ1bmN0aW9uIG5lZWRDb250ZXh0KHByb3h5LCBuYW1lcykge1xuICBjb25zdCB7aXNTY3JpcHRhYmxlLCBpc0luZGV4YWJsZX0gPSBfZGVzY3JpcHRvcnMocHJveHkpO1xuXG4gIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgIGNvbnN0IHNjcmlwdGFibGUgPSBpc1NjcmlwdGFibGUocHJvcCk7XG4gICAgY29uc3QgaW5kZXhhYmxlID0gaXNJbmRleGFibGUocHJvcCk7XG4gICAgY29uc3QgdmFsdWUgPSAoaW5kZXhhYmxlIHx8IHNjcmlwdGFibGUpICYmIHByb3h5W3Byb3BdO1xuICAgIGlmICgoc2NyaXB0YWJsZSAmJiAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaGFzRnVuY3Rpb24odmFsdWUpKSlcbiAgICAgIHx8IChpbmRleGFibGUgJiYgaXNBcnJheSh2YWx1ZSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwgImltcG9ydCBhbmltYXRvciBmcm9tICcuL2NvcmUuYW5pbWF0b3IuanMnO1xuaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uIGZyb20gJy4vY29yZS5pbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge19kZXRlY3RQbGF0Zm9ybX0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IFBsdWdpblNlcnZpY2UgZnJvbSAnLi9jb3JlLnBsdWdpbnMuanMnO1xuaW1wb3J0IHJlZ2lzdHJ5IGZyb20gJy4vY29yZS5yZWdpc3RyeS5qcyc7XG5pbXBvcnQgQ29uZmlnLCB7ZGV0ZXJtaW5lQXhpcywgZ2V0SW5kZXhBeGlzfSBmcm9tICcuL2NvcmUuY29uZmlnLmpzJztcbmltcG9ydCB7cmV0aW5hU2NhbGUsIF9pc0RvbVN1cHBvcnRlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge2VhY2gsIGNhbGxiYWNrIGFzIGNhbGxDYWxsYmFjaywgdWlkLCB2YWx1ZU9yRGVmYXVsdCwgX2VsZW1lbnRzRXF1YWwsIGlzTnVsbE9yVW5kZWYsIHNldHNFcXVhbCwgZGVmaW5lZCwgaXNGdW5jdGlvbiwgX2lzQ2xpY2tFdmVudH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtjbGVhckNhbnZhcywgY2xpcEFyZWEsIGNyZWF0ZUNvbnRleHQsIHVuY2xpcEFyZWEsIF9pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7dmVyc2lvbn0gZnJvbSAnLi4vLi4vcGFja2FnZS5qc29uJztcbmltcG9ydCB7ZGVib3VuY2V9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5Qb2ludCB9IFBvaW50XG4gKi9cblxuY29uc3QgS05PV05fUE9TSVRJT05TID0gWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnLCAnY2hhcnRBcmVhJ107XG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbiwgYXhpcykge1xuICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCAoS05PV05fUE9TSVRJT05TLmluZGV4T2YocG9zaXRpb24pID09PSAtMSAmJiBheGlzID09PSAneCcpO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlMkxldmVsKGwxLCBsMikge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhW2wxXSA9PT0gYltsMV1cbiAgICAgID8gYVtsMl0gLSBiW2wyXVxuICAgICAgOiBhW2wxXSAtIGJbbDFdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbkFuaW1hdGlvbnNDb21wbGV0ZShjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuXG4gIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyUmVuZGVyJyk7XG4gIGNhbGxDYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Db21wbGV0ZSwgW2NvbnRleHRdLCBjaGFydCk7XG59XG5cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uUHJvZ3Jlc3MoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgY2FsbENhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cblxuLyoqXG4gKiBDaGFydC5qcyBjYW4gdGFrZSBhIHN0cmluZyBpZCBvZiBhIGNhbnZhcyBlbGVtZW50LCBhIDJkIGNvbnRleHQsIG9yIGEgY2FudmFzIGVsZW1lbnQgaXRzZWxmLlxuICogQXR0ZW1wdCB0byB1bndyYXAgdGhlIGl0ZW0gcGFzc2VkIGludG8gdGhlIGNoYXJ0IGNvbnN0cnVjdG9yIHNvIHRoYXQgaXQgaXMgYSBjYW52YXMgZWxlbWVudCAoaWYgcG9zc2libGUpLlxuICovXG5mdW5jdGlvbiBnZXRDYW52YXMoaXRlbSkge1xuICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkgJiYgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaXRlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGl0ZW0pO1xuICB9IGVsc2UgaWYgKGl0ZW0gJiYgaXRlbS5sZW5ndGgpIHtcbiAgICAvLyBTdXBwb3J0IGZvciBhcnJheSBiYXNlZCBxdWVyaWVzIChzdWNoIGFzIGpRdWVyeSlcbiAgICBpdGVtID0gaXRlbVswXTtcbiAgfVxuXG4gIGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG4gICAgLy8gU3VwcG9ydCBmb3IgYW55IG9iamVjdCBhc3NvY2lhdGVkIHRvIGEgY2FudmFzIChpbmNsdWRpbmcgYSBjb250ZXh0MmQpXG4gICAgaXRlbSA9IGl0ZW0uY2FudmFzO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuXG5jb25zdCBpbnN0YW5jZXMgPSB7fTtcbmNvbnN0IGdldENoYXJ0ID0gKGtleSkgPT4ge1xuICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoa2V5KTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaW5zdGFuY2VzKS5maWx0ZXIoKGMpID0+IGMuY2FudmFzID09PSBjYW52YXMpLnBvcCgpO1xufTtcblxuZnVuY3Rpb24gbW92ZU51bWVyaWNLZXlzKG9iaiwgc3RhcnQsIG1vdmUpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBpbnRLZXkgPSAra2V5O1xuICAgIGlmIChpbnRLZXkgPj0gc3RhcnQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICBpZiAobW92ZSA+IDAgfHwgaW50S2V5ID4gc3RhcnQpIHtcbiAgICAgICAgb2JqW2ludEtleSArIG1vdmVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGFydEV2ZW50fSBlXG4gKiBAcGFyYW0ge0NoYXJ0RXZlbnR8bnVsbH0gbGFzdEV2ZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluQ2hhcnRBcmVhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzQ2xpY2tcbiAqIEByZXR1cm5zIHtDaGFydEV2ZW50fG51bGx9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUxhc3RFdmVudChlLCBsYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKSB7XG4gIGlmICghaW5DaGFydEFyZWEgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQ2xpY2spIHtcbiAgICByZXR1cm4gbGFzdEV2ZW50O1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplRm9yQXJlYShzY2FsZSwgY2hhcnRBcmVhLCBmaWVsZCkge1xuICByZXR1cm4gc2NhbGUub3B0aW9ucy5jbGlwID8gc2NhbGVbZmllbGRdIDogY2hhcnRBcmVhW2ZpZWxkXTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YXNldEFyZWEobWV0YSwgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICBpZiAoeFNjYWxlICYmIHlTY2FsZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBnZXRTaXplRm9yQXJlYSh4U2NhbGUsIGNoYXJ0QXJlYSwgJ2xlZnQnKSxcbiAgICAgIHJpZ2h0OiBnZXRTaXplRm9yQXJlYSh4U2NhbGUsIGNoYXJ0QXJlYSwgJ3JpZ2h0JyksXG4gICAgICB0b3A6IGdldFNpemVGb3JBcmVhKHlTY2FsZSwgY2hhcnRBcmVhLCAndG9wJyksXG4gICAgICBib3R0b206IGdldFNpemVGb3JBcmVhKHlTY2FsZSwgY2hhcnRBcmVhLCAnYm90dG9tJylcbiAgICB9O1xuICB9XG4gIHJldHVybiBjaGFydEFyZWE7XG59XG5cbmNsYXNzIENoYXJ0IHtcblxuICBzdGF0aWMgZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgc3RhdGljIGluc3RhbmNlcyA9IGluc3RhbmNlcztcbiAgc3RhdGljIG92ZXJyaWRlcyA9IG92ZXJyaWRlcztcbiAgc3RhdGljIHJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG4gIHN0YXRpYyB2ZXJzaW9uID0gdmVyc2lvbjtcbiAgc3RhdGljIGdldENoYXJ0ID0gZ2V0Q2hhcnQ7XG5cbiAgc3RhdGljIHJlZ2lzdGVyKC4uLml0ZW1zKSB7XG4gICAgcmVnaXN0cnkuYWRkKC4uLml0ZW1zKTtcbiAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICB9XG5cbiAgc3RhdGljIHVucmVnaXN0ZXIoLi4uaXRlbXMpIHtcbiAgICByZWdpc3RyeS5yZW1vdmUoLi4uaXRlbXMpO1xuICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgY29uc3RydWN0b3IoaXRlbSwgdXNlckNvbmZpZykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gbmV3IENvbmZpZyh1c2VyQ29uZmlnKTtcbiAgICBjb25zdCBpbml0aWFsQ2FudmFzID0gZ2V0Q2FudmFzKGl0ZW0pO1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hhcnQgPSBnZXRDaGFydChpbml0aWFsQ2FudmFzKTtcbiAgICBpZiAoZXhpc3RpbmdDaGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2FudmFzIGlzIGFscmVhZHkgaW4gdXNlLiBDaGFydCB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmlkICsgJ1xcJycgK1xuXHRcdFx0XHQnIG11c3QgYmUgZGVzdHJveWVkIGJlZm9yZSB0aGUgY2FudmFzIHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuY2FudmFzLmlkICsgJ1xcJyBjYW4gYmUgcmV1c2VkLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuXG4gICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyAoY29uZmlnLnBsYXRmb3JtIHx8IF9kZXRlY3RQbGF0Zm9ybShpbml0aWFsQ2FudmFzKSkoKTtcbiAgICB0aGlzLnBsYXRmb3JtLnVwZGF0ZUNvbmZpZyhjb25maWcpO1xuXG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMucGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaW5pdGlhbENhbnZhcywgb3B0aW9ucy5hc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XG5cbiAgICB0aGlzLmlkID0gdWlkKCk7XG4gICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBTdG9yZSB0aGUgcHJldmlvdXNseSB1c2VkIGFzcGVjdCByYXRpbyB0byBkZXRlcm1pbmUgaWYgYSByZXNpemVcbiAgICAvLyBpcyBuZWVkZWQgZHVyaW5nIHVwZGF0ZXMuIERvIHRoaXMgYWZ0ZXIgX29wdGlvbnMgaXMgc2V0IHNpbmNlXG4gICAgLy8gYXNwZWN0UmF0aW8gdXNlcyBhIGdldHRlclxuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICB0aGlzLl9tZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuX3N0YWNrcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJveGVzID0gW107XG4gICAgdGhpcy5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0QXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgLyoqIEB0eXBlIHs/e2F0dGFjaD86IGZ1bmN0aW9uLCBkZXRhY2g/OiBmdW5jdGlvbiwgcmVzaXplPzogZnVuY3Rpb259fSAqL1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuX3BsdWdpbnMgPSBuZXcgUGx1Z2luU2VydmljZSgpO1xuICAgIHRoaXMuJHByb3hpZXMgPSB7fTtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzID0ge307XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RvUmVzaXplID0gZGVib3VuY2UobW9kZSA9PiB0aGlzLnVwZGF0ZShtb2RlKSwgb3B0aW9ucy5yZXNpemVEZWxheSB8fCAwKTtcbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuXG4gICAgLy8gQWRkIHRoZSBjaGFydCBpbnN0YW5jZSB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxuICAgIGluc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XG5cbiAgICBpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuICAgICAgLy8gVGhlIGdpdmVuIGl0ZW0gaXMgbm90IGEgY29tcGF0aWJsZSBjb250ZXh0MmQgZWxlbWVudCwgbGV0J3MgcmV0dXJuIGJlZm9yZSBmaW5hbGl6aW5nXG4gICAgICAvLyB0aGUgY2hhcnQgaW5pdGlhbGl6YXRpb24gYnV0IGFmdGVyIHNldHRpbmcgYmFzaWMgY2hhcnQgLyBjb250cm9sbGVyIHByb3BlcnRpZXMgdGhhdFxuICAgICAgLy8gY2FuIGhlbHAgdG8gZmlndXJlIG91dCB0aGF0IHRoZSBjaGFydCBpcyBub3QgdmFsaWQgKGUuZyBjaGFydC5jYW52YXMgIT09IG51bGwpO1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ2NvbXBsZXRlJywgb25BbmltYXRpb25zQ29tcGxldGUpO1xuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAncHJvZ3Jlc3MnLCBvbkFuaW1hdGlvblByb2dyZXNzKTtcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IHthc3BlY3RSYXRpbywgbWFpbnRhaW5Bc3BlY3RSYXRpb30sIHdpZHRoLCBoZWlnaHQsIF9hc3BlY3RSYXRpb30gPSB0aGlzO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihhc3BlY3RSYXRpbykpIHtcbiAgICAgIC8vIElmIGFzcGVjdFJhdGlvIGlzIGRlZmluZWQgaW4gb3B0aW9ucywgdXNlIHRoYXQuXG4gICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgaWYgKG1haW50YWluQXNwZWN0UmF0aW8gJiYgX2FzcGVjdFJhdGlvKSB7XG4gICAgICAvLyBJZiBtYWludGFpbkFzcGVjdFJhdGlvIGlzIHRydXRobHkgYW5kIHdlIGhhZCBwcmV2aW91c2x5IGRldGVybWluZWQgX2FzcGVjdFJhdGlvLCB1c2UgdGhhdFxuICAgICAgcmV0dXJuIF9hc3BlY3RSYXRpbztcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGVcbiAgICByZXR1cm4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuICB9XG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XG4gIH1cblxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5jb25maWcuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGdldCByZWdpc3RyeSgpIHtcbiAgICByZXR1cm4gcmVnaXN0cnk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIC8vIEJlZm9yZSBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUluaXQnKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0aW5hU2NhbGUodGhpcywgdGhpcy5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIH1cblxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuXG4gICAgLy8gQWZ0ZXIgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckluaXQnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXJDYW52YXModGhpcy5jYW52YXMsIHRoaXMuY3R4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgYW5pbWF0b3Iuc3RvcCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXNpemUgdGhlIGNoYXJ0IHRvIGl0cyBjb250YWluZXIgb3IgdG8gZXhwbGljaXQgZGltZW5zaW9ucy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdXG5cdCAqL1xuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0ge3dpZHRoLCBoZWlnaHR9O1xuICAgIH1cbiAgfVxuXG4gIF9yZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSBvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgdGhpcy5hc3BlY3RSYXRpbztcbiAgICBjb25zdCBuZXdTaXplID0gdGhpcy5wbGF0Zm9ybS5nZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBuZXdSYXRpbyA9IG9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyB8fCB0aGlzLnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICBjb25zdCBtb2RlID0gdGhpcy53aWR0aCA/ICdyZXNpemUnIDogJ2F0dGFjaCc7XG5cbiAgICB0aGlzLndpZHRoID0gbmV3U2l6ZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG5ld1NpemUuaGVpZ2h0O1xuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICBpZiAoIXJldGluYVNjYWxlKHRoaXMsIG5ld1JhdGlvLCB0cnVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzaXplJywge3NpemU6IG5ld1NpemV9KTtcblxuICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uUmVzaXplLCBbdGhpcywgbmV3U2l6ZV0sIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGlmICh0aGlzLl9kb1Jlc2l6ZShtb2RlKSkge1xuICAgICAgICAvLyBUaGUgcmVzaXplIHVwZGF0ZSBpcyBkZWxheWVkLCBvbmx5IGRyYXcgd2l0aG91dCB1cGRhdGluZy5cbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbnN1cmVTY2FsZXNIYXZlSURzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVzT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuXG4gICAgZWFjaChzY2FsZXNPcHRpb25zLCAoYXhpc09wdGlvbnMsIGF4aXNJRCkgPT4ge1xuICAgICAgYXhpc09wdGlvbnMuaWQgPSBheGlzSUQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQnVpbGRzIGEgbWFwIG9mIHNjYWxlIElEIHRvIHNjYWxlIG9iamVjdCBmb3IgZnV0dXJlIGxvb2t1cC5cblx0ICovXG4gIGJ1aWxkT3JVcGRhdGVTY2FsZXMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZU9wdHMgPSBvcHRpb25zLnNjYWxlcztcbiAgICBjb25zdCBzY2FsZXMgPSB0aGlzLnNjYWxlcztcbiAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmtleXMoc2NhbGVzKS5yZWR1Y2UoKG9iaiwgaWQpID0+IHtcbiAgICAgIG9ialtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xuICAgIGxldCBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKHNjYWxlT3B0cykge1xuICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoXG4gICAgICAgIE9iamVjdC5rZXlzKHNjYWxlT3B0cykubWFwKChpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IHNjYWxlT3B0c1tpZF07XG4gICAgICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICAgICAgY29uc3QgaXNSYWRpYWwgPSBheGlzID09PSAncic7XG4gICAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gYXhpcyA9PT0gJ3gnO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiBzY2FsZU9wdGlvbnMsXG4gICAgICAgICAgICBkcG9zaXRpb246IGlzUmFkaWFsID8gJ2NoYXJ0QXJlYScgOiBpc0hvcml6b250YWwgPyAnYm90dG9tJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIGR0eXBlOiBpc1JhZGlhbCA/ICdyYWRpYWxMaW5lYXInIDogaXNIb3Jpem9udGFsID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZWFjaChpdGVtcywgKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IGlkID0gc2NhbGVPcHRpb25zLmlkO1xuICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICBjb25zdCBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG5cbiAgICAgIGlmIChzY2FsZU9wdGlvbnMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24sIGF4aXMpICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcbiAgICAgICAgc2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZWRbaWRdID0gdHJ1ZTtcbiAgICAgIGxldCBzY2FsZSA9IG51bGw7XG4gICAgICBpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG4gICAgICAgIHNjYWxlID0gc2NhbGVzW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNjYWxlQ2xhc3MgPSByZWdpc3RyeS5nZXRTY2FsZShzY2FsZVR5cGUpO1xuICAgICAgICBzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB0eXBlOiBzY2FsZVR5cGUsXG4gICAgICAgICAgY3R4OiB0aGlzLmN0eCxcbiAgICAgICAgICBjaGFydDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgc2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xuICAgICAgfVxuXG4gICAgICBzY2FsZS5pbml0KHNjYWxlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgLy8gY2xlYXIgdXAgZGlzY2FyZGVkIHNjYWxlc1xuICAgIGVhY2godXBkYXRlZCwgKGhhc1VwZGF0ZWQsIGlkKSA9PiB7XG4gICAgICBpZiAoIWhhc1VwZGF0ZWQpIHtcbiAgICAgICAgZGVsZXRlIHNjYWxlc1tpZF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBlYWNoKHNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLmNvbmZpZ3VyZSh0aGlzLCBzY2FsZSwgc2NhbGUub3B0aW9ucyk7XG4gICAgICBsYXlvdXRzLmFkZEJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVNZXRhc2V0cygpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGNvbnN0IG51bURhdGEgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bU1ldGEgPSBtZXRhc2V0cy5sZW5ndGg7XG5cbiAgICBtZXRhc2V0cy5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleCk7XG4gICAgaWYgKG51bU1ldGEgPiBudW1EYXRhKSB7XG4gICAgICBmb3IgKGxldCBpID0gbnVtRGF0YTsgaSA8IG51bU1ldGE7ICsraSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhc2V0cy5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IG1ldGFzZXRzLnNsaWNlKDApLnNvcnQoY29tcGFyZTJMZXZlbCgnb3JkZXInLCAnaW5kZXgnKSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpIHtcbiAgICBjb25zdCB7X21ldGFzZXRzOiBtZXRhc2V0cywgZGF0YToge2RhdGFzZXRzfX0gPSB0aGlzO1xuICAgIGlmIChtZXRhc2V0cy5sZW5ndGggPiBkYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdGFja3M7XG4gICAgfVxuICAgIG1ldGFzZXRzLmZvckVhY2goKG1ldGEsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZGF0YXNldHMuZmlsdGVyKHggPT4geCA9PT0gbWV0YS5fZGF0YXNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKSB7XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0cyA9IHRoaXMuZGF0YS5kYXRhc2V0cztcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIHRoaXMuX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldHNbaV07XG4gICAgICBsZXQgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IHRoaXMuY29uZmlnLnR5cGU7XG5cbiAgICAgIGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhLnR5cGUgPSB0eXBlO1xuICAgICAgbWV0YS5pbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIG1ldGEub3JkZXIgPSBkYXRhc2V0Lm9yZGVyIHx8IDA7XG4gICAgICBtZXRhLmluZGV4ID0gaTtcbiAgICAgIG1ldGEubGFiZWwgPSAnJyArIGRhdGFzZXQubGFiZWw7XG4gICAgICBtZXRhLnZpc2libGUgPSB0aGlzLmlzRGF0YXNldFZpc2libGUoaSk7XG5cbiAgICAgIGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLnVwZGF0ZUluZGV4KGkpO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIubGlua1NjYWxlcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgQ29udHJvbGxlckNsYXNzID0gcmVnaXN0cnkuZ2V0Q29udHJvbGxlcih0eXBlKTtcbiAgICAgICAgY29uc3Qge2RhdGFzZXRFbGVtZW50VHlwZSwgZGF0YUVsZW1lbnRUeXBlfSA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdO1xuICAgICAgICBPYmplY3QuYXNzaWduKENvbnRyb2xsZXJDbGFzcywge1xuICAgICAgICAgIGRhdGFFbGVtZW50VHlwZTogcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhRWxlbWVudFR5cGUpLFxuICAgICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZGF0YXNldEVsZW1lbnRUeXBlICYmIHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YXNldEVsZW1lbnRUeXBlKVxuICAgICAgICB9KTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzLCBpKTtcbiAgICAgICAgbmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZU1ldGFzZXRzKCk7XG4gICAgcmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlc2V0IHRoZSBlbGVtZW50cyBvZiBhbGwgZGF0YXNldHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZXNldEVsZW1lbnRzKCkge1xuICAgIGVhY2godGhpcy5kYXRhLmRhdGFzZXRzLCAoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgLyoqXG5cdCogUmVzZXRzIHRoZSBjaGFydCBiYWNrIHRvIGl0cyBzdGF0ZSBiZWZvcmUgdGhlIGluaXRpYWwgYW5pbWF0aW9uXG5cdCovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudHMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2V0Jyk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgY29uZmlnLnVwZGF0ZSgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYW5pbXNEaXNhYmxlZCA9IHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9ICFvcHRpb25zLmFuaW1hdGlvbjtcblxuICAgIHRoaXMuX3VwZGF0ZVNjYWxlcygpO1xuICAgIHRoaXMuX2NoZWNrRXZlbnRCaW5kaW5ncygpO1xuICAgIHRoaXMuX3VwZGF0ZUhpZGRlbkluZGljZXMoKTtcblxuICAgIC8vIHBsdWdpbnMgb3B0aW9ucyByZWZlcmVuY2VzIG1pZ2h0IGhhdmUgY2hhbmdlLCBsZXQncyBpbnZhbGlkYXRlIHRoZSBjYWNoZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MTExI2lzc3VlY29tbWVudC0zNTU5MzQxNjdcbiAgICB0aGlzLl9wbHVnaW5zLmludmFsaWRhdGUoKTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVVwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIGRhdGFzZXQgY29udHJvbGxlcnMgYXJlIHVwZGF0ZWQgYW5kIG5ldyBjb250cm9sbGVycyBhcmUgcmVzZXRcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IHRoaXMuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUVsZW1lbnRzVXBkYXRlJyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgYWxsIGRhdGFzZXQgY29udHJvbGxlcnMgaGF2ZSBjb3JyZWN0IG1ldGEgZGF0YSBjb3VudHNcbiAgICBsZXQgbWluUGFkZGluZyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB7Y29udHJvbGxlcn0gPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgcmVzZXQgPSAhYW5pbXNEaXNhYmxlZCAmJiBuZXdDb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpID09PSAtMTtcbiAgICAgIC8vIE5ldyBjb250cm9sbGVycyB3aWxsIGJlIHJlc2V0IGFmdGVyIHRoZSBsYXlvdXQgcGFzcywgc28gd2Ugb25seSB3YW50IHRvIG1vZGlmeVxuICAgICAgLy8gZWxlbWVudHMgYWRkZWQgdG8gbmV3IGRhdGFzZXRzXG4gICAgICBjb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cyhyZXNldCk7XG4gICAgICBtaW5QYWRkaW5nID0gTWF0aC5tYXgoK2NvbnRyb2xsZXIuZ2V0TWF4T3ZlcmZsb3coKSwgbWluUGFkZGluZyk7XG4gICAgfVxuICAgIG1pblBhZGRpbmcgPSB0aGlzLl9taW5QYWRkaW5nID0gb3B0aW9ucy5sYXlvdXQuYXV0b1BhZGRpbmcgPyBtaW5QYWRkaW5nIDogMDtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQobWluUGFkZGluZyk7XG5cbiAgICAvLyBPbmx5IHJlc2V0IHRoZSBjb250cm9sbGVycyBpZiB3ZSBoYXZlIGFuaW1hdGlvbnNcbiAgICBpZiAoIWFuaW1zRGlzYWJsZWQpIHtcbiAgICAgIC8vIENhbiBvbmx5IHJlc2V0IHRoZSBuZXcgY29udHJvbGxlcnMgYWZ0ZXIgdGhlIHNjYWxlcyBoYXZlIGJlZW4gdXBkYXRlZFxuICAgICAgLy8gUmVzZXQgaXMgZG9uZSB0byBnZXQgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciB0aGUgaW5pdGlhbCBhbmltYXRpb25cbiAgICAgIGVhY2gobmV3Q29udHJvbGxlcnMsIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZURhdGFzZXRzKG1vZGUpO1xuXG4gICAgLy8gRG8gdGhpcyBiZWZvcmUgcmVuZGVyIHNvIHRoYXQgYW55IHBsdWdpbnMgdGhhdCBuZWVkIGZpbmFsIHNjYWxlIHVwZGF0ZXMgY2FuIHVzZSBpdFxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJVcGRhdGUnLCB7bW9kZX0pO1xuXG4gICAgdGhpcy5fbGF5ZXJzLnNvcnQoY29tcGFyZTJMZXZlbCgneicsICdfaWR4JykpO1xuXG4gICAgLy8gUmVwbGF5IGxhc3QgZXZlbnQgZnJvbSBiZWZvcmUgdXBkYXRlLCBvciBzZXQgaG92ZXIgc3R5bGVzIG9uIGFjdGl2ZSBlbGVtZW50c1xuICAgIGNvbnN0IHtfYWN0aXZlLCBfbGFzdEV2ZW50fSA9IHRoaXM7XG4gICAgaWYgKF9sYXN0RXZlbnQpIHtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihfbGFzdEV2ZW50LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKF9hY3RpdmUubGVuZ3RoKSB7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhfYWN0aXZlLCBfYWN0aXZlLCB0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU2NhbGVzKCkge1xuICAgIGVhY2godGhpcy5zY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5yZW1vdmVCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG4gICAgdGhpcy5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja0V2ZW50QmluZGluZ3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBleGlzdGluZ0V2ZW50cyA9IG5ldyBTZXQoT2JqZWN0LmtleXModGhpcy5fbGlzdGVuZXJzKSk7XG4gICAgY29uc3QgbmV3RXZlbnRzID0gbmV3IFNldChvcHRpb25zLmV2ZW50cyk7XG5cbiAgICBpZiAoIXNldHNFcXVhbChleGlzdGluZ0V2ZW50cywgbmV3RXZlbnRzKSB8fCAhIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgIT09IG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgLy8gVGhlIGNvbmZpZ3VyZWQgZXZlbnRzIGhhdmUgY2hhbmdlZC4gUmViaW5kLlxuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZUhpZGRlbkluZGljZXMoKSB7XG4gICAgY29uc3Qge19oaWRkZW5JbmRpY2VzfSA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHx8IFtdO1xuICAgIGZvciAoY29uc3Qge21ldGhvZCwgc3RhcnQsIGNvdW50fSBvZiBjaGFuZ2VzKSB7XG4gICAgICBjb25zdCBtb3ZlID0gbWV0aG9kID09PSAnX3JlbW92ZUVsZW1lbnRzJyA/IC1jb3VudCA6IGNvdW50O1xuICAgICAgbW92ZU51bWVyaWNLZXlzKF9oaWRkZW5JbmRpY2VzLCBzdGFydCwgbW92ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkge1xuICAgIGNvbnN0IF9kYXRhQ2hhbmdlcyA9IHRoaXMuX2RhdGFDaGFuZ2VzO1xuICAgIGlmICghX2RhdGFDaGFuZ2VzIHx8ICFfZGF0YUNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0Q291bnQgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG1ha2VTZXQgPSAoaWR4KSA9PiBuZXcgU2V0KFxuICAgICAgX2RhdGFDaGFuZ2VzXG4gICAgICAgIC5maWx0ZXIoYyA9PiBjWzBdID09PSBpZHgpXG4gICAgICAgIC5tYXAoKGMsIGkpID0+IGkgKyAnLCcgKyBjLnNwbGljZSgxKS5qb2luKCcsJykpXG4gICAgKTtcblxuICAgIGNvbnN0IGNoYW5nZVNldCA9IG1ha2VTZXQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhc2V0Q291bnQ7IGkrKykge1xuICAgICAgaWYgKCFzZXRzRXF1YWwoY2hhbmdlU2V0LCBtYWtlU2V0KGkpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGNoYW5nZVNldClcbiAgICAgIC5tYXAoYyA9PiBjLnNwbGl0KCcsJykpXG4gICAgICAubWFwKGEgPT4gKHttZXRob2Q6IGFbMV0sIHN0YXJ0OiArYVsyXSwgY291bnQ6ICthWzNdfSkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNoYXJ0IGxheW91dCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlTGF5b3V0YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJMYXlvdXRgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlTGF5b3V0Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsYXlvdXRzLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgbWluUGFkZGluZyk7XG5cbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3Qgbm9BcmVhID0gYXJlYS53aWR0aCA8PSAwIHx8IGFyZWEuaGVpZ2h0IDw9IDA7XG5cbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICBlYWNoKHRoaXMuYm94ZXMsIChib3gpID0+IHtcbiAgICAgIGlmIChub0FyZWEgJiYgYm94LnBvc2l0aW9uID09PSAnY2hhcnRBcmVhJykge1xuICAgICAgICAvLyBTa2lwIGRyYXdpbmcgYW5kIGNvbmZpZ3VyaW5nIGNoYXJ0QXJlYSBib3hlcyB3aGVuIGNoYXJ0QXJlYSBpcyB6ZXJvIG9yIG5lZ2F0aXZlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY29uZmlndXJlIGlzIGNhbGxlZCB0d2ljZSwgb25jZSBpbiBjb3JlLnNjYWxlLnVwZGF0ZSBhbmQgb25jZSBoZXJlLlxuICAgICAgLy8gSGVyZSB0aGUgYm94ZXMgYXJlIGZ1bGx5IHVwZGF0ZWQgYW5kIGF0IHRoZWlyIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAgIGlmIChib3guY29uZmlndXJlKSB7XG4gICAgICAgIGJveC5jb25maWd1cmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xheWVycy5wdXNoKC4uLmJveC5fbGF5ZXJzKCkpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBpdGVtLl9pZHggPSBpbmRleDtcbiAgICB9KTtcblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJMYXlvdXQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGVzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNVcGRhdGVgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRzVXBkYXRlYC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVEYXRhc2V0cyhtb2RlKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLmNvbmZpZ3VyZSgpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YXNldChpLCBpc0Z1bmN0aW9uKG1vZGUpID8gbW9kZSh7ZGF0YXNldEluZGV4OiBpfSkgOiBtb2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNVcGRhdGUnLCB7bW9kZX0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldFVwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldFVwZGF0ZWAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlRGF0YXNldChpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgICBjb25zdCBhcmdzID0ge21ldGEsIGluZGV4LCBtb2RlLCBjYW5jZWxhYmxlOiB0cnVlfTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRVcGRhdGUnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtZXRhLmNvbnRyb2xsZXIuX3VwZGF0ZShtb2RlKTtcblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0VXBkYXRlJywgYXJncyk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlUmVuZGVyJywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0b3IuaGFzKHRoaXMpKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgICBhbmltYXRvci5zdGFydCh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICBvbkFuaW1hdGlvbnNDb21wbGV0ZSh7Y2hhcnQ6IHRoaXN9KTtcbiAgICB9XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGxldCBpO1xuICAgIGlmICh0aGlzLl9yZXNpemVCZWZvcmVEcmF3KSB7XG4gICAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9yZXNpemVCZWZvcmVEcmF3O1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEJlY2F1c2Ugb2YgcGx1Z2luIGhvb2tzIChiZWZvcmUvYWZ0ZXJEYXRhc2V0c0RyYXcpLCBkYXRhc2V0cyBjYW4ndFxuICAgIC8vIGN1cnJlbnRseSBiZSBwYXJ0IG9mIGxheWVycy4gSW5zdGVhZCwgd2UgZHJhd1xuICAgIC8vIGxheWVycyA8PSAwIGJlZm9yZShkZWZhdWx0LCBiYWNrd2FyZCBjb21wYXQpLCBhbmQgdGhlIHJlc3QgYWZ0ZXJcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgZm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGggJiYgbGF5ZXJzW2ldLnogPD0gMDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZHJhd0RhdGFzZXRzKCk7XG5cbiAgICAvLyBSZXN0IG9mIGxheWVyc1xuICAgIGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRyYXcnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9zb3J0ZWRNZXRhc2V0cztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc2V0c1tpXTtcbiAgICAgIGlmICghZmlsdGVyVmlzaWJsZSB8fCBtZXRhLnZpc2libGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSB2aXNpYmxlIGRhdGFzZXQgbWV0YXMgaW4gZHJhd2luZyBvcmRlclxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3cyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzRHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNEcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3RGF0YXNldHMoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGhpcy5fZHJhd0RhdGFzZXQobWV0YXNldHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c0RyYXcnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3cyBkYXRhc2V0IGF0IGluZGV4IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0RHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldERyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXdEYXRhc2V0KG1ldGEpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjbGlwID0gbWV0YS5fY2xpcDtcbiAgICBjb25zdCB1c2VDbGlwID0gIWNsaXAuZGlzYWJsZWQ7XG4gICAgY29uc3QgYXJlYSA9IGdldERhdGFzZXRBcmVhKG1ldGEsIHRoaXMuY2hhcnRBcmVhKTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgbWV0YSxcbiAgICAgIGluZGV4OiBtZXRhLmluZGV4LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0RHJhdycsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIHtcbiAgICAgICAgbGVmdDogY2xpcC5sZWZ0ID09PSBmYWxzZSA/IDAgOiBhcmVhLmxlZnQgLSBjbGlwLmxlZnQsXG4gICAgICAgIHJpZ2h0OiBjbGlwLnJpZ2h0ID09PSBmYWxzZSA/IHRoaXMud2lkdGggOiBhcmVhLnJpZ2h0ICsgY2xpcC5yaWdodCxcbiAgICAgICAgdG9wOiBjbGlwLnRvcCA9PT0gZmFsc2UgPyAwIDogYXJlYS50b3AgLSBjbGlwLnRvcCxcbiAgICAgICAgYm90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyB0aGlzLmhlaWdodCA6IGFyZWEuYm90dG9tICsgY2xpcC5ib3R0b21cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG1ldGEuY29udHJvbGxlci5kcmF3KCk7XG5cbiAgICBpZiAodXNlQ2xpcCkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0RHJhdycsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBwb2ludCBpcyBpbiB0aGUgY2hhcnQgYXJlYS5cbiAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBpbiByZWxhdGl2ZSBjb29yZGluYXRlcyAoc2VlLCBlLmcuLCBnZXRSZWxhdGl2ZVBvc2l0aW9uKVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzUG9pbnRJbkFyZWEocG9pbnQpIHtcbiAgICByZXR1cm4gX2lzUG9pbnRJbkFyZWEocG9pbnQsIHRoaXMuY2hhcnRBcmVhLCB0aGlzLl9taW5QYWRkaW5nKTtcbiAgfVxuXG4gIGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgbW9kZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG1ldGhvZCA9IEludGVyYWN0aW9uLm1vZGVzW21vZGVdO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGxldCBtZXRhID0gbWV0YXNldHMuZmlsdGVyKHggPT4geCAmJiB4Ll9kYXRhc2V0ID09PSBkYXRhc2V0KS5wb3AoKTtcblxuICAgIGlmICghbWV0YSkge1xuICAgICAgbWV0YSA9IHtcbiAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGRhdGFzZXQ6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgIGhpZGRlbjogbnVsbCxcdFx0XHQvLyBTZWUgaXNEYXRhc2V0VmlzaWJsZSgpIGNvbW1lbnRcbiAgICAgICAgeEF4aXNJRDogbnVsbCxcbiAgICAgICAgeUF4aXNJRDogbnVsbCxcbiAgICAgICAgb3JkZXI6IGRhdGFzZXQgJiYgZGF0YXNldC5vcmRlciB8fCAwLFxuICAgICAgICBpbmRleDogZGF0YXNldEluZGV4LFxuICAgICAgICBfZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgX3BhcnNlZDogW10sXG4gICAgICAgIF9zb3J0ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbWV0YXNldHMucHVzaChtZXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfVxuXG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwsIHtjaGFydDogdGhpcywgdHlwZTogJ2NoYXJ0J30pKTtcbiAgfVxuXG4gIGdldFZpc2libGVEYXRhc2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmxlbmd0aDtcbiAgfVxuXG4gIGlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmICghZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cbiAgICAvLyBtZXRhLmhpZGRlbiBpcyBhIHBlciBjaGFydCBkYXRhc2V0IGhpZGRlbiBmbGFnIG92ZXJyaWRlIHdpdGggMyBzdGF0ZXM6IGlmIHRydWUgb3IgZmFsc2UsXG4gICAgLy8gdGhlIGRhdGFzZXQuaGlkZGVuIHZhbHVlIGlzIGlnbm9yZWQsIGVsc2UgaWYgbnVsbCwgdGhlIGRhdGFzZXQgaGlkZGVuIHN0YXRlIGlzIHJldHVybmVkLlxuICAgIHJldHVybiB0eXBlb2YgbWV0YS5oaWRkZW4gPT09ICdib29sZWFuJyA/ICFtZXRhLmhpZGRlbiA6ICFkYXRhc2V0LmhpZGRlbjtcbiAgfVxuXG4gIHNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgbWV0YS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgfVxuXG4gIHRvZ2dsZURhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF0gPSAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cblxuICBnZXREYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHJldHVybiAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbW9kZSA9IHZpc2libGUgPyAnc2hvdycgOiAnaGlkZSc7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBhbmltcyA9IG1ldGEuY29udHJvbGxlci5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKTtcblxuICAgIGlmIChkZWZpbmVkKGRhdGFJbmRleCkpIHtcbiAgICAgIG1ldGEuZGF0YVtkYXRhSW5kZXhdLmhpZGRlbiA9ICF2aXNpYmxlO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpO1xuICAgICAgLy8gQW5pbWF0ZSB2aXNpYmxlIHN0YXRlLCBzbyBoaWRlIGFuaW1hdGlvbiBjYW4gYmUgc2Vlbi4gVGhpcyBjb3VsZCBiZSBoYW5kbGVkIGJldHRlciBpZiB1cGRhdGUgLyB1cGRhdGVEYXRhc2V0IHJldHVybmVkIGEgUHJvbWlzZS5cbiAgICAgIGFuaW1zLnVwZGF0ZShtZXRhLCB7dmlzaWJsZX0pO1xuICAgICAgdGhpcy51cGRhdGUoKGN0eCkgPT4gY3R4LmRhdGFzZXRJbmRleCA9PT0gZGF0YXNldEluZGV4ID8gbW9kZSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG5cbiAgaGlkZShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIGZhbHNlKTtcbiAgfVxuXG4gIHNob3coZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2Rlc3Ryb3lEYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAobWV0YSAmJiBtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgIG1ldGEuY29udHJvbGxlci5fZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgfVxuXG4gIF9zdG9wKCkge1xuICAgIGxldCBpLCBpbGVuO1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIGFuaW1hdG9yLnJlbW92ZSh0aGlzKTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURlc3Ryb3knKTtcbiAgICBjb25zdCB7Y2FudmFzLCBjdHh9ID0gdGhpcztcblxuICAgIHRoaXMuX3N0b3AoKTtcbiAgICB0aGlzLmNvbmZpZy5jbGVhckNhY2hlKCk7XG5cbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpO1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZWxlYXNlQ29udGV4dChjdHgpO1xuICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgIH1cblxuICAgIGRlbGV0ZSBpbnN0YW5jZXNbdGhpcy5pZF07XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGVzdHJveScpO1xuICB9XG5cbiAgdG9CYXNlNjRJbWFnZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTCguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLmJpbmRVc2VyRXZlbnRzKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLmJpbmRSZXNwb25zaXZlRXZlbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYmluZFVzZXJFdmVudHMoKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcblxuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcblxuICAgIGNvbnN0IGxpc3RlbmVyID0gKGUsIHgsIHkpID0+IHtcbiAgICAgIGUub2Zmc2V0WCA9IHg7XG4gICAgICBlLm9mZnNldFkgPSB5O1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKGUpO1xuICAgIH07XG5cbiAgICBlYWNoKHRoaXMub3B0aW9ucy5ldmVudHMsICh0eXBlKSA9PiBfYWRkKHR5cGUsIGxpc3RlbmVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJpbmRSZXNwb25zaXZlRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcblxuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBjb25zdCBfcmVtb3ZlID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAobGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW3R5cGVdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCBkZXRhY2hlZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItY29uc3RcbiAgICBjb25zdCBhdHRhY2hlZCA9ICgpID0+IHtcbiAgICAgIF9yZW1vdmUoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcblxuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICBfYWRkKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICBfYWRkKCdkZXRhY2gnLCBkZXRhY2hlZCk7XG4gICAgfTtcblxuICAgIGRldGFjaGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuXG4gICAgICBfcmVtb3ZlKCdyZXNpemUnLCBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFN0b3AgYW5pbWF0aW5nIGFuZCByZW1vdmUgbWV0YXNldHMsIHNvIHdoZW4gcmUtYXR0YWNoZWQsIHRoZSBhbmltYXRpb25zIHN0YXJ0IGZyb20gYmVnaW5uaW5nLlxuICAgICAgdGhpcy5fc3RvcCgpO1xuICAgICAgdGhpcy5fcmVzaXplKDAsIDApO1xuXG4gICAgICBfYWRkKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG4gICAgfTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0F0dGFjaGVkKHRoaXMuY2FudmFzKSkge1xuICAgICAgYXR0YWNoZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0YWNoZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIHVuYmluZEV2ZW50cygpIHtcbiAgICBlYWNoKHRoaXMuX2xpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXG4gICAgZWFjaCh0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHVwZGF0ZUhvdmVyU3R5bGUoaXRlbXMsIG1vZGUsIGVuYWJsZWQpIHtcbiAgICBjb25zdCBwcmVmaXggPSBlbmFibGVkID8gJ3NldCcgOiAncmVtb3ZlJztcbiAgICBsZXQgbWV0YSwgaXRlbSwgaSwgaWxlbjtcblxuICAgIGlmIChtb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLmRhdGFzZXRJbmRleCk7XG4gICAgICBtZXRhLmNvbnRyb2xsZXJbJ18nICsgcHJlZml4ICsgJ0RhdGFzZXRIb3ZlclN0eWxlJ10oKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gaXRlbSAmJiB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW0uZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlcltwcmVmaXggKyAnSG92ZXJTdHlsZSddKGl0ZW0uZWxlbWVudCwgaXRlbS5kYXRhc2V0SW5kZXgsIGl0ZW0uaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgYWN0aXZlIChob3ZlcmVkKSBlbGVtZW50c1xuXHQgKiBAcmV0dXJucyBhcnJheVxuXHQgKi9cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZXQgYWN0aXZlIChob3ZlcmVkKSBlbGVtZW50c1xuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmVFbGVtZW50cyBOZXcgYWN0aXZlIGRhdGEgcG9pbnRzXG5cdCAqL1xuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cykge1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhc2V0IGZvdW5kIGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG5cbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHVzZSB0aGUgcHJldmlvdXMgbW91c2UgZXZlbnQgdG8gb3ZlcnJpZGUgdGhlIGFjdGl2ZSBlbGVtZW50cyBpbiB1cGRhdGUuXG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyBhcyBzb29uIGFzIGEgcGx1Z2luIGV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZS4gVGhlXG5cdCAqIHJldHVybmVkIHZhbHVlIGNhbiBiZSB1c2VkLCBmb3IgaW5zdGFuY2UsIHRvIGludGVycnVwdCB0aGUgY3VycmVudCBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnc10gLSBFeHRyYSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGhvb2sgY2FsbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vY29yZS5wbHVnaW5zLmpzJykuZmlsdGVyQ2FsbGJhY2t9IFtmaWx0ZXJdIC0gRmlsdGVyaW5nIGZ1bmN0aW9uIGZvciBsaW1pdGluZyB3aGljaCBwbHVnaW5zIGFyZSBub3RpZmllZFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgYW55IG9mIHRoZSBwbHVnaW5zIHJldHVybiBmYWxzZSwgZWxzZSByZXR1cm5zIHRydWUuXG5cdCAqL1xuICBub3RpZnlQbHVnaW5zKGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLm5vdGlmeSh0aGlzLCBob29rLCBhcmdzLCBmaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgcGx1Z2luIHdpdGggdGhlIHNwZWNpZmljIElEIGlzIHJlZ2lzdGVyZWQgYW5kIGVuYWJsZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBsdWdpbklkIC0gVGhlIElEIG9mIHRoZSBwbHVnaW4gb2Ygd2hpY2ggdG8gY2hlY2sgaWYgaXQgaXMgZW5hYmxlZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzUGx1Z2luRW5hYmxlZChwbHVnaW5JZCkge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLl9jYWNoZS5maWx0ZXIocCA9PiBwLnBsdWdpbi5pZCA9PT0gcGx1Z2luSWQpLmxlbmd0aCA9PT0gMTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5kYXRhc2V0SW5kZXggPT09IHkuZGF0YXNldEluZGV4ICYmIHguaW5kZXggPT09IHkuaW5kZXgpKTtcbiAgICBjb25zdCBkZWFjdGl2YXRlZCA9IGRpZmYobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBhY3RpdmF0ZWQgPSByZXBsYXkgPyBhY3RpdmUgOiBkaWZmKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG5cbiAgICBpZiAoZGVhY3RpdmF0ZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoZGVhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2YXRlZC5sZW5ndGggJiYgaG92ZXJPcHRpb25zLm1vZGUpIHtcbiAgICAgIHRoaXMudXBkYXRlSG92ZXJTdHlsZShhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ldmVudEhhbmRsZXIoZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgcmVwbGF5LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGluQ2hhcnRBcmVhOiB0aGlzLmlzUG9pbnRJbkFyZWEoZSlcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50RmlsdGVyID0gKHBsdWdpbikgPT4gKHBsdWdpbi5vcHRpb25zLmV2ZW50cyB8fCB0aGlzLm9wdGlvbnMuZXZlbnRzKS5pbmNsdWRlcyhlLm5hdGl2ZS50eXBlKTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLl9oYW5kbGVFdmVudChlLCByZXBsYXksIGFyZ3MuaW5DaGFydEFyZWEpO1xuXG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpO1xuXG4gICAgaWYgKGNoYW5nZWQgfHwgYXJncy5jaGFuZ2VkKSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgdGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXBsYXldIC0gdHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHJlcGxheWVkIGJ5IGB1cGRhdGVgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luQ2hhcnRBcmVhXSAtIHRydWUgaWYgdGhlIGV2ZW50IGlzIGluc2lkZSBjaGFydEFyZWFcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hhcnQgbmVlZHMgdG8gcmUtcmVuZGVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IHtfYWN0aXZlOiBsYXN0QWN0aXZlID0gW10sIG9wdGlvbnN9ID0gdGhpcztcblxuICAgIC8vIElmIHRoZSBldmVudCBpcyByZXBsYXllZCBmcm9tIGB1cGRhdGVgLCB3ZSBzaG91bGQgZXZhbHVhdGUgd2l0aCB0aGUgZmluYWwgcG9zaXRpb25zLlxuICAgIC8vXG4gICAgLy8gVGhlIGByZXBsYXlgOlxuICAgIC8vIEl0J3MgdGhlIGxhc3QgZXZlbnQgKGV4Y2x1ZGluZyBjbGljaykgdGhhdCBoYXMgb2NjdXJyZWQgYmVmb3JlIGB1cGRhdGVgLlxuICAgIC8vIFNvIG1vdXNlIGhhcyBub3QgbW92ZWQuIEl0J3MgYWxzbyBvdmVyIHRoZSBjaGFydCwgYmVjYXVzZSB0aGVyZSBpcyBhIGByZXBsYXlgLlxuICAgIC8vXG4gICAgLy8gVGhlIHdoeTpcbiAgICAvLyBJZiBhbmltYXRpb25zIGFyZSBhY3RpdmUsIHRoZSBlbGVtZW50cyBoYXZlbid0IG1vdmVkIHlldCBjb21wYXJlZCB0byBzdGF0ZSBiZWZvcmUgdXBkYXRlLlxuICAgIC8vIEJ1dCBpZiB0aGV5IHdpbGwsIHdlIGFyZSBhY3RpdmF0aW5nIHRoZSBlbGVtZW50cyB0aGF0IHdvdWxkIGJlIGFjdGl2ZSwgaWYgdGhpcyBjaGVja1xuICAgIC8vIHdhcyBkb25lIGFmdGVyIHRoZSBhbmltYXRpb25zIGhhdmUgY29tcGxldGVkLiA9PiBcImZpbmFsIHBvc2l0aW9uc1wiLlxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFuaW1hdGlvbnMsIHRoZSBcImZpbmFsXCIgYW5kIFwiY3VycmVudFwiIHBvc2l0aW9ucyBhcmUgZXF1YWwuXG4gICAgLy8gVGhpcyBpcyBkb25lIHNvIHdlIGRvIG5vdCBoYXZlIHRvIGV2YWx1YXRlIHRoZSBhY3RpdmUgZWxlbWVudHMgZWFjaCBhbmltYXRpb24gZnJhbWVcbiAgICAvLyAtIGl0IHdvdWxkIGJlIGV4cGVuc2l2ZS5cbiAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gcmVwbGF5O1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBpc0NsaWNrID0gX2lzQ2xpY2tFdmVudChlKTtcbiAgICBjb25zdCBsYXN0RXZlbnQgPSBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgdGhpcy5fbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljayk7XG5cbiAgICBpZiAoaW5DaGFydEFyZWEpIHtcbiAgICAgIC8vIFNldCBfbGFzdEV2ZW50IHRvIG51bGwgd2hpbGUgd2UgYXJlIHByb2Nlc3NpbmcgdGhlIGV2ZW50IGhhbmRsZXJzLlxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyByZWN1cnNpb24gaWYgdGhlIGhhbmRsZXIgY2FsbHMgY2hhcnQudXBkYXRlKClcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgICAgIC8vIEludm9rZSBvbkhvdmVyIGhvb2tcbiAgICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uSG92ZXIsIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcblxuICAgICAgaWYgKGlzQ2xpY2spIHtcbiAgICAgICAgY2FsbENhbGxiYWNrKG9wdGlvbnMub25DbGljaywgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCB8fCByZXBsYXkpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KTtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBsYXN0RXZlbnQ7XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBUaGUgZXZlbnRcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQWN0aXZlRWxlbWVudFtdfSBsYXN0QWN0aXZlIC0gUHJldmlvdXNseSBhY3RpdmUgZWxlbWVudHNcbiAgICogQHBhcmFtIHtib29sZWFufSBpbkNoYXJ0QXJlYSAtIElzIHRoZSBlbnZlbnQgaW5zaWRlIGNoYXJ0QXJlYVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUZpbmFsUG9zaXRpb24gLSBTaG91bGQgdGhlIGV2YWx1YXRpb24gYmUgZG9uZSB3aXRoIGN1cnJlbnQgb3IgZmluYWwgKGFmdGVyIGFuaW1hdGlvbikgZWxlbWVudCBwb3NpdGlvbnNcbiAgICogQHJldHVybnMge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5BY3RpdmVFbGVtZW50W119IC0gVGhlIGFjdGl2ZSBlbGVtZW50c1xuICAgKiBAcHJhdmF0ZVxuICAgKi9cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIGluQ2hhcnRBcmVhLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIC8vIExldCB1c2VyIGNvbnRyb2wgdGhlIGFjdGl2ZSBlbGVtZW50cyBvdXRzaWRlIGNoYXJ0QXJlYS4gRWcuIHVzaW5nIExlZ2VuZC5cbiAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgIH1cblxuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG59XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGludmFsaWRhdGVQbHVnaW5zKCkge1xuICByZXR1cm4gZWFjaChDaGFydC5pbnN0YW5jZXMsIChjaGFydCkgPT4gY2hhcnQuX3BsdWdpbnMuaW52YWxpZGF0ZSgpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnQ7XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBnZXRBbmdsZUZyb21Qb2ludCwgVEFVLCBIQUxGX1BJLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge1BJLCBfaXNCZXR3ZWVuLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfcmVhZFZhbHVlVG9Qcm9wc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHR5cGUge0FyY09wdGlvbnMsIFBvaW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cblxuZnVuY3Rpb24gY2xpcEFyYyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZWxlbWVudDogQXJjRWxlbWVudCwgZW5kQW5nbGU6IG51bWJlcikge1xuICBjb25zdCB7c3RhcnRBbmdsZSwgcGl4ZWxNYXJnaW4sIHgsIHksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1c30gPSBlbGVtZW50O1xuICBsZXQgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIG91dGVyUmFkaXVzO1xuXG4gIC8vIERyYXcgYW4gaW5uZXIgYm9yZGVyIGJ5IGNsaXBwaW5nIHRoZSBhcmMgYW5kIGRyYXdpbmcgYSBkb3VibGUtd2lkdGggYm9yZGVyXG4gIC8vIEVubGFyZ2UgdGhlIGNsaXBwaW5nIGFyYyBieSAwLjMzIHBpeGVscyB0byBlbGltaW5hdGUgZ2xpdGNoZXMgYmV0d2VlbiBib3JkZXJzXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luKTtcbiAgaWYgKGlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcbiAgICBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gaW5uZXJSYWRpdXM7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbiwgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguYXJjKHgsIHksIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIEhBTEZfUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5cbmZ1bmN0aW9uIHRvUmFkaXVzQ29ybmVycyh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsnb3V0ZXJTdGFydCcsICdvdXRlckVuZCcsICdpbm5lclN0YXJ0JywgJ2lubmVyRW5kJ10pO1xufVxuXG4vKipcbiAqIFBhcnNlIGJvcmRlciByYWRpdXMgZnJvbSB0aGUgcHJvdmlkZWQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhhcmM6IEFyY0VsZW1lbnQsIGlubmVyUmFkaXVzOiBudW1iZXIsIG91dGVyUmFkaXVzOiBudW1iZXIsIGFuZ2xlRGVsdGE6IG51bWJlcikge1xuICBjb25zdCBvID0gdG9SYWRpdXNDb3JuZXJzKGFyYy5vcHRpb25zLmJvcmRlclJhZGl1cyk7XG4gIGNvbnN0IGhhbGZUaGlja25lc3MgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyAyO1xuICBjb25zdCBpbm5lckxpbWl0ID0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgYW5nbGVEZWx0YSAqIGlubmVyUmFkaXVzIC8gMik7XG5cbiAgLy8gT3V0ZXIgbGltaXRzIGFyZSBjb21wbGljYXRlZC4gV2Ugd2FudCB0byBjb21wdXRlIHRoZSBhdmFpbGFibGUgYW5ndWxhciBkaXN0YW5jZSBhdFxuICAvLyBhIHJhZGl1cyBvZiBvdXRlclJhZGl1cyAtIGJvcmRlclJhZGl1cyBiZWNhdXNlIGZvciBzbWFsbCBhbmd1bGFyIGRpc3RhbmNlcywgdGhpcyB0ZXJtIGxpbWl0cy5cbiAgLy8gV2UgY29tcHV0ZSBhdCByID0gb3V0ZXJSYWRpdXMgLSBib3JkZXJSYWRpdXMgYmVjYXVzZSB0aGlzIGNpcmNsZSBkZWZpbmVzIHRoZSBjZW50ZXIgb2YgdGhlIGJvcmRlciBjb3JuZXJzLlxuICAvL1xuICAvLyBJZiB0aGUgYm9yZGVyUmFkaXVzIGlzIGxhcmdlLCB0aGF0IHZhbHVlIGNhbiBiZWNvbWUgbmVnYXRpdmUuXG4gIC8vIFRoaXMgY2F1c2VzIHRoZSBvdXRlciBib3JkZXJzIHRvIGxvc2UgdGhlaXIgcmFkaXVzIGVudGlyZWx5LCB3aGljaCBpcyByYXRoZXIgdW5leHBlY3RlZC4gVG8gc29sdmUgdGhhdCwgaWYgYm9yZGVyUmFkaXVzID4gb3V0ZXJSYWRpdXNcbiAgLy8gd2Uga25vdyB0aGF0IHRoZSB0aGlja25lc3MgdGVybSB3aWxsIGRvbWluYXRlIGFuZCBjb21wdXRlIHRoZSBsaW1pdHMgYXQgdGhhdCBwb2ludFxuICBjb25zdCBjb21wdXRlT3V0ZXJMaW1pdCA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBvdXRlckFyY0xpbWl0ID0gKG91dGVyUmFkaXVzIC0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgdmFsKSkgKiBhbmdsZURlbHRhIC8gMjtcbiAgICByZXR1cm4gX2xpbWl0VmFsdWUodmFsLCAwLCBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBvdXRlckFyY0xpbWl0KSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvdXRlclN0YXJ0OiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyU3RhcnQpLFxuICAgIG91dGVyRW5kOiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyRW5kKSxcbiAgICBpbm5lclN0YXJ0OiBfbGltaXRWYWx1ZShvLmlubmVyU3RhcnQsIDAsIGlubmVyTGltaXQpLFxuICAgIGlubmVyRW5kOiBfbGltaXRWYWx1ZShvLmlubmVyRW5kLCAwLCBpbm5lckxpbWl0KSxcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IChyLCDwnZyDKSB0byAoeCwgeSlcbiAqL1xuZnVuY3Rpb24gclRoZXRhVG9YWShyOiBudW1iZXIsIHRoZXRhOiBudW1iZXIsIHg6IG51bWJlciwgeTogbnVtYmVyKSB7XG4gIHJldHVybiB7XG4gICAgeDogeCArIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgeTogeSArIHIgKiBNYXRoLnNpbih0aGV0YSksXG4gIH07XG59XG5cblxuLyoqXG4gKiBQYXRoIHRoZSBhcmMsIHJlc3BlY3RpbmcgYm9yZGVyIHJhZGl1cyBieSBzZXBhcmF0aW5nIGludG8gbGVmdCBhbmQgcmlnaHQgaGFsdmVzLlxuICpcbiAqICAgU3RhcnQgICAgICBFbmRcbiAqXG4gKiAgICAxLS0tPmEtLS0+MiAgICBPdXRlclxuICogICAvICAgICAgICAgICBcXFxuICogICA4ICAgICAgICAgICAzXG4gKiAgIHwgICAgICAgICAgIHxcbiAqICAgfCAgICAgICAgICAgfFxuICogICA3ICAgICAgICAgICA0XG4gKiAgIFxcICAgICAgICAgICAvXG4gKiAgICA2PC0tLWI8LS0tNSAgICBJbm5lclxuICovXG5mdW5jdGlvbiBwYXRoQXJjKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZWxlbWVudDogQXJjRWxlbWVudCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlcixcbiAgZW5kOiBudW1iZXIsXG4gIGNpcmN1bGFyOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlOiBzdGFydCwgcGl4ZWxNYXJnaW4sIGlubmVyUmFkaXVzOiBpbm5lclJ9ID0gZWxlbWVudDtcblxuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0IC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgKyBzcGFjaW5nICsgb2Zmc2V0ICsgcGl4ZWxNYXJnaW4gOiAwO1xuXG4gIGxldCBzcGFjaW5nT2Zmc2V0ID0gMDtcbiAgY29uc3QgYWxwaGEgPSBlbmQgLSBzdGFydDtcblxuICBpZiAoc3BhY2luZykge1xuICAgIC8vIFdoZW4gc3BhY2luZyBpcyBwcmVzZW50LCBpdCBpcyB0aGUgc2FtZSBmb3IgYWxsIGl0ZW1zXG4gICAgLy8gU28gd2UgYWRqdXN0IHRoZSBzdGFydCBhbmQgZW5kIGFuZ2xlIG9mIHRoZSBhcmMgc3VjaCB0aGF0XG4gICAgLy8gdGhlIGRpc3RhbmNlIGlzIHRoZSBzYW1lIGFzIGl0IHdvdWxkIGJlIHdpdGhvdXQgdGhlIHNwYWNpbmdcbiAgICBjb25zdCBub1NwYWNpbmdJbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBub1NwYWNpbmdPdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzID4gMCA/IG91dGVyUmFkaXVzIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3QgYXZOb2dTcGFjaW5nUmFkaXVzID0gKG5vU3BhY2luZ0lubmVyUmFkaXVzICsgbm9TcGFjaW5nT3V0ZXJSYWRpdXMpIC8gMjtcbiAgICBjb25zdCBhZGp1c3RlZEFuZ2xlID0gYXZOb2dTcGFjaW5nUmFkaXVzICE9PSAwID8gKGFscGhhICogYXZOb2dTcGFjaW5nUmFkaXVzKSAvIChhdk5vZ1NwYWNpbmdSYWRpdXMgKyBzcGFjaW5nKSA6IGFscGhhO1xuICAgIHNwYWNpbmdPZmZzZXQgPSAoYWxwaGEgLSBhZGp1c3RlZEFuZ2xlKSAvIDI7XG4gIH1cblxuICBjb25zdCBiZXRhID0gTWF0aC5tYXgoMC4wMDEsIGFscGhhICogb3V0ZXJSYWRpdXMgLSBvZmZzZXQgLyBQSSkgLyBvdXRlclJhZGl1cztcbiAgY29uc3QgYW5nbGVPZmZzZXQgPSAoYWxwaGEgLSBiZXRhKSAvIDI7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydCArIGFuZ2xlT2Zmc2V0ICsgc3BhY2luZ09mZnNldDtcbiAgY29uc3QgZW5kQW5nbGUgPSBlbmQgLSBhbmdsZU9mZnNldCAtIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IHtvdXRlclN0YXJ0LCBvdXRlckVuZCwgaW5uZXJTdGFydCwgaW5uZXJFbmR9ID0gcGFyc2VCb3JkZXJSYWRpdXMoZWxlbWVudCwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuXG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJTdGFydDtcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJFbmQ7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIG91dGVyU3RhcnQgLyBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gb3V0ZXJFbmQgLyBvdXRlckVuZEFkanVzdGVkUmFkaXVzO1xuXG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJTdGFydDtcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJFbmQ7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIGlubmVyU3RhcnQgLyBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gaW5uZXJFbmQgLyBpbm5lckVuZEFkanVzdGVkUmFkaXVzO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICBpZiAoY2lyY3VsYXIpIHtcbiAgICAvLyBUaGUgZmlyc3QgYXJjIHNlZ21lbnRzIGZyb20gcG9pbnQgMSB0byBwb2ludCBhIHRvIHBvaW50IDJcbiAgICBjb25zdCBvdXRlck1pZEFkanVzdGVkQW5nbGUgPSAob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgKyBvdXRlckVuZEFkanVzdGVkQW5nbGUpIC8gMjtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgb3V0ZXJNaWRBZGp1c3RlZEFuZ2xlKTtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlck1pZEFkanVzdGVkQW5nbGUsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCAyIHRvIHBvaW50IDNcbiAgICBpZiAob3V0ZXJFbmQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlckVuZEFkanVzdGVkUmFkaXVzLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJFbmQsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgZW5kQW5nbGUgKyBIQUxGX1BJKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgbGluZSBmcm9tIHBvaW50IDMgdG8gcG9pbnQgNFxuICAgIGNvbnN0IHA0ID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBlbmRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwNC54LCBwNC55KTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDQgdG8gcG9pbnQgNVxuICAgIGlmIChpbm5lckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lckVuZCwgZW5kQW5nbGUgKyBIQUxGX1BJLCBpbm5lckVuZEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgaW5uZXIgYXJjIGZyb20gcG9pbnQgNSB0byBwb2ludCBiIHRvIHBvaW50IDZcbiAgICBjb25zdCBpbm5lck1pZEFkanVzdGVkQW5nbGUgPSAoKGVuZEFuZ2xlIC0gKGlubmVyRW5kIC8gaW5uZXJSYWRpdXMpKSArIChzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cykpKSAvIDI7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgLSAoaW5uZXJFbmQgLyBpbm5lclJhZGl1cyksIGlubmVyTWlkQWRqdXN0ZWRBbmdsZSwgdHJ1ZSk7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgaW5uZXJNaWRBZGp1c3RlZEFuZ2xlLCBzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cyksIHRydWUpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgNiB0byBwb2ludCA3XG4gICAgaWYgKGlubmVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyU3RhcnQsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICAgIH1cblxuICAgIC8vIFRoZSBsaW5lIGZyb20gcG9pbnQgNyB0byBwb2ludCA4XG4gICAgY29uc3QgcDggPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgc3RhcnRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwOC54LCBwOC55KTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDggdG8gcG9pbnQgMVxuICAgIGlmIChvdXRlclN0YXJ0ID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlclN0YXJ0LCBzdGFydEFuZ2xlIC0gSEFMRl9QSSwgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuXG4gICAgY29uc3Qgb3V0ZXJTdGFydFggPSBNYXRoLmNvcyhvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHg7XG4gICAgY29uc3Qgb3V0ZXJTdGFydFkgPSBNYXRoLnNpbihvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlclN0YXJ0WCwgb3V0ZXJTdGFydFkpO1xuXG4gICAgY29uc3Qgb3V0ZXJFbmRYID0gTWF0aC5jb3Mob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlckVuZFkgPSBNYXRoLnNpbihvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgIGN0eC5saW5lVG8ob3V0ZXJFbmRYLCBvdXRlckVuZFkpO1xuICB9XG5cbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuXG5mdW5jdGlvbiBkcmF3QXJjKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZWxlbWVudDogQXJjRWxlbWVudCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlcixcbiAgY2lyY3VsYXI6IGJvb2xlYW4sXG4pIHtcbiAgY29uc3Qge2Z1bGxDaXJjbGVzLCBzdGFydEFuZ2xlLCBjaXJjdW1mZXJlbmNlfSA9IGVsZW1lbnQ7XG4gIGxldCBlbmRBbmdsZSA9IGVsZW1lbnQuZW5kQW5nbGU7XG4gIGlmIChmdWxsQ2lyY2xlcykge1xuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoY2lyY3VtZmVyZW5jZSAlIFRBVSB8fCBUQVUpO1xuICAgIH1cbiAgfVxuICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICBjdHguZmlsbCgpO1xuICByZXR1cm4gZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIGRyYXdCb3JkZXIoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBlbGVtZW50OiBBcmNFbGVtZW50LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgc3BhY2luZzogbnVtYmVyLFxuICBjaXJjdWxhcjogYm9vbGVhbixcbikge1xuICBjb25zdCB7ZnVsbENpcmNsZXMsIHN0YXJ0QW5nbGUsIGNpcmN1bWZlcmVuY2UsIG9wdGlvbnN9ID0gZWxlbWVudDtcbiAgY29uc3Qge2JvcmRlcldpZHRoLCBib3JkZXJKb2luU3R5bGUsIGJvcmRlckRhc2gsIGJvcmRlckRhc2hPZmZzZXR9ID0gb3B0aW9ucztcbiAgY29uc3QgaW5uZXIgPSBvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInO1xuXG4gIGlmICghYm9yZGVyV2lkdGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguc2V0TGluZURhc2goYm9yZGVyRGFzaCB8fCBbXSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgaWYgKGlubmVyKSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoICogMjtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ3JvdW5kJztcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdiZXZlbCc7XG4gIH1cblxuICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICBpZiAoZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoY2lyY3VtZmVyZW5jZSAlIFRBVSB8fCBUQVUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSk7XG4gIH1cblxuICBpZiAoIWZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcmNQcm9wcyBleHRlbmRzIFBvaW50IHtcbiAgc3RhcnRBbmdsZTogbnVtYmVyO1xuICBlbmRBbmdsZTogbnVtYmVyO1xuICBpbm5lclJhZGl1czogbnVtYmVyO1xuICBvdXRlclJhZGl1czogbnVtYmVyO1xuICBjaXJjdW1mZXJlbmNlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyY0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PEFyY1Byb3BzLCBBcmNPcHRpb25zPiB7XG5cbiAgc3RhdGljIGlkID0gJ2FyYyc7XG5cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlckFsaWduOiAnY2VudGVyJyxcbiAgICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gICAgYm9yZGVySm9pblN0eWxlOiB1bmRlZmluZWQsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIGJvcmRlcldpZHRoOiAyLFxuICAgIG9mZnNldDogMCxcbiAgICBzcGFjaW5nOiAwLFxuICAgIGFuZ2xlOiB1bmRlZmluZWQsXG4gICAgY2lyY3VsYXI6IHRydWUsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJ1xuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnXG4gIH07XG5cbiAgY2lyY3VtZmVyZW5jZTogbnVtYmVyO1xuICBlbmRBbmdsZTogbnVtYmVyO1xuICBmdWxsQ2lyY2xlczogbnVtYmVyO1xuICBpbm5lclJhZGl1czogbnVtYmVyO1xuICBvdXRlclJhZGl1czogbnVtYmVyO1xuICBwaXhlbE1hcmdpbjogbnVtYmVyO1xuICBzdGFydEFuZ2xlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNpcmN1bWZlcmVuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kQW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSAwO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIGluUmFuZ2UoY2hhcnRYOiBudW1iZXIsIGNoYXJ0WTogbnVtYmVyLCB1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZSwgZGlzdGFuY2V9ID0gZ2V0QW5nbGVGcm9tUG9pbnQocG9pbnQsIHt4OiBjaGFydFgsIHk6IGNoYXJ0WX0pO1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgckFkanVzdCA9ICh0aGlzLm9wdGlvbnMuc3BhY2luZyArIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCkgLyAyO1xuICAgIGNvbnN0IF9jaXJjdW1mZXJlbmNlID0gdmFsdWVPckRlZmF1bHQoY2lyY3VtZmVyZW5jZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBiZXR3ZWVuQW5nbGVzID0gX2NpcmN1bWZlcmVuY2UgPj0gVEFVIHx8IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICBjb25zdCB3aXRoaW5SYWRpdXMgPSBfaXNCZXR3ZWVuKGRpc3RhbmNlLCBpbm5lclJhZGl1cyArIHJBZGp1c3QsIG91dGVyUmFkaXVzICsgckFkanVzdCk7XG5cbiAgICByZXR1cm4gKGJldHdlZW5BbmdsZXMgJiYgd2l0aGluUmFkaXVzKTtcbiAgfVxuXG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pIHtcbiAgICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1c30gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICd4JyxcbiAgICAgICd5JyxcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJ1xuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHtvZmZzZXQsIHNwYWNpbmd9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGhhbGZBbmdsZSA9IChzdGFydEFuZ2xlICsgZW5kQW5nbGUpIC8gMjtcbiAgICBjb25zdCBoYWxmUmFkaXVzID0gKGlubmVyUmFkaXVzICsgb3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0KSAvIDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhoYWxmQW5nbGUpICogaGFsZlJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xuICAgIH07XG4gIH1cblxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gKG9wdGlvbnMub2Zmc2V0IHx8IDApIC8gNDtcbiAgICBjb25zdCBzcGFjaW5nID0gKG9wdGlvbnMuc3BhY2luZyB8fCAwKSAvIDI7XG4gICAgY29uc3QgY2lyY3VsYXIgPSBvcHRpb25zLmNpcmN1bGFyO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAob3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykgPyAwLjMzIDogMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gY2lyY3VtZmVyZW5jZSA+IFRBVSA/IE1hdGguZmxvb3IoY2lyY3VtZmVyZW5jZSAvIFRBVSkgOiAwO1xuXG4gICAgaWYgKGNpcmN1bWZlcmVuY2UgPT09IDAgfHwgdGhpcy5pbm5lclJhZGl1cyA8IDAgfHwgdGhpcy5vdXRlclJhZGl1cyA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgY29uc3QgaGFsZkFuZ2xlID0gKHRoaXMuc3RhcnRBbmdsZSArIHRoaXMuZW5kQW5nbGUpIC8gMjtcbiAgICBjdHgudHJhbnNsYXRlKE1hdGguY29zKGhhbGZBbmdsZSkgKiBvZmZzZXQsIE1hdGguc2luKGhhbGZBbmdsZSkgKiBvZmZzZXQpO1xuICAgIGNvbnN0IGZpeCA9IDEgLSBNYXRoLnNpbihNYXRoLm1pbihQSSwgY2lyY3VtZmVyZW5jZSB8fCAwKSk7XG4gICAgY29uc3QgcmFkaXVzT2Zmc2V0ID0gb2Zmc2V0ICogZml4O1xuXG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG5cbiAgICBkcmF3QXJjKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcik7XG4gICAgZHJhd0JvcmRlcihjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7X2JlemllckludGVycG9sYXRpb24sIF9wb2ludEluTGluZSwgX3N0ZXBwZWRJbnRlcnBvbGF0aW9ufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50ZXJwb2xhdGlvbi5qcyc7XG5pbXBvcnQge19jb21wdXRlU2VnbWVudHMsIF9ib3VuZFNlZ21lbnRzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuc2VnbWVudC5qcyc7XG5pbXBvcnQge19zdGVwcGVkTGluZVRvLCBfYmV6aWVyQ3VydmVUb30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge191cGRhdGVCZXppZXJDb250cm9sUG9pbnRzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY3VydmUuanMnO1xuaW1wb3J0IHt2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHN0eWxlID0gb3B0aW9ucykge1xuICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNhcFN0eWxlLCBvcHRpb25zLmJvcmRlckNhcFN0eWxlKTtcbiAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2gsIG9wdGlvbnMuYm9yZGVyRGFzaCkpO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LCBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQpO1xuICBjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJKb2luU3R5bGUsIG9wdGlvbnMuYm9yZGVySm9pblN0eWxlKTtcbiAgY3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ29sb3IsIG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xufVxuXG5mdW5jdGlvbiBsaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0KSB7XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBnZXRMaW5lTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZExpbmVUbztcbiAgfVxuXG4gIGlmIChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgcmV0dXJuIF9iZXppZXJDdXJ2ZVRvO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVUbztcbn1cblxuZnVuY3Rpb24gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMgPSB7fSkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHtzdGFydDogcGFyYW1zU3RhcnQgPSAwLCBlbmQ6IHBhcmFtc0VuZCA9IGNvdW50IC0gMX0gPSBwYXJhbXM7XG4gIGNvbnN0IHtzdGFydDogc2VnbWVudFN0YXJ0LCBlbmQ6IHNlZ21lbnRFbmR9ID0gc2VnbWVudDtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChwYXJhbXNTdGFydCwgc2VnbWVudFN0YXJ0KTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4ocGFyYW1zRW5kLCBzZWdtZW50RW5kKTtcbiAgY29uc3Qgb3V0c2lkZSA9IHBhcmFtc1N0YXJ0IDwgc2VnbWVudFN0YXJ0ICYmIHBhcmFtc0VuZCA8IHNlZ21lbnRTdGFydCB8fCBwYXJhbXNTdGFydCA+IHNlZ21lbnRFbmQgJiYgcGFyYW1zRW5kID4gc2VnbWVudEVuZDtcblxuICByZXR1cm4ge1xuICAgIGNvdW50LFxuICAgIHN0YXJ0LFxuICAgIGxvb3A6IHNlZ21lbnQubG9vcCxcbiAgICBpbGVuOiBlbmQgPCBzdGFydCAmJiAhb3V0c2lkZSA/IGNvdW50ICsgZW5kIC0gc3RhcnQgOiBlbmQgLSBzdGFydFxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBwYXRoIGZyb20gcG9pbnRzLCBncm91cGluZyBieSB0cnVuY2F0ZWQgeC1jb29yZGluYXRlXG4gKiBQb2ludHMgbmVlZCB0byBiZSBpbiBvcmRlciBieSB4LWNvb3JkaW5hdGUgZm9yIHRoaXMgdG8gd29yayBlZmZpY2llbnRseVxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8UGF0aDJEfSBjdHggLSBDb250ZXh0XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuc3RhcnQgLSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LmVuZCAtIGVuZCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VnbWVudC5sb29wIC0gaW5kaWNhdGVzIHRoYXQgdGhlIHNlZ21lbnQgaXMgYSBsb29wXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5tb3ZlIC0gbW92ZSB0byBzdGFydGluZyBwb2ludCAodnMgbGluZSB0byBpdClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnJldmVyc2UgLSBwYXRoIHRoZSBzZWdtZW50IGZyb20gZW5kIHRvIHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIGVuZGluZyBhdCBgc3RhcnRgICsgYGNvdW50YCBpbmRleFxuICovXG5mdW5jdGlvbiBwYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCB7cG9pbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGxvb3AsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCBsaW5lTWV0aG9kID0gZ2V0TGluZU1ldGhvZChvcHRpb25zKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGksIHBvaW50LCBwcmV2O1xuXG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaSA6IGkpKSAlIGNvdW50XTtcblxuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHNraXBwZWQgcG9pbnQgaW5zaWRlIGEgc2VnbWVudCwgc3BhbkdhcHMgbXVzdCBiZSB0cnVlXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKG1vdmUpIHtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBtb3ZlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICB9XG5cbiAgICBwcmV2ID0gcG9pbnQ7XG4gIH1cblxuICBpZiAobG9vcCkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiA6IDApKSAlIGNvdW50XTtcbiAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gIH1cblxuICByZXR1cm4gISFsb29wO1xufVxuXG4vKipcbiAqIENyZWF0ZSBwYXRoIGZyb20gcG9pbnRzLCBncm91cGluZyBieSB0cnVuY2F0ZWQgeC1jb29yZGluYXRlXG4gKiBQb2ludHMgbmVlZCB0byBiZSBpbiBvcmRlciBieSB4LWNvb3JkaW5hdGUgZm9yIHRoaXMgdG8gd29yayBlZmZpY2llbnRseVxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8UGF0aDJEfSBjdHggLSBDb250ZXh0XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuc3RhcnQgLSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LmVuZCAtIGVuZCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VnbWVudC5sb29wIC0gaW5kaWNhdGVzIHRoYXQgdGhlIHNlZ21lbnQgaXMgYSBsb29wXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5tb3ZlIC0gbW92ZSB0byBzdGFydGluZyBwb2ludCAodnMgbGluZSB0byBpdClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnJldmVyc2UgLSBwYXRoIHRoZSBzZWdtZW50IGZyb20gZW5kIHRvIHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIGVuZGluZyBhdCBgc3RhcnRgICsgYGNvdW50YCBpbmRleFxuICovXG5mdW5jdGlvbiBmYXN0UGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCB7bW92ZSA9IHRydWUsIHJldmVyc2V9ID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgYXZnWCA9IDA7XG4gIGxldCBjb3VudFggPSAwO1xuICBsZXQgaSwgcG9pbnQsIHByZXZYLCBtaW5ZLCBtYXhZLCBsYXN0WTtcblxuICBjb25zdCBwb2ludEluZGV4ID0gKGluZGV4KSA9PiAoc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpbmRleCA6IGluZGV4KSkgJSBjb3VudDtcbiAgY29uc3QgZHJhd1ggPSAoKSA9PiB7XG4gICAgaWYgKG1pblkgIT09IG1heFkpIHtcbiAgICAgIC8vIERyYXcgbGluZSB0byBtYXhZIGFuZCBtaW5ZLCB1c2luZyB0aGUgYXZlcmFnZSB4LWNvb3JkaW5hdGVcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWF4WSk7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1pblkpO1xuICAgICAgLy8gTGluZSB0byB5LXZhbHVlIG9mIGxhc3QgcG9pbnQgaW4gZ3JvdXAuIFNvIHRoZSBsaW5lIGNvbnRpbnVlc1xuICAgICAgLy8gZnJvbSBjb3JyZWN0IHBvc2l0aW9uLiBOb3QgdXNpbmcgbW92ZSwgdG8gaGF2ZSBzb2xpZCBwYXRoLlxuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBsYXN0WSk7XG4gICAgfVxuICB9O1xuXG4gIGlmIChtb3ZlKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleCgwKV07XG4gICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleChpKV07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBza2lwcGVkIHBvaW50IGluc2lkZSBhIHNlZ21lbnQsIHNwYW5HYXBzIG11c3QgYmUgdHJ1ZVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgeCA9IHBvaW50Lng7XG4gICAgY29uc3QgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7IC8vIHRydW5jYXRlZCB4LWNvb3JkaW5hdGVcblxuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICAvLyBEZXRlcm1pbmUgYG1pbllgIC8gYG1heFlgIGFuZCBgYXZnWGAgd2hpbGUgd2Ugc3RheSB3aXRoaW4gc2FtZSB4LXBvc2l0aW9uXG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgfVxuICAgICAgLy8gRm9yIGZpcnN0IHBvaW50IGluIGdyb3VwLCBjb3VudFggaXMgYDBgLCBzbyBhdmVyYWdlIHdpbGwgYmUgYHhgIC8gMS5cbiAgICAgIGF2Z1ggPSAoY291bnRYICogYXZnWCArIHgpIC8gKytjb3VudFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXdYKCk7XG4gICAgICAvLyBEcmF3IGxpbmUgdG8gbmV4dCB4LXBvc2l0aW9uLCB1c2luZyB0aGUgZmlyc3QgKG9yIG9ubHkpXG4gICAgICAvLyB5LXZhbHVlIGluIHRoYXQgZ3JvdXBcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG5cbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICB9XG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGFzdCB5LXZhbHVlIGluIGdyb3VwXG4gICAgbGFzdFkgPSB5O1xuICB9XG4gIGRyYXdYKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZSAtIHRoZSBsaW5lXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKSB7XG4gIGNvbnN0IG9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzLmJvcmRlckRhc2ggJiYgb3B0cy5ib3JkZXJEYXNoLmxlbmd0aDtcbiAgY29uc3QgdXNlRmFzdFBhdGggPSAhbGluZS5fZGVjaW1hdGVkICYmICFsaW5lLl9sb29wICYmICFvcHRzLnRlbnNpb24gJiYgb3B0cy5jdWJpY0ludGVycG9sYXRpb25Nb2RlICE9PSAnbW9ub3RvbmUnICYmICFvcHRzLnN0ZXBwZWQgJiYgIWJvcmRlckRhc2g7XG4gIHJldHVybiB1c2VGYXN0UGF0aCA/IGZhc3RQYXRoU2VnbWVudCA6IHBhdGhTZWdtZW50O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZEludGVycG9sYXRpb247XG4gIH1cblxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVySW50ZXJwb2xhdGlvbjtcbiAgfVxuXG4gIHJldHVybiBfcG9pbnRJbkxpbmU7XG59XG5cbmZ1bmN0aW9uIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgbGV0IHBhdGggPSBsaW5lLl9wYXRoO1xuICBpZiAoIXBhdGgpIHtcbiAgICBwYXRoID0gbGluZS5fcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICBpZiAobGluZS5wYXRoKHBhdGgsIHN0YXJ0LCBjb3VudCkpIHtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XG4gIHNldFN0eWxlKGN0eCwgbGluZS5vcHRpb25zKTtcbiAgY3R4LnN0cm9rZShwYXRoKTtcbn1cblxuZnVuY3Rpb24gc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCB7c2VnbWVudHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpO1xuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc2VnbWVudC5zdHlsZSk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGlmIChzZWdtZW50TWV0aG9kKGN0eCwgbGluZSwgc2VnbWVudCwge3N0YXJ0LCBlbmQ6IHN0YXJ0ICsgY291bnQgLSAxfSkpIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmNvbnN0IHVzZVBhdGgyRCA9IHR5cGVvZiBQYXRoMkQgPT09ICdmdW5jdGlvbic7XG5cbmZ1bmN0aW9uIGRyYXcoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgaWYgKHVzZVBhdGgyRCAmJiAhbGluZS5vcHRpb25zLnNlZ21lbnQpIHtcbiAgICBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIHN0YXRpYyBpZCA9ICdsaW5lJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gICAgYm9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuICAgIGJvcmRlcldpZHRoOiAzLFxuICAgIGNhcEJlemllclBvaW50czogdHJ1ZSxcbiAgICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiAnZGVmYXVsdCcsXG4gICAgZmlsbDogZmFsc2UsXG4gICAgc3BhbkdhcHM6IGZhbHNlLFxuICAgIHN0ZXBwZWQ6IGZhbHNlLFxuICAgIHRlbnNpb246IDAsXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG4gIH07XG5cblxuICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAnZmlsbCcsXG4gIH07XG5cblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5hbmltYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NoYXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnVsbExvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2VnbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZGVjaW1hdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGFzZXRJbmRleCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDb250cm9sUG9pbnRzKGNoYXJ0QXJlYSwgaW5kZXhBeGlzKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpICYmICFvcHRpb25zLnN0ZXBwZWQgJiYgIXRoaXMuX3BvaW50c1VwZGF0ZWQpIHtcbiAgICAgIGNvbnN0IGxvb3AgPSBvcHRpb25zLnNwYW5HYXBzID8gdGhpcy5fbG9vcCA6IHRoaXMuX2Z1bGxMb29wO1xuICAgICAgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHModGhpcy5fcG9pbnRzLCBvcHRpb25zLCBjaGFydEFyZWEsIGxvb3AsIGluZGV4QXhpcyk7XG4gICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBzZXQgcG9pbnRzKHBvaW50cykge1xuICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICBkZWxldGUgdGhpcy5fc2VnbWVudHM7XG4gICAgZGVsZXRlIHRoaXMuX3BhdGg7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgZ2V0IHBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICB9XG5cbiAgZ2V0IHNlZ21lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWdtZW50cyB8fCAodGhpcy5fc2VnbWVudHMgPSBfY29tcHV0ZVNlZ21lbnRzKHRoaXMsIHRoaXMub3B0aW9ucy5zZWdtZW50KSk7XG4gIH1cblxuICAvKipcblx0ICogRmlyc3Qgbm9uLXNraXBwZWQgcG9pbnQgb24gdGhpcyBsaW5lXG5cdCAqIEByZXR1cm5zIHtQb2ludEVsZW1lbnR8dW5kZWZpbmVkfVxuXHQgKi9cbiAgZmlyc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggJiYgcG9pbnRzW3NlZ21lbnRzWzBdLnN0YXJ0XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBMYXN0IG5vbi1za2lwcGVkIHBvaW50IG9uIHRoaXMgbGluZVxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGxhc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGNvbnN0IGNvdW50ID0gc2VnbWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBjb3VudCAmJiBwb2ludHNbc2VnbWVudHNbY291bnQgLSAxXS5lbmRdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEludGVycG9sYXRlIGEgcG9pbnQgaW4gdGhpcyBsaW5lIGF0IHRoZSBzYW1lIHZhbHVlIG9uIGBwcm9wZXJ0eWAgYXNcblx0ICogdGhlIHJlZmVyZW5jZSBgcG9pbnRgIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSB7UG9pbnRFbGVtZW50fSBwb2ludCAtIHRoZSByZWZlcmVuY2UgcG9pbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gdGhlIHByb3BlcnR5IHRvIG1hdGNoIG9uXG5cdCAqIEByZXR1cm5zIHtQb2ludEVsZW1lbnR8dW5kZWZpbmVkfVxuXHQgKi9cbiAgaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBzZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRoaXMsIHtwcm9wZXJ0eSwgc3RhcnQ6IHZhbHVlLCBlbmQ6IHZhbHVlfSk7XG5cbiAgICBpZiAoIXNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IF9pbnRlcnBvbGF0ZSA9IF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnRzW2ldO1xuICAgICAgY29uc3QgcDEgPSBwb2ludHNbc3RhcnRdO1xuICAgICAgY29uc3QgcDIgPSBwb2ludHNbZW5kXTtcbiAgICAgIGlmIChwMSA9PT0gcDIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHQgPSBNYXRoLmFicygodmFsdWUgLSBwMVtwcm9wZXJ0eV0pIC8gKHAyW3Byb3BlcnR5XSAtIHAxW3Byb3BlcnR5XSkpO1xuICAgICAgY29uc3QgaW50ZXJwb2xhdGVkID0gX2ludGVycG9sYXRlKHAxLCBwMiwgdCwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICAgIGludGVycG9sYXRlZFtwcm9wZXJ0eV0gPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgICByZXN1bHQucHVzaChpbnRlcnBvbGF0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBcHBlbmQgYSBzZWdtZW50IG9mIHRoaXMgbGluZSB0byBjdXJyZW50IHBhdGguXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuc3RhcnQgLSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiBcdCAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LmVuZCAtIGVuZCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiBcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VnbWVudC5sb29wIC0gaW5kaWNhdGVzIHRoYXQgdGhlIHNlZ21lbnQgaXMgYSBsb29wXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcblx0ICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnJldmVyc2UgLSBwYXRoIHRoZSBzZWdtZW50IGZyb20gZW5kIHRvIHN0YXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RhcnQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBzdGFydGluZyBmcm9tIGBzdGFydGAgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcblx0ICogQHJldHVybnMge3VuZGVmaW5lZHxib29sZWFufSAtIHRydWUgaWYgdGhlIHNlZ21lbnQgaXMgYSBmdWxsIGxvb3AgKHBhdGggc2hvdWxkIGJlIGNsb3NlZClcblx0ICovXG4gIHBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwgcGFyYW1zKSB7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIHJldHVybiBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBcHBlbmQgYWxsIHNlZ21lbnRzIG9mIHRoaXMgbGluZSB0byBjdXJyZW50IHBhdGguXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbY291bnRdXG5cdCAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gLSB0cnVlIGlmIGxpbmUgaXMgYSBmdWxsIGxvb3AgKHBhdGggc2hvdWxkIGJlIGNsb3NlZClcblx0ICovXG4gIHBhdGgoY3R4LCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIGxldCBsb29wID0gdGhpcy5fbG9vcDtcblxuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICBjb3VudCA9IGNvdW50IHx8ICh0aGlzLnBvaW50cy5sZW5ndGggLSBzdGFydCk7XG5cbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgIGxvb3AgJj0gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pO1xuICAgIH1cbiAgICByZXR1cm4gISFsb29wO1xuICB9XG5cbiAgLyoqXG5cdCAqIERyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcGFyYW0ge29iamVjdH0gY2hhcnRBcmVhXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbY291bnRdXG5cdCAqL1xuICBkcmF3KGN0eCwgY2hhcnRBcmVhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzIHx8IFtdO1xuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCkge1xuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgZHJhdyhjdHgsIHRoaXMsIHN0YXJ0LCBjb3VudCk7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYW5pbWF0ZWQpIHtcbiAgICAgIC8vIFdoZW4gbGluZSBpcyBhbmltYXRlZCwgdGhlIGNvbnRyb2wgcG9pbnRzIGFuZCBwYXRoIGFyZSBub3QgY2FjaGVkLlxuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge2RyYXdQb2ludCwgX2lzUG9pbnRJbkFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHR5cGUge1xuICBDYXJ0ZXNpYW5QYXJzZWREYXRhLFxuICBDaGFydEFyZWEsXG4gIFBvaW50LFxuICBQb2ludEhvdmVyT3B0aW9ucyxcbiAgUG9pbnRPcHRpb25zLFxufSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGluUmFuZ2UoZWw6IFBvaW50RWxlbWVudCwgcG9zOiBudW1iZXIsIGF4aXM6ICd4JyB8ICd5JywgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGVsLm9wdGlvbnM7XG4gIGNvbnN0IHtbYXhpc106IHZhbHVlfSA9IGVsLmdldFByb3BzKFtheGlzXSwgdXNlRmluYWxQb3NpdGlvbik7XG5cbiAgcmV0dXJuIChNYXRoLmFicyhwb3MgLSB2YWx1ZSkgPCBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzKTtcbn1cblxuZXhwb3J0IHR5cGUgUG9pbnRQcm9wcyA9IFBvaW50XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ8UG9pbnRQcm9wcywgUG9pbnRPcHRpb25zICYgUG9pbnRIb3Zlck9wdGlvbnM+IHtcblxuICBzdGF0aWMgaWQgPSAncG9pbnQnO1xuXG4gIHBhcnNlZDogQ2FydGVzaWFuUGFyc2VkRGF0YTtcbiAgc2tpcD86IGJvb2xlYW47XG4gIHN0b3A/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlcldpZHRoOiAxLFxuICAgIGhpdFJhZGl1czogMSxcbiAgICBob3ZlckJvcmRlcldpZHRoOiAxLFxuICAgIGhvdmVyUmFkaXVzOiA0LFxuICAgIHBvaW50U3R5bGU6ICdjaXJjbGUnLFxuICAgIHJhZGl1czogMyxcbiAgICByb3RhdGlvbjogMFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5za2lwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RvcCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICBpblJhbmdlKG1vdXNlWDogbnVtYmVyLCBtb3VzZVk6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuICgoTWF0aC5wb3cobW91c2VYIC0geCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB5LCAyKSkgPCBNYXRoLnBvdyhvcHRpb25zLmhpdFJhZGl1cyArIG9wdGlvbnMucmFkaXVzLCAyKSk7XG4gIH1cblxuICBpblhSYW5nZShtb3VzZVg6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsICd4JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBpbllSYW5nZShtb3VzZVk6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVksICd5JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uPzogYm9vbGVhbikge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fTtcbiAgfVxuXG4gIHNpemUob3B0aW9ucz86IFBhcnRpYWw8UG9pbnRPcHRpb25zICYgUG9pbnRIb3Zlck9wdGlvbnM+KSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGxldCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAwO1xuICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgcmFkaXVzICYmIG9wdGlvbnMuaG92ZXJSYWRpdXMgfHwgMCk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSByYWRpdXMgJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIHJldHVybiAocmFkaXVzICsgYm9yZGVyV2lkdGgpICogMjtcbiAgfVxuXG4gIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGFyZWE6IENoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAodGhpcy5za2lwIHx8IG9wdGlvbnMucmFkaXVzIDwgMC4xIHx8ICFfaXNQb2ludEluQXJlYSh0aGlzLCBhcmVhLCB0aGlzLnNpemUob3B0aW9ucykgLyAyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHRoaXMueCwgdGhpcy55KTtcbiAgfVxuXG4gIGdldFJhbmdlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBGYWxsYmFja3Mgc2hvdWxkIG5ldmVyIGJlIGhpdCBpbiBwcmFjdGljZVxuICAgIHJldHVybiBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzO1xuICB9XG59XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtpc09iamVjdCwgX2lzQmV0d2VlbiwgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHthZGRSb3VuZGVkUmVjdFBhdGh9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHt0b1RSQkwsIHRvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqIEB0eXBlZGVmIHt7IHg6IG51bWJlciwgeTogbnVtYmVyLCBiYXNlOiBudW1iZXIsIGhvcml6b250YWw6IGJvb2xlYW4sIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH19IEJhclByb3BzICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm91bmRzIG9mIHRoZSBiYXIgcmVnYXJkbGVzcyBvZiB0aGUgb3JpZW50YXRpb25cbiAqIEBwYXJhbSB7QmFyRWxlbWVudH0gYmFyIHRoZSBiYXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dXG4gKiBAcmV0dXJuIHtvYmplY3R9IGJvdW5kcyBvZiB0aGUgYmFyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHt4LCB5LCBiYXNlLCB3aWR0aCwgaGVpZ2h0fSA9IC8qKiBAdHlwZSB7QmFyUHJvcHN9ICovIChiYXIuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXSwgdXNlRmluYWxQb3NpdGlvbikpO1xuXG4gIGxldCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIGhhbGY7XG5cbiAgaWYgKGJhci5ob3Jpem9udGFsKSB7XG4gICAgaGFsZiA9IGhlaWdodCAvIDI7XG4gICAgbGVmdCA9IE1hdGgubWluKHgsIGJhc2UpO1xuICAgIHJpZ2h0ID0gTWF0aC5tYXgoeCwgYmFzZSk7XG4gICAgdG9wID0geSAtIGhhbGY7XG4gICAgYm90dG9tID0geSArIGhhbGY7XG4gIH0gZWxzZSB7XG4gICAgaGFsZiA9IHdpZHRoIC8gMjtcbiAgICBsZWZ0ID0geCAtIGhhbGY7XG4gICAgcmlnaHQgPSB4ICsgaGFsZjtcbiAgICB0b3AgPSBNYXRoLm1pbih5LCBiYXNlKTtcbiAgICBib3R0b20gPSBNYXRoLm1heCh5LCBiYXNlKTtcbiAgfVxuXG4gIHJldHVybiB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfTtcbn1cblxuZnVuY3Rpb24gc2tpcE9yTGltaXQoc2tpcCwgdmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBza2lwID8gMCA6IF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyV2lkdGgoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgbyA9IHRvVFJCTCh2YWx1ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0OiBza2lwT3JMaW1pdChza2lwLnRvcCwgby50b3AsIDAsIG1heEgpLFxuICAgIHI6IHNraXBPckxpbWl0KHNraXAucmlnaHQsIG8ucmlnaHQsIDAsIG1heFcpLFxuICAgIGI6IHNraXBPckxpbWl0KHNraXAuYm90dG9tLCBvLmJvdHRvbSwgMCwgbWF4SCksXG4gICAgbDogc2tpcE9yTGltaXQoc2tpcC5sZWZ0LCBvLmxlZnQsIDAsIG1heFcpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB7ZW5hYmxlQm9yZGVyUmFkaXVzfSA9IGJhci5nZXRQcm9wcyhbJ2VuYWJsZUJvcmRlclJhZGl1cyddKTtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJSYWRpdXM7XG4gIGNvbnN0IG8gPSB0b1RSQkxDb3JuZXJzKHZhbHVlKTtcbiAgY29uc3QgbWF4UiA9IE1hdGgubWluKG1heFcsIG1heEgpO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgYXNzdW1lIHRoZSB1c2VyIGtub3dzIHdoYXQgdGhleSBhcmUgZG9pbmdcbiAgLy8gYW5kIGFwcGx5IGFzIGRpcmVjdGVkLlxuICBjb25zdCBlbmFibGVCb3JkZXIgPSBlbmFibGVCb3JkZXJSYWRpdXMgfHwgaXNPYmplY3QodmFsdWUpO1xuXG4gIHJldHVybiB7XG4gICAgdG9wTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLmxlZnQsIG8udG9wTGVmdCwgMCwgbWF4UiksXG4gICAgdG9wUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5yaWdodCwgby50b3BSaWdodCwgMCwgbWF4UiksXG4gICAgYm90dG9tTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLmxlZnQsIG8uYm90dG9tTGVmdCwgMCwgbWF4UiksXG4gICAgYm90dG9tUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5yaWdodCwgby5ib3R0b21SaWdodCwgMCwgbWF4UilcbiAgfTtcbn1cblxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyhiYXIpIHtcbiAgY29uc3QgYm91bmRzID0gZ2V0QmFyQm91bmRzKGJhcik7XG4gIGNvbnN0IHdpZHRoID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQ7XG4gIGNvbnN0IGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xuICBjb25zdCBib3JkZXIgPSBwYXJzZUJvcmRlcldpZHRoKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgY29uc3QgcmFkaXVzID0gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuXG4gIHJldHVybiB7XG4gICAgb3V0ZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0LFxuICAgICAgeTogYm91bmRzLnRvcCxcbiAgICAgIHc6IHdpZHRoLFxuICAgICAgaDogaGVpZ2h0LFxuICAgICAgcmFkaXVzXG4gICAgfSxcbiAgICBpbm5lcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQgKyBib3JkZXIubCxcbiAgICAgIHk6IGJvdW5kcy50b3AgKyBib3JkZXIudCxcbiAgICAgIHc6IHdpZHRoIC0gYm9yZGVyLmwgLSBib3JkZXIucixcbiAgICAgIGg6IGhlaWdodCAtIGJvcmRlci50IC0gYm9yZGVyLmIsXG4gICAgICByYWRpdXM6IHtcbiAgICAgICAgdG9wTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcExlZnQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLmwpKSxcbiAgICAgICAgdG9wUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BSaWdodCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIucikpLFxuICAgICAgICBib3R0b21MZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tTGVmdCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIubCkpLFxuICAgICAgICBib3R0b21SaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbVJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5yKSksXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpblJhbmdlKGJhciwgeCwgeSwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBza2lwWCA9IHggPT09IG51bGw7XG4gIGNvbnN0IHNraXBZID0geSA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcEJvdGggPSBza2lwWCAmJiBza2lwWTtcbiAgY29uc3QgYm91bmRzID0gYmFyICYmICFza2lwQm90aCAmJiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKTtcblxuICByZXR1cm4gYm91bmRzXG5cdFx0JiYgKHNraXBYIHx8IF9pc0JldHdlZW4oeCwgYm91bmRzLmxlZnQsIGJvdW5kcy5yaWdodCkpXG5cdFx0JiYgKHNraXBZIHx8IF9pc0JldHdlZW4oeSwgYm91bmRzLnRvcCwgYm91bmRzLmJvdHRvbSkpO1xufVxuXG5mdW5jdGlvbiBoYXNSYWRpdXMocmFkaXVzKSB7XG4gIHJldHVybiByYWRpdXMudG9wTGVmdCB8fCByYWRpdXMudG9wUmlnaHQgfHwgcmFkaXVzLmJvdHRvbUxlZnQgfHwgcmFkaXVzLmJvdHRvbVJpZ2h0O1xufVxuXG4vKipcbiAqIEFkZCBhIHBhdGggb2YgYSByZWN0YW5nbGUgdG8gdGhlIGN1cnJlbnQgc3ViLXBhdGhcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dFxuICogQHBhcmFtIHsqfSByZWN0IEJvdW5kaW5nIHJlY3RcbiAqL1xuZnVuY3Rpb24gYWRkTm9ybWFsUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZWN0KHJlY3QsIGFtb3VudCwgcmVmUmVjdCA9IHt9KSB7XG4gIGNvbnN0IHggPSByZWN0LnggIT09IHJlZlJlY3QueCA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB5ID0gcmVjdC55ICE9PSByZWZSZWN0LnkgPyAtYW1vdW50IDogMDtcbiAgY29uc3QgdyA9IChyZWN0LnggKyByZWN0LncgIT09IHJlZlJlY3QueCArIHJlZlJlY3QudyA/IGFtb3VudCA6IDApIC0geDtcbiAgY29uc3QgaCA9IChyZWN0LnkgKyByZWN0LmggIT09IHJlZlJlY3QueSArIHJlZlJlY3QuaCA/IGFtb3VudCA6IDApIC0geTtcbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LnggKyB4LFxuICAgIHk6IHJlY3QueSArIHksXG4gICAgdzogcmVjdC53ICsgdyxcbiAgICBoOiByZWN0LmggKyBoLFxuICAgIHJhZGl1czogcmVjdC5yYWRpdXNcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIHN0YXRpYyBpZCA9ICdiYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlclNraXBwZWQ6ICdzdGFydCcsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIGluZmxhdGVBbW91bnQ6ICdhdXRvJyxcbiAgICBwb2ludFN0eWxlOiB1bmRlZmluZWRcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhc2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluZmxhdGVBbW91bnQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCB7aW5mbGF0ZUFtb3VudCwgb3B0aW9uczoge2JvcmRlckNvbG9yLCBiYWNrZ3JvdW5kQ29sb3J9fSA9IHRoaXM7XG4gICAgY29uc3Qge2lubmVyLCBvdXRlcn0gPSBib3VuZGluZ1JlY3RzKHRoaXMpO1xuICAgIGNvbnN0IGFkZFJlY3RQYXRoID0gaGFzUmFkaXVzKG91dGVyLnJhZGl1cykgPyBhZGRSb3VuZGVkUmVjdFBhdGggOiBhZGROb3JtYWxSZWN0UGF0aDtcblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBpZiAob3V0ZXIudyAhPT0gaW5uZXIudyB8fCBvdXRlci5oICE9PSBpbm5lci5oKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KG91dGVyLCBpbmZsYXRlQW1vdW50LCBpbm5lcikpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIC1pbmZsYXRlQW1vdW50LCBvdXRlcikpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICB9XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgaW5mbGF0ZUFtb3VudCkpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LmZpbGwoKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgaW5YUmFuZ2UobW91c2VYLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBudWxsLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG51bGwsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHksIGJhc2UsIGhvcml6b250YWx9ID0gLyoqIEB0eXBlIHtCYXJQcm9wc30gKi8gKHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICdob3Jpem9udGFsJ10sIHVzZUZpbmFsUG9zaXRpb24pKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/ICh4ICsgYmFzZSkgLyAyIDogeCxcbiAgICAgIHk6IGhvcml6b250YWwgPyB5IDogKHkgKyBiYXNlKSAvIDJcbiAgICB9O1xuICB9XG5cbiAgZ2V0UmFuZ2UoYXhpcykge1xuICAgIHJldHVybiBheGlzID09PSAneCcgPyB0aGlzLndpZHRoIC8gMiA6IHRoaXMuaGVpZ2h0IC8gMjtcbiAgfVxufVxuIiwgImltcG9ydCB7RG91Z2hudXRDb250cm9sbGVyLCBQb2xhckFyZWFDb250cm9sbGVyfSBmcm9tICcuLi9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnQsIENoYXJ0RGF0YXNldH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbG9yc1BsdWdpbk9wdGlvbnMge1xuICBlbmFibGVkPzogYm9vbGVhbjtcbiAgZm9yY2VPdmVycmlkZT86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBDb2xvcnNEZXNjcmlwdG9yIHtcbiAgYmFja2dyb3VuZENvbG9yPzogdW5rbm93bjtcbiAgYm9yZGVyQ29sb3I/OiB1bmtub3duO1xufVxuXG5jb25zdCBCT1JERVJfQ09MT1JTID0gW1xuICAncmdiKDU0LCAxNjIsIDIzNSknLCAvLyBibHVlXG4gICdyZ2IoMjU1LCA5OSwgMTMyKScsIC8vIHJlZFxuICAncmdiKDI1NSwgMTU5LCA2NCknLCAvLyBvcmFuZ2VcbiAgJ3JnYigyNTUsIDIwNSwgODYpJywgLy8geWVsbG93XG4gICdyZ2IoNzUsIDE5MiwgMTkyKScsIC8vIGdyZWVuXG4gICdyZ2IoMTUzLCAxMDIsIDI1NSknLCAvLyBwdXJwbGVcbiAgJ3JnYigyMDEsIDIwMywgMjA3KScgLy8gZ3JleVxuXTtcblxuLy8gQm9yZGVyIGNvbG9ycyB3aXRoIDUwJSB0cmFuc3BhcmVuY3lcbmNvbnN0IEJBQ0tHUk9VTkRfQ09MT1JTID0gLyogI19fUFVSRV9fICovIEJPUkRFUl9DT0xPUlMubWFwKGNvbG9yID0+IGNvbG9yLnJlcGxhY2UoJ3JnYignLCAncmdiYSgnKS5yZXBsYWNlKCcpJywgJywgMC41KScpKTtcblxuZnVuY3Rpb24gZ2V0Qm9yZGVyQ29sb3IoaTogbnVtYmVyKSB7XG4gIHJldHVybiBCT1JERVJfQ09MT1JTW2kgJSBCT1JERVJfQ09MT1JTLmxlbmd0aF07XG59XG5cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRDb2xvcihpOiBudW1iZXIpIHtcbiAgcmV0dXJuIEJBQ0tHUk9VTkRfQ09MT1JTW2kgJSBCQUNLR1JPVU5EX0NPTE9SUy5sZW5ndGhdO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZURlZmF1bHREYXRhc2V0KGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgaTogbnVtYmVyKSB7XG4gIGRhdGFzZXQuYm9yZGVyQ29sb3IgPSBnZXRCb3JkZXJDb2xvcihpKTtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrZ3JvdW5kQ29sb3IoaSk7XG5cbiAgcmV0dXJuICsraTtcbn1cblxuZnVuY3Rpb24gY29sb3JpemVEb3VnaG51dERhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0LmRhdGEubWFwKCgpID0+IGdldEJvcmRlckNvbG9yKGkrKykpO1xuXG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZVBvbGFyQXJlYURhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBkYXRhc2V0LmRhdGEubWFwKCgpID0+IGdldEJhY2tncm91bmRDb2xvcihpKyspKTtcblxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29sb3JpemVyKGNoYXJ0OiBDaGFydCkge1xuICBsZXQgaSA9IDA7XG5cbiAgcmV0dXJuIChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGRhdGFzZXRJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcblxuICAgIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgRG91Z2hudXRDb250cm9sbGVyKSB7XG4gICAgICBpID0gY29sb3JpemVEb3VnaG51dERhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgUG9sYXJBcmVhQ29udHJvbGxlcikge1xuICAgICAgaSA9IGNvbG9yaXplUG9sYXJBcmVhRGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgIGkgPSBjb2xvcml6ZURlZmF1bHREYXRhc2V0KGRhdGFzZXQsIGkpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhcbiAgZGVzY3JpcHRvcnM6IENvbG9yc0Rlc2NyaXB0b3JbXSB8IFJlY29yZDxzdHJpbmcsIENvbG9yc0Rlc2NyaXB0b3I+XG4pIHtcbiAgbGV0IGs6IG51bWJlciB8IHN0cmluZztcblxuICBmb3IgKGsgaW4gZGVzY3JpcHRvcnMpIHtcbiAgICBpZiAoZGVzY3JpcHRvcnNba10uYm9yZGVyQ29sb3IgfHwgZGVzY3JpcHRvcnNba10uYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbihcbiAgZGVzY3JpcHRvcjogQ29sb3JzRGVzY3JpcHRvclxuKSB7XG4gIHJldHVybiBkZXNjcmlwdG9yICYmIChkZXNjcmlwdG9yLmJvcmRlckNvbG9yIHx8IGRlc2NyaXB0b3IuYmFja2dyb3VuZENvbG9yKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2NvbG9ycycsXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZvcmNlT3ZlcnJpZGU6IGZhbHNlXG4gIH0gYXMgQ29sb3JzUGx1Z2luT3B0aW9ucyxcblxuICBiZWZvcmVMYXlvdXQoY2hhcnQ6IENoYXJ0LCBfYXJncywgb3B0aW9uczogQ29sb3JzUGx1Z2luT3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge2RhdGFzZXRzfSxcbiAgICAgIG9wdGlvbnM6IGNoYXJ0T3B0aW9uc1xuICAgIH0gPSBjaGFydC5jb25maWc7XG4gICAgY29uc3Qge2VsZW1lbnRzfSA9IGNoYXJ0T3B0aW9ucztcblxuICAgIGlmICghb3B0aW9ucy5mb3JjZU92ZXJyaWRlICYmIChjb250YWluc0NvbG9yc0RlZmluaXRpb25zKGRhdGFzZXRzKSB8fCBjb250YWluc0NvbG9yc0RlZmluaXRpb24oY2hhcnRPcHRpb25zKSB8fCAoZWxlbWVudHMgJiYgY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhlbGVtZW50cykpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbG9yaXplciA9IGdldENvbG9yaXplcihjaGFydCk7XG5cbiAgICBkYXRhc2V0cy5mb3JFYWNoKGNvbG9yaXplcik7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHtfbGltaXRWYWx1ZSwgX2xvb2t1cEJ5S2V5LCBpc051bGxPclVuZGVmLCByZXNvbHZlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZnVuY3Rpb24gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucykge1xuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIExhcmdlc3QgVHJpYW5nbGUgVGhyZWUgQnVja2V0cyBhbGdvcml0aG0uXG4gICAqXG4gICAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGJ5IFN2ZWlubiBTdGVpbmFyc3NvblxuICAgKiBpbiBodHRwczovL2dpdGh1Yi5jb20vc3ZlaW5uLXN0ZWluYXJzc29uL2Zsb3QtZG93bnNhbXBsZS9ibG9iL21hc3Rlci9qcXVlcnkuZmxvdC5kb3duc2FtcGxlLmpzXG4gICAqXG4gICAqIFRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBpcyBNSVQgbGljZW5zZWQuXG4gICAqL1xuICBjb25zdCBzYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzIHx8IGF2YWlsYWJsZVdpZHRoO1xuICAvLyBUaGVyZSBhcmUgbGVzcyBwb2ludHMgdGhhbiB0aGUgdGhyZXNob2xkLCByZXR1cm5pbmcgdGhlIHdob2xlIGFycmF5XG4gIGlmIChzYW1wbGVzID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICB9XG5cbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG5cbiAgY29uc3QgYnVja2V0V2lkdGggPSAoY291bnQgLSAyKSAvIChzYW1wbGVzIC0gMik7XG4gIGxldCBzYW1wbGVkSW5kZXggPSAwO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICAvLyBTdGFydGluZyBmcm9tIG9mZnNldFxuICBsZXQgYSA9IHN0YXJ0O1xuICBsZXQgaSwgbWF4QXJlYVBvaW50LCBtYXhBcmVhLCBhcmVhLCBuZXh0QTtcblxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVthXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcyAtIDI7IGkrKykge1xuICAgIGxldCBhdmdYID0gMDtcbiAgICBsZXQgYXZnWSA9IDA7XG4gICAgbGV0IGo7XG5cbiAgICAvLyBBZGRpbmcgb2Zmc2V0XG4gICAgY29uc3QgYXZnUmFuZ2VTdGFydCA9IE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUVuZCA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAyKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlTGVuZ3RoID0gYXZnUmFuZ2VFbmQgLSBhdmdSYW5nZVN0YXJ0O1xuXG4gICAgZm9yIChqID0gYXZnUmFuZ2VTdGFydDsgaiA8IGF2Z1JhbmdlRW5kOyBqKyspIHtcbiAgICAgIGF2Z1ggKz0gZGF0YVtqXS54O1xuICAgICAgYXZnWSArPSBkYXRhW2pdLnk7XG4gICAgfVxuXG4gICAgYXZnWCAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBhdmdZIC89IGF2Z1JhbmdlTGVuZ3RoO1xuXG4gICAgLy8gQWRkaW5nIG9mZnNldFxuICAgIGNvbnN0IHJhbmdlT2ZmcyA9IE1hdGguZmxvb3IoaSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCByYW5nZVRvID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3Qge3g6IHBvaW50QXgsIHk6IHBvaW50QXl9ID0gZGF0YVthXTtcblxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIGNoYW5nZWQgZnJvbSB0aGUgb3JpZ2luYWwgYWxnb3JpdGhtIHdoaWNoIGluaXRpYWxpemVzIHRoZXNlXG4gICAgLy8gdmFsdWVzIHRvIDEuIFRoZSByZWFzb24gZm9yIHRoaXMgY2hhbmdlIGlzIHRoYXQgaWYgdGhlIGFyZWEgaXMgc21hbGwsIG5leHRBXG4gICAgLy8gd291bGQgbmV2ZXIgYmUgc2V0IGFuZCB0aHVzIGEgY3Jhc2ggd291bGQgb2NjdXIgaW4gdGhlIG5leHQgbG9vcCBhcyBgYWAgd291bGQgYmVjb21lXG4gICAgLy8gYHVuZGVmaW5lZGAuIFNpbmNlIHRoZSBhcmVhIGlzIGFsd2F5cyBwb3NpdGl2ZSwgYnV0IGNvdWxkIGJlIDAgaW4gdGhlIGNhc2Ugb2YgYSBmbGF0IHRyYWNlLFxuICAgIC8vIGluaXRpYWxpemluZyB3aXRoIGEgbmVnYXRpdmUgbnVtYmVyIGlzIHRoZSBjb3JyZWN0IHNvbHV0aW9uLlxuICAgIG1heEFyZWEgPSBhcmVhID0gLTE7XG5cbiAgICBmb3IgKGogPSByYW5nZU9mZnM7IGogPCByYW5nZVRvOyBqKyspIHtcbiAgICAgIGFyZWEgPSAwLjUgKiBNYXRoLmFicyhcbiAgICAgICAgKHBvaW50QXggLSBhdmdYKSAqIChkYXRhW2pdLnkgLSBwb2ludEF5KSAtXG4gICAgICAgIChwb2ludEF4IC0gZGF0YVtqXS54KSAqIChhdmdZIC0gcG9pbnRBeSlcbiAgICAgICk7XG5cbiAgICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xuICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgICAgbWF4QXJlYVBvaW50ID0gZGF0YVtqXTtcbiAgICAgICAgbmV4dEEgPSBqO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBtYXhBcmVhUG9pbnQ7XG4gICAgYSA9IG5leHRBO1xuICB9XG5cbiAgLy8gSW5jbHVkZSB0aGUgbGFzdCBwb2ludFxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVtlbmRJbmRleF07XG5cbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cblxuZnVuY3Rpb24gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKSB7XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgeCwgeSwgcHJldlgsIG1pbkluZGV4LCBtYXhJbmRleCwgc3RhcnRJbmRleCwgbWluWSwgbWF4WTtcbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG5cbiAgY29uc3QgeE1pbiA9IGRhdGFbc3RhcnRdLng7XG4gIGNvbnN0IHhNYXggPSBkYXRhW2VuZEluZGV4XS54O1xuICBjb25zdCBkeCA9IHhNYXggLSB4TWluO1xuXG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgcG9pbnQgPSBkYXRhW2ldO1xuICAgIHggPSAocG9pbnQueCAtIHhNaW4pIC8gZHggKiBhdmFpbGFibGVXaWR0aDtcbiAgICB5ID0gcG9pbnQueTtcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDtcblxuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICAvLyBEZXRlcm1pbmUgYG1pbllgIC8gYG1heFlgIGFuZCBgYXZnWGAgd2hpbGUgd2Ugc3RheSB3aXRoaW4gc2FtZSB4LXBvc2l0aW9uXG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICAgIG1pbkluZGV4ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgIG1heEluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBmaXJzdCBwb2ludCBpbiBncm91cCwgY291bnRYIGlzIGAwYCwgc28gYXZlcmFnZSB3aWxsIGJlIGB4YCAvIDEuXG4gICAgICAvLyBVc2UgcG9pbnQueCBoZXJlIGJlY2F1c2Ugd2UncmUgY29tcHV0aW5nIHRoZSBhdmVyYWdlIGRhdGEgYHhgIHZhbHVlXG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyBwb2ludC54KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQdXNoIHVwIHRvIDQgcG9pbnRzLCAzIGZvciB0aGUgbGFzdCBpbnRlcnZhbCBhbmQgdGhlIGZpcnN0IHBvaW50IGZvciB0aGlzIGludGVydmFsXG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBpIC0gMTtcblxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG1pbkluZGV4KSAmJiAhaXNOdWxsT3JVbmRlZihtYXhJbmRleCkpIHtcbiAgICAgICAgLy8gVGhlIGludGVydmFsIGlzIGRlZmluZWQgYnkgNCBwb2ludHM6IHN0YXJ0LCBtaW4sIG1heCwgZW5kLlxuICAgICAgICAvLyBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgYWxyZWFkeSBjb25zaWRlcmVkIGF0IHRoaXMgcG9pbnQsIHNvIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICAgIC8vIG9mIHRoZSBvdGhlciBwb2ludHMgdG8gYWRkLiBXZSBuZWVkIHRvIHNvcnQgdGhlc2UgcG9pbnRzIHRvIGVuc3VyZSB0aGUgZGVjaW1hdGVkIGRhdGFcbiAgICAgICAgLy8gaXMgc3RpbGwgc29ydGVkIGFuZCB0aGVuIGVuc3VyZSB0aGVyZSBhcmUgbm8gZHVwbGljYXRlcy5cbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgxID0gTWF0aC5taW4obWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgyID0gTWF0aC5tYXgobWluSW5kZXgsIG1heEluZGV4KTtcblxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MSAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDFdLFxuICAgICAgICAgICAgeDogYXZnWCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MiAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDJdLFxuICAgICAgICAgICAgeDogYXZnWFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGxhc3RJbmRleCA9PT0gc3RhcnRJbmRleCB3aWxsIG9jY3VyIHdoZW4gYSByYW5nZSBoYXMgb25seSAxIHBvaW50IHdoaWNoIGNvdWxkXG4gICAgICAvLyBoYXBwZW4gd2l0aCB2ZXJ5IHVuZXZlbiBkYXRhXG4gICAgICBpZiAoaSA+IDAgJiYgbGFzdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgIC8vIExhc3QgcG9pbnQgaW4gdGhlIHByZXZpb3VzIGludGVydmFsXG4gICAgICAgIGRlY2ltYXRlZC5wdXNoKGRhdGFbbGFzdEluZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0YXJ0IG9mIHRoZSBuZXcgaW50ZXJ2YWxcbiAgICAgIGRlY2ltYXRlZC5wdXNoKHBvaW50KTtcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICAgIG1pbkluZGV4ID0gbWF4SW5kZXggPSBzdGFydEluZGV4ID0gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuXG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCkge1xuICBpZiAoZGF0YXNldC5fZGVjaW1hdGVkKSB7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuX2RhdGE7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBkZWxldGUgZGF0YXNldC5fZGF0YTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZGF0YSxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpIHtcbiAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0KSA9PiB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgcG9pbnRzKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudDtcblxuICBjb25zdCB7aVNjYWxlfSA9IG1ldGE7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuXG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWluKS5sbywgMCwgcG9pbnRDb3VudCAtIDEpO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgY291bnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWF4KS5oaSArIDEsIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnZGVjaW1hdGlvbicsXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGdvcml0aG06ICdtaW4tbWF4JyxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgfSxcblxuICBiZWZvcmVFbGVtZW50c1VwZGF0ZTogKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIC8vIFRoZSBkZWNpbWF0aW9uIHBsdWdpbiBtYXkgaGF2ZSBiZWVuIHByZXZpb3VzbHkgZW5hYmxlZC4gTmVlZCB0byByZW1vdmUgb2xkIGBkYXRhc2V0Ll9kYXRhYCBoYW5kbGVyc1xuICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBc3N1bWUgdGhlIGVudGlyZSBjaGFydCBpcyBhdmFpbGFibGUgdG8gc2hvdyBhIGZldyBtb3JlIHBvaW50cyB0aGFuIG5lZWRlZFxuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gY2hhcnQud2lkdGg7XG5cbiAgICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgY29uc3Qge19kYXRhLCBpbmRleEF4aXN9ID0gZGF0YXNldDtcbiAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgY29uc3QgZGF0YSA9IF9kYXRhIHx8IGRhdGFzZXQuZGF0YTtcblxuICAgICAgaWYgKHJlc29sdmUoW2luZGV4QXhpcywgY2hhcnQub3B0aW9ucy5pbmRleEF4aXNdKSA9PT0gJ3knKSB7XG4gICAgICAgIC8vIERlY2ltYXRpb24gaXMgb25seSBzdXBwb3J0ZWQgZm9yIGxpbmVzIHRoYXQgaGF2ZSBhbiBYIGluZGV4QXhpc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghbWV0YS5jb250cm9sbGVyLnN1cHBvcnRzRGVjaW1hdGlvbikge1xuICAgICAgICAvLyBPbmx5IGxpbmUgZGF0YXNldHMgYXJlIHN1cHBvcnRlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHhBeGlzID0gY2hhcnQuc2NhbGVzW21ldGEueEF4aXNJRF07XG4gICAgICBpZiAoeEF4aXMudHlwZSAhPT0gJ2xpbmVhcicgJiYgeEF4aXMudHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgIC8vIE9ubHkgbGluZWFyIGludGVycG9sYXRpb24gaXMgc3VwcG9ydGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYXJ0Lm9wdGlvbnMucGFyc2luZykge1xuICAgICAgICAvLyBQbHVnaW4gb25seSBzdXBwb3J0cyBkYXRhIHRoYXQgZG9lcyBub3QgbmVlZCBwYXJzaW5nXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IHtzdGFydCwgY291bnR9ID0gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgZGF0YSk7XG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCA0ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoY291bnQgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgIC8vIE5vIGRlY2ltYXRpb24gaXMgcmVxdWlyZWQgdW50aWwgd2UgYXJlIGFib3ZlIHRoaXMgdGhyZXNob2xkXG4gICAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZihfZGF0YSkpIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSB3ZSBhcmUgc2VlaW5nIHRoaXMgZGF0YXNldFxuICAgICAgICAvLyBXZSBvdmVycmlkZSB0aGUgJ2RhdGEnIHByb3BlcnR5IHdpdGggYSBzZXR0ZXIgdGhhdCBzdG9yZXMgdGhlXG4gICAgICAgIC8vIHJhdyBkYXRhIGluIF9kYXRhLCBidXQgcmVhZHMgdGhlIGRlY2ltYXRlZCBkYXRhIGZyb20gX2RlY2ltYXRlZFxuICAgICAgICBkYXRhc2V0Ll9kYXRhID0gZGF0YTtcbiAgICAgICAgZGVsZXRlIGRhdGFzZXQuZGF0YTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjaW1hdGVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBQb2ludCB0aGUgY2hhcnQgdG8gdGhlIGRlY2ltYXRlZCBkYXRhXG4gICAgICBsZXQgZGVjaW1hdGVkO1xuICAgICAgc3dpdGNoIChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgICAgY2FzZSAnbHR0Yic6XG4gICAgICAgIGRlY2ltYXRlZCA9IGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pbi1tYXgnOlxuICAgICAgICBkZWNpbWF0ZWQgPSBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVjaW1hdGlvbiBhbGdvcml0aG0gJyR7b3B0aW9ucy5hbGdvcml0aG19J2ApO1xuICAgICAgfVxuXG4gICAgICBkYXRhc2V0Ll9kZWNpbWF0ZWQgPSBkZWNpbWF0ZWQ7XG4gICAgfSk7XG4gIH0sXG5cbiAgZGVzdHJveShjaGFydCkge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHtfYm91bmRTZWdtZW50LCBfYm91bmRTZWdtZW50cywgX25vcm1hbGl6ZUFuZ2xlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHRwb2ludHMgPSB0YXJnZXQucG9pbnRzO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGxldCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpO1xuXG4gICAgY29uc3QgYm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgcG9pbnRzW3N0YXJ0XSwgcG9pbnRzW2VuZF0sIHNlZ21lbnQubG9vcCk7XG5cbiAgICBpZiAoIXRhcmdldC5zZWdtZW50cykge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBib3VuZGFyeSBub3Qgc3VwcG9ydGluZyBgc2VnbWVudHNgIChzaW1wbGVBcmMpXG4gICAgICAvLyBCb3VuZHMgYXJlIHByb3ZpZGVkIGFzIGB0YXJnZXRgIGZvciBwYXJ0aWFsIGNpcmNsZSwgb3IgdW5kZWZpbmVkIGZvciBmdWxsIGNpcmNsZVxuICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgIHNvdXJjZTogc2VnbWVudCxcbiAgICAgICAgdGFyZ2V0OiBib3VuZHMsXG4gICAgICAgIHN0YXJ0OiBwb2ludHNbc3RhcnRdLFxuICAgICAgICBlbmQ6IHBvaW50c1tlbmRdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEdldCBhbGwgc2VnbWVudHMgZnJvbSBgdGFyZ2V0YCB0aGF0IGludGVyc2VjdCB0aGUgYm91bmRzIG9mIGN1cnJlbnQgc2VnbWVudCBvZiBgbGluZWBcbiAgICBjb25zdCB0YXJnZXRTZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRhcmdldCwgYm91bmRzKTtcblxuICAgIGZvciAoY29uc3QgdGd0IG9mIHRhcmdldFNlZ21lbnRzKSB7XG4gICAgICBjb25zdCBzdWJCb3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCB0cG9pbnRzW3RndC5zdGFydF0sIHRwb2ludHNbdGd0LmVuZF0sIHRndC5sb29wKTtcbiAgICAgIGNvbnN0IGZpbGxTb3VyY2VzID0gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIHN1YkJvdW5kcyk7XG5cbiAgICAgIGZvciAoY29uc3QgZmlsbFNvdXJjZSBvZiBmaWxsU291cmNlcykge1xuICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICBzb3VyY2U6IGZpbGxTb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0OiB0Z3QsXG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnc3RhcnQnLCBNYXRoLm1heClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdlbmQnLCBNYXRoLm1pbilcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBmaXJzdCwgbGFzdCwgbG9vcCkge1xuICBpZiAobG9vcCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc3RhcnQgPSBmaXJzdFtwcm9wZXJ0eV07XG4gIGxldCBlbmQgPSBsYXN0W3Byb3BlcnR5XTtcblxuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICBzdGFydCA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gICAgZW5kID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gIH1cbiAgcmV0dXJuIHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGNvbnN0IHt4ID0gbnVsbCwgeSA9IG51bGx9ID0gYm91bmRhcnkgfHwge307XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGxpbmUuc2VnbWVudHMuZm9yRWFjaCgoe3N0YXJ0LCBlbmR9KSA9PiB7XG4gICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIGxpbmVQb2ludHMpO1xuICAgIGNvbnN0IGZpcnN0ID0gbGluZVBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdCA9IGxpbmVQb2ludHNbZW5kXTtcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGZpcnN0LngsIHl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBsYXN0LngsIHl9KTtcbiAgICB9IGVsc2UgaWYgKHggIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBmaXJzdC55fSk7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogbGFzdC55fSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBvaW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpIHtcbiAgZm9yICg7ZW5kID4gc3RhcnQ7IGVuZC0tKSB7XG4gICAgY29uc3QgcG9pbnQgPSBwb2ludHNbZW5kXTtcbiAgICBpZiAoIWlzTmFOKHBvaW50LngpICYmICFpc05hTihwb2ludC55KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmQ7XG59XG5cbmZ1bmN0aW9uIF9nZXRFZGdlKGEsIGIsIHByb3AsIGZuKSB7XG4gIGlmIChhICYmIGIpIHtcbiAgICByZXR1cm4gZm4oYVtwcm9wXSwgYltwcm9wXSk7XG4gIH1cbiAgcmV0dXJuIGEgPyBhW3Byb3BdIDogYiA/IGJbcHJvcF0gOiAwO1xufVxuIiwgIi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5pbXBvcnQge0xpbmVFbGVtZW50fSBmcm9tICcuLi8uLi9lbGVtZW50cy9pbmRleC5qcyc7XG5pbXBvcnQge2lzQXJyYXl9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfcG9pbnRzRnJvbVNlZ21lbnRzfSBmcm9tICcuL2ZpbGxlci5zZWdtZW50LmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdIHwgeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgfX0gYm91bmRhcnlcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEByZXR1cm4ge0xpbmVFbGVtZW50P31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpIHtcbiAgbGV0IHBvaW50cyA9IFtdO1xuICBsZXQgX2xvb3AgPSBmYWxzZTtcblxuICBpZiAoaXNBcnJheShib3VuZGFyeSkpIHtcbiAgICBfbG9vcCA9IHRydWU7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBvaW50cyA9IGJvdW5kYXJ5O1xuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IF9wb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cy5sZW5ndGggPyBuZXcgTGluZUVsZW1lbnQoe1xuICAgIHBvaW50cyxcbiAgICBvcHRpb25zOiB7dGVuc2lvbjogMH0sXG4gICAgX2xvb3AsXG4gICAgX2Z1bGxMb29wOiBfbG9vcFxuICB9KSA6IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkge1xuICByZXR1cm4gc291cmNlICYmIHNvdXJjZS5maWxsICE9PSBmYWxzZTtcbn1cbiIsICJpbXBvcnQge2lzT2JqZWN0LCBpc0Zpbml0ZSwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uLy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5saW5lLmpzJykuZGVmYXVsdCB9IExpbmVFbGVtZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMvaW5kZXguanMnKS5GaWxsVGFyZ2V0IH0gRmlsbFRhcmdldFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzL2luZGV4LmpzJykuQ29tcGxleEZpbGxUYXJnZXQgfSBDb21wbGV4RmlsbFRhcmdldFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICBsZXQgZmlsbCA9IHNvdXJjZS5maWxsO1xuICBjb25zdCB2aXNpdGVkID0gW2luZGV4XTtcbiAgbGV0IHRhcmdldDtcblxuICBpZiAoIXByb3BhZ2F0ZSkge1xuICAgIHJldHVybiBmaWxsO1xuICB9XG5cbiAgd2hpbGUgKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpIHtcbiAgICBpZiAoIWlzRmluaXRlKGZpbGwpKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG5cbiAgICB2aXNpdGVkLnB1c2goZmlsbCk7XG4gICAgZmlsbCA9IHRhcmdldC5maWxsO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVjb2RlRmlsbChsaW5lLCBpbmRleCwgY291bnQpIHtcbiAgLyoqIEB0eXBlIHtzdHJpbmcgfCB7dmFsdWU6IG51bWJlcn19ICovXG4gIGNvbnN0IGZpbGwgPSBwYXJzZUZpbGxPcHRpb24obGluZSk7XG5cbiAgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgcmV0dXJuIGlzTmFOKGZpbGwudmFsdWUpID8gZmFsc2UgOiBmaWxsO1xuICB9XG5cbiAgbGV0IHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCk7XG5cbiAgaWYgKGlzRmluaXRlKHRhcmdldCkgJiYgTWF0aC5mbG9vcih0YXJnZXQpID09PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gZGVjb2RlVGFyZ2V0SW5kZXgoZmlsbFswXSwgaW5kZXgsIHRhcmdldCwgY291bnQpO1xuICB9XG5cbiAgcmV0dXJuIFsnb3JpZ2luJywgJ3N0YXJ0JywgJ2VuZCcsICdzdGFjaycsICdzaGFwZSddLmluZGV4T2YoZmlsbCkgPj0gMCAmJiBmaWxsO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUYXJnZXRJbmRleChmaXJzdENoLCBpbmRleCwgdGFyZ2V0LCBjb3VudCkge1xuICBpZiAoZmlyc3RDaCA9PT0gJy0nIHx8IGZpcnN0Q2ggPT09ICcrJykge1xuICAgIHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuICB9XG5cbiAgaWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmlsbFRhcmdldCB8IENvbXBsZXhGaWxsVGFyZ2V0fSBmaWxsXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHJldHVybnMge251bWJlciB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpIHtcbiAgbGV0IHBpeGVsID0gbnVsbDtcbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmJvdHRvbTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHBpeGVsID0gc2NhbGUudG9wO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBpeGVsID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShmaWxsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICB9XG4gIHJldHVybiBwaXhlbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZpbGxUYXJnZXQgfCBDb21wbGV4RmlsbFRhcmdldH0gZmlsbFxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydFZhbHVlKSB7XG4gIGxldCB2YWx1ZTtcblxuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHZhbHVlID0gc3RhcnRWYWx1ZTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHZhbHVlID0gc2NhbGUub3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4O1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhbHVlID0gZmlsbC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHNjYWxlLmdldEJhc2VWYWx1ZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRmlsbE9wdGlvbihsaW5lKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBvcHRpb25zLmZpbGw7XG4gIGxldCBmaWxsID0gdmFsdWVPckRlZmF1bHQoZmlsbE9wdGlvbiAmJiBmaWxsT3B0aW9uLnRhcmdldCwgZmlsbE9wdGlvbik7XG5cbiAgaWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGZpbGwgPSAhIW9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09IGZhbHNlIHx8IGZpbGwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnb3JpZ2luJztcbiAgfVxuICByZXR1cm4gZmlsbDtcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuaW1wb3J0IHtMaW5lRWxlbWVudH0gZnJvbSAnLi4vLi4vZWxlbWVudHMvaW5kZXguanMnO1xuaW1wb3J0IHtfaXNCZXR3ZWVufSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2NyZWF0ZUJvdW5kYXJ5TGluZX0gZnJvbSAnLi9maWxsZXIuaGVscGVyLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge3sgY2hhcnQ6IENoYXJ0OyBzY2FsZTogU2NhbGU7IGluZGV4OiBudW1iZXI7IGxpbmU6IExpbmVFbGVtZW50OyB9fSBzb3VyY2VcbiAqIEByZXR1cm4ge0xpbmVFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGluZGV4LCBsaW5lfSA9IHNvdXJjZTtcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3Qgc291cmNlUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IGxpbmVzQmVsb3cgPSBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCk7XG4gIGxpbmVzQmVsb3cucHVzaChfY3JlYXRlQm91bmRhcnlMaW5lKHt4OiBudWxsLCB5OiBzY2FsZS5ib3R0b219LCBsaW5lKSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBmb3IgKGxldCBqID0gc2VnbWVudC5zdGFydDsgaiA8PSBzZWdtZW50LmVuZDsgaisrKSB7XG4gICAgICBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50c1tqXSwgbGluZXNCZWxvdyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgTGluZUVsZW1lbnQoe3BvaW50cywgb3B0aW9uczoge319KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJuIHtMaW5lRWxlbWVudFtdfVxuICovXG5mdW5jdGlvbiBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCkge1xuICBjb25zdCBiZWxvdyA9IFtdO1xuICBjb25zdCBtZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCdsaW5lJyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICBpZiAobWV0YS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIW1ldGEuaGlkZGVuKSB7XG4gICAgICBiZWxvdy51bnNoaWZ0KG1ldGEuZGF0YXNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiZWxvdztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHNcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50fSBzb3VyY2VQb2ludFxuICogQHBhcmFtIHtMaW5lRWxlbWVudFtdfSBsaW5lc0JlbG93XG4gKi9cbmZ1bmN0aW9uIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnQsIGxpbmVzQmVsb3cpIHtcbiAgY29uc3QgcG9zdHBvbmVkID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbGluZXNCZWxvdy5sZW5ndGg7IGorKykge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc0JlbG93W2pdO1xuICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgcG9pbnR9ID0gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCAneCcpO1xuXG4gICAgaWYgKCFwb2ludCB8fCAoZmlyc3QgJiYgbGFzdCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIC8vIEZpcnN0IHBvaW50IG9mIGFuIHNlZ21lbnQgLT4gbmVlZCB0byBhZGQgYW5vdGhlciBwb2ludCBiZWZvcmUgdGhpcyxcbiAgICAgIC8vIGZyb20gbmV4dCBsaW5lIGJlbG93LlxuICAgICAgcG9zdHBvbmVkLnVuc2hpZnQocG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiBzZWdtZW50LCBubyBuZWVkIHRvIGFkZCBtb3JlIHBvaW50cy5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBvaW50cy5wdXNoKC4uLnBvc3Rwb25lZCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtQb2ludEVsZW1lbnR9IHNvdXJjZVBvaW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHt7cG9pbnQ/OiBQb2ludEVsZW1lbnQsIGZpcnN0PzogYm9vbGVhbiwgbGFzdD86IGJvb2xlYW59fVxuICovXG5mdW5jdGlvbiBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHBvaW50ID0gbGluZS5pbnRlcnBvbGF0ZShzb3VyY2VQb2ludCwgcHJvcGVydHkpO1xuICBpZiAoIXBvaW50KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3QgcG9pbnRWYWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGxldCBmaXJzdCA9IGZhbHNlO1xuICBsZXQgbGFzdCA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuc3RhcnRdW3Byb3BlcnR5XTtcbiAgICBjb25zdCBsYXN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuZW5kXVtwcm9wZXJ0eV07XG4gICAgaWYgKF9pc0JldHdlZW4ocG9pbnRWYWx1ZSwgZmlyc3RWYWx1ZSwgbGFzdFZhbHVlKSkge1xuICAgICAgZmlyc3QgPSBwb2ludFZhbHVlID09PSBmaXJzdFZhbHVlO1xuICAgICAgbGFzdCA9IHBvaW50VmFsdWUgPT09IGxhc3RWYWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2ZpcnN0LCBsYXN0LCBwb2ludH07XG59XG4iLCAiaW1wb3J0IHtUQVV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vLyBUT0RPOiB1c2UgZWxlbWVudHMuQXJjRWxlbWVudCBpbnN0ZWFkXG5leHBvcnQgY2xhc3Mgc2ltcGxlQXJjIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMueCA9IG9wdHMueDtcbiAgICB0aGlzLnkgPSBvcHRzLnk7XG4gICAgdGhpcy5yYWRpdXMgPSBvcHRzLnJhZGl1cztcbiAgfVxuXG4gIHBhdGhTZWdtZW50KGN0eCwgYm91bmRzLCBvcHRzKSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGJvdW5kcyA9IGJvdW5kcyB8fCB7c3RhcnQ6IDAsIGVuZDogVEFVfTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgYm91bmRzLmVuZCwgYm91bmRzLnN0YXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gIW9wdHMuYm91bmRzO1xuICB9XG5cbiAgaW50ZXJwb2xhdGUocG9pbnQpIHtcbiAgICBjb25zdCB7eCwgeSwgcmFkaXVzfSA9IHRoaXM7XG4gICAgY29uc3QgYW5nbGUgPSBwb2ludC5hbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzRmluaXRlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2NyZWF0ZUJvdW5kYXJ5TGluZX0gZnJvbSAnLi9maWxsZXIuaGVscGVyLmpzJztcbmltcG9ydCB7X2dldFRhcmdldFBpeGVsLCBfZ2V0VGFyZ2V0VmFsdWV9IGZyb20gJy4vZmlsbGVyLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtfYnVpbGRTdGFja0xpbmV9IGZyb20gJy4vZmlsbGVyLnRhcmdldC5zdGFjay5qcyc7XG5pbXBvcnQge3NpbXBsZUFyY30gZnJvbSAnLi9zaW1wbGVBcmMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRUYXJnZXQoc291cmNlKSB7XG4gIGNvbnN0IHtjaGFydCwgZmlsbCwgbGluZX0gPSBzb3VyY2U7XG5cbiAgaWYgKGlzRmluaXRlKGZpbGwpKSB7XG4gICAgcmV0dXJuIGdldExpbmVCeUluZGV4KGNoYXJ0LCBmaWxsKTtcbiAgfVxuXG4gIGlmIChmaWxsID09PSAnc3RhY2snKSB7XG4gICAgcmV0dXJuIF9idWlsZFN0YWNrTGluZShzb3VyY2UpO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09ICdzaGFwZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGJvdW5kYXJ5ID0gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSk7XG5cbiAgaWYgKGJvdW5kYXJ5IGluc3RhbmNlb2Ygc2ltcGxlQXJjKSB7XG4gICAgcmV0dXJuIGJvdW5kYXJ5O1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuZnVuY3Rpb24gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGluZGV4KSB7XG4gIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gIGNvbnN0IHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuICByZXR1cm4gdmlzaWJsZSA/IG1ldGEuZGF0YXNldCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qgc2NhbGUgPSBzb3VyY2Uuc2NhbGUgfHwge307XG5cbiAgaWYgKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSkge1xuICAgIHJldHVybiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpO1xuICB9XG4gIHJldHVybiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKTtcbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSA9IHt9LCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3QgcGl4ZWwgPSBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpO1xuXG4gIGlmIChpc0Zpbml0ZShwaXhlbCkpIHtcbiAgICBjb25zdCBob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/IHBpeGVsIDogbnVsbCxcbiAgICAgIHk6IGhvcml6b250YWwgPyBudWxsIDogcGl4ZWxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBvcHRpb25zID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUuZ2V0TGFiZWxzKCkubGVuZ3RoO1xuICBjb25zdCBzdGFydCA9IG9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1heCA6IHNjYWxlLm1pbjtcbiAgY29uc3QgdmFsdWUgPSBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0KTtcbiAgY29uc3QgdGFyZ2V0ID0gW107XG5cbiAgaWYgKG9wdGlvbnMuZ3JpZC5jaXJjdWxhcikge1xuICAgIGNvbnN0IGNlbnRlciA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSgwLCBzdGFydCk7XG4gICAgcmV0dXJuIG5ldyBzaW1wbGVBcmMoe1xuICAgICAgeDogY2VudGVyLngsXG4gICAgICB5OiBjZW50ZXIueSxcbiAgICAgIHJhZGl1czogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpXG4gICAgfSk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdGFyZ2V0LnB1c2goc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuIiwgImltcG9ydCB7Y2xpcEFyZWEsIHVuY2xpcEFyZWF9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfZmluZFNlZ21lbnRFbmQsIF9nZXRCb3VuZHMsIF9zZWdtZW50c30gZnJvbSAnLi9maWxsZXIuc2VnbWVudC5qcyc7XG5pbXBvcnQge19nZXRUYXJnZXR9IGZyb20gJy4vZmlsbGVyLnRhcmdldC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfZHJhd2ZpbGwoY3R4LCBzb3VyY2UsIGFyZWEpIHtcbiAgY29uc3QgdGFyZ2V0ID0gX2dldFRhcmdldChzb3VyY2UpO1xuICBjb25zdCB7bGluZSwgc2NhbGUsIGF4aXN9ID0gc291cmNlO1xuICBjb25zdCBsaW5lT3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IGxpbmVPcHRzLmZpbGw7XG4gIGNvbnN0IGNvbG9yID0gbGluZU9wdHMuYmFja2dyb3VuZENvbG9yO1xuICBjb25zdCB7YWJvdmUgPSBjb2xvciwgYmVsb3cgPSBjb2xvcn0gPSBmaWxsT3B0aW9uIHx8IHt9O1xuICBpZiAodGFyZ2V0ICYmIGxpbmUucG9pbnRzLmxlbmd0aCkge1xuICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgZG9GaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZSwgYXhpc30pO1xuICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHByb3BlcnR5ID0gbGluZS5fbG9vcCA/ICdhbmdsZScgOiBjZmcuYXhpcztcblxuICBjdHguc2F2ZSgpO1xuXG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnICYmIGJlbG93ICE9PSBhYm92ZSkge1xuICAgIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgYXJlYS50b3ApO1xuICAgIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYWJvdmUsIHNjYWxlLCBwcm9wZXJ0eX0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEuYm90dG9tKTtcbiAgfVxuICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGJlbG93LCBzY2FsZSwgcHJvcGVydHl9KTtcblxuICBjdHgucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGNsaXBZKSB7XG4gIGNvbnN0IHtzZWdtZW50cywgcG9pbnRzfSA9IHRhcmdldDtcbiAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgbGV0IGxpbmVMb29wID0gZmFsc2U7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IHBvaW50c1tfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKV07XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBjbGlwWSk7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICB9XG4gICAgbGluZUxvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHttb3ZlOiBsaW5lTG9vcH0pO1xuICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGxhc3RQb2ludC54LCBjbGlwWSk7XG4gICAgfVxuICB9XG5cbiAgY3R4LmxpbmVUbyh0YXJnZXQuZmlyc3QoKS54LCBjbGlwWSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cblxuZnVuY3Rpb24gZmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSwgY29sb3IsIHNjYWxlfSA9IGNmZztcbiAgY29uc3Qgc2VnbWVudHMgPSBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgZm9yIChjb25zdCB7c291cmNlOiBzcmMsIHRhcmdldDogdGd0LCBzdGFydCwgZW5kfSBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdHlsZToge2JhY2tncm91bmRDb2xvciA9IGNvbG9yfSA9IHt9fSA9IHNyYztcbiAgICBjb25zdCBub3RTaGFwZSA9IHRhcmdldCAhPT0gdHJ1ZTtcblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcblxuICAgIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgbm90U2hhcGUgJiYgX2dldEJvdW5kcyhwcm9wZXJ0eSwgc3RhcnQsIGVuZCkpO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgY29uc3QgbGluZUxvb3AgPSAhIWxpbmUucGF0aFNlZ21lbnQoY3R4LCBzcmMpO1xuXG4gICAgbGV0IGxvb3A7XG4gICAgaWYgKG5vdFNoYXBlKSB7XG4gICAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBlbmQsIHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0TG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgdGd0LCB7bW92ZTogbGluZUxvb3AsIHJldmVyc2U6IHRydWV9KTtcbiAgICAgIGxvb3AgPSBsaW5lTG9vcCAmJiB0YXJnZXRMb29wO1xuICAgICAgaWYgKCFsb29wKSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgc3RhcnQsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwobG9vcCA/ICdldmVub2RkJyA6ICdub256ZXJvJyk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgYm91bmRzKSB7XG4gIGNvbnN0IHt0b3AsIGJvdHRvbX0gPSBzY2FsZS5jaGFydC5jaGFydEFyZWE7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH0gPSBib3VuZHMgfHwge307XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5yZWN0KHN0YXJ0LCB0b3AsIGVuZCAtIHN0YXJ0LCBib3R0b20gLSB0b3ApO1xuICAgIGN0eC5jbGlwKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBwb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgaW50ZXJwb2xhdGVkUG9pbnQgPSB0YXJnZXQuaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKGludGVycG9sYXRlZFBvaW50KSB7XG4gICAgY3R4LmxpbmVUbyhpbnRlcnBvbGF0ZWRQb2ludC54LCBpbnRlcnBvbGF0ZWRQb2ludC55KTtcbiAgfVxufVxuXG4iLCAiLyoqXG4gKiBQbHVnaW4gYmFzZWQgb24gZGlzY3Vzc2lvbiBmcm9tIHRoZSBmb2xsb3dpbmcgQ2hhcnQuanMgaXNzdWVzOlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjM4MCNpc3N1ZWNvbW1lbnQtMjc5OTYxNTY5XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNDQwI2lzc3VlY29tbWVudC0yNTY0NjE4OTdcbiAqL1xuXG5pbXBvcnQgTGluZUVsZW1lbnQgZnJvbSAnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5saW5lLmpzJztcbmltcG9ydCB7X2RyYXdmaWxsfSBmcm9tICcuL2ZpbGxlci5kcmF3aW5nLmpzJztcbmltcG9ydCB7X3Nob3VsZEFwcGx5RmlsbH0gZnJvbSAnLi9maWxsZXIuaGVscGVyLmpzJztcbmltcG9ydCB7X2RlY29kZUZpbGwsIF9yZXNvbHZlVGFyZ2V0fSBmcm9tICcuL2ZpbGxlci5vcHRpb25zLmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2ZpbGxlcicsXG5cbiAgYWZ0ZXJEYXRhc2V0c1VwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XG4gICAgY29uc3Qgc291cmNlcyA9IFtdO1xuICAgIGxldCBtZXRhLCBpLCBsaW5lLCBzb3VyY2U7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICAgIHNvdXJjZSA9IG51bGw7XG5cbiAgICAgIGlmIChsaW5lICYmIGxpbmUub3B0aW9ucyAmJiBsaW5lIGluc3RhbmNlb2YgTGluZUVsZW1lbnQpIHtcbiAgICAgICAgc291cmNlID0ge1xuICAgICAgICAgIHZpc2libGU6IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgZmlsbDogX2RlY29kZUZpbGwobGluZSwgaSwgY291bnQpLFxuICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgIGF4aXM6IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmluZGV4QXhpcyxcbiAgICAgICAgICBzY2FsZTogbWV0YS52U2NhbGUsXG4gICAgICAgICAgbGluZSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbWV0YS4kZmlsbGVyID0gc291cmNlO1xuICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICBpZiAoIXNvdXJjZSB8fCBzb3VyY2UuZmlsbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZS5maWxsID0gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaSwgb3B0aW9ucy5wcm9wYWdhdGUpO1xuICAgIH1cbiAgfSxcblxuICBiZWZvcmVEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGRyYXcgPSBvcHRpb25zLmRyYXdUaW1lID09PSAnYmVmb3JlRHJhdyc7XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc291cmNlLmxpbmUudXBkYXRlQ29udHJvbFBvaW50cyhhcmVhLCBzb3VyY2UuYXhpcyk7XG4gICAgICBpZiAoZHJhdyAmJiBzb3VyY2UuZmlsbCkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiZWZvcmVEYXRhc2V0c0RyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0c0RyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuXG4gICAgICBpZiAoX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpKSB7XG4gICAgICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRGF0YXNldERyYXcoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBhcmdzLm1ldGEuJGZpbGxlcjtcblxuICAgIGlmICghX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHx8IG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0RHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgZHJhd1RpbWU6ICdiZWZvcmVEYXRhc2V0RHJhdydcbiAgfVxufTtcbiIsICJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCBsYXlvdXRzIGZyb20gJy4uL2NvcmUvY29yZS5sYXlvdXRzLmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRoLCBkcmF3UG9pbnRMZWdlbmQsIHJlbmRlclRleHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtcbiAgX2lzQmV0d2VlbixcbiAgY2FsbGJhY2sgYXMgY2FsbCxcbiAgY2xpcEFyZWEsXG4gIGdldFJ0bEFkYXB0ZXIsXG4gIG92ZXJyaWRlVGV4dERpcmVjdGlvbixcbiAgcmVzdG9yZVRleHREaXJlY3Rpb24sXG4gIHRvRm9udCxcbiAgdG9QYWRkaW5nLFxuICB1bmNsaXBBcmVhLFxuICB2YWx1ZU9yRGVmYXVsdCxcbn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19hbGlnblN0YXJ0RW5kLCBfdGV4dFgsIF90b0xlZnRSaWdodENlbnRlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge3RvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICovXG5cbmNvbnN0IGdldEJveFNpemUgPSAobGFiZWxPcHRzLCBmb250U2l6ZSkgPT4ge1xuICBsZXQge2JveEhlaWdodCA9IGZvbnRTaXplLCBib3hXaWR0aCA9IGZvbnRTaXplfSA9IGxhYmVsT3B0cztcblxuICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICBib3hIZWlnaHQgPSBNYXRoLm1pbihib3hIZWlnaHQsIGZvbnRTaXplKTtcbiAgICBib3hXaWR0aCA9IGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggfHwgTWF0aC5taW4oYm94V2lkdGgsIGZvbnRTaXplKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYm94V2lkdGgsXG4gICAgYm94SGVpZ2h0LFxuICAgIGl0ZW1IZWlnaHQ6IE1hdGgubWF4KGZvbnRTaXplLCBib3hIZWlnaHQpXG4gIH07XG59O1xuXG5jb25zdCBpdGVtc0VxdWFsID0gKGEsIGIpID0+IGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLmRhdGFzZXRJbmRleCA9PT0gYi5kYXRhc2V0SW5kZXggJiYgYS5pbmRleCA9PT0gYi5pbmRleDtcblxuZXhwb3J0IGNsYXNzIExlZ2VuZCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3sgY3R4OiBhbnk7IG9wdGlvbnM6IGFueTsgY2hhcnQ6IGFueTsgfX0gY29uZmlnXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcblxuICAgIC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxuICAgIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcblxuICAgIC8qKlxuIFx0XHQgKiBAcHJpdmF0ZVxuIFx0XHQgKi9cbiAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IG51bGw7XG5cbiAgICAvLyBBcmUgd2UgaW4gZG91Z2hudXQgbW9kZSB3aGljaCBoYXMgYSBkaWZmZXJlbnQgZGF0YSB0eXBlXG4gICAgdGhpcy5kb3VnaG51dE1vZGUgPSBmYWxzZTtcblxuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMubGVnZW5kSXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2x1bW5TaXplcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxpbmVXaWR0aHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnM7XG5cbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmJ1aWxkTGFiZWxzKCk7XG4gICAgdGhpcy5maXQoKTtcbiAgfVxuXG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5fbWFyZ2lucy5sZWZ0O1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IHRoaXMuX21hcmdpbnMudG9wO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG4gIH1cblxuICBidWlsZExhYmVscygpIHtcbiAgICBjb25zdCBsYWJlbE9wdHMgPSB0aGlzLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xuICAgIGxldCBsZWdlbmRJdGVtcyA9IGNhbGwobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbdGhpcy5jaGFydF0sIHRoaXMpIHx8IFtdO1xuXG4gICAgaWYgKGxhYmVsT3B0cy5maWx0ZXIpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuZmlsdGVyKChpdGVtKSA9PiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChsYWJlbE9wdHMuc29ydCkge1xuICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5zb3J0KChhLCBiKSA9PiBsYWJlbE9wdHMuc29ydChhLCBiLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG4gIH1cblxuICBmaXQoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGN0eH0gPSB0aGlzO1xuXG4gICAgLy8gVGhlIGxlZ2VuZCBtYXkgbm90IGJlIGRpc3BsYXllZCBmb3IgYSB2YXJpZXR5IG9mIHJlYXNvbnMgaW5jbHVkaW5nXG4gICAgLy8gdGhlIGZhY3QgdGhhdCB0aGUgZGVmYXVsdHMgZ290IHNldCB0byBgZmFsc2VgLlxuICAgIC8vIFdoZW4gdGhlIGxlZ2VuZCBpcyBub3QgZGlzcGxheWVkLCB0aGVyZSBhcmUgbm8gZ3VhcmFudGVlcyB0aGF0IHRoZSBvcHRpb25zXG4gICAgLy8gYXJlIGNvcnJlY3RseSBmb3JtYXR0ZWQgc28gd2UgbmVlZCB0byBiYWlsIG91dCBhcyBlYXJseSBhcyBwb3NzaWJsZS5cbiAgICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbE9wdHMgPSBvcHRpb25zLmxhYmVscztcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7Ym94V2lkdGgsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcblxuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5tYXhXaWR0aDsgLy8gZmlsbCBhbGwgdGhlIHdpZHRoXG4gICAgICBoZWlnaHQgPSB0aGlzLl9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IHRoaXMubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG4gICAgICB3aWR0aCA9IHRoaXMuX2ZpdENvbHModGl0bGVIZWlnaHQsIGxhYmVsRm9udCwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfVxuXG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWluKHdpZHRoLCBvcHRpb25zLm1heFdpZHRoIHx8IHRoaXMubWF4V2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBvcHRpb25zLm1heEhlaWdodCB8fCB0aGlzLm1heEhlaWdodCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhXaWR0aCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIC8vIFdpZHRoIG9mIGVhY2ggbGluZSBvZiBsZWdlbmQgYm94ZXMuIExhYmVscyB3cmFwIG9udG8gbXVsdGlwbGUgbGluZXMgd2hlbiB0aGVyZSBhcmUgdG9vIG1hbnkgdG8gZml0IG9uIG9uZVxuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSB0aGlzLmxpbmVXaWR0aHMgPSBbMF07XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIGxldCB0b3RhbEhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuXG4gICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICBsZXQgcm93ID0gLTE7XG4gICAgbGV0IHRvcCA9IC1saW5lSGVpZ2h0O1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXG4gICAgICBpZiAoaSA9PT0gMCB8fCBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyBpdGVtV2lkdGggKyAyICogcGFkZGluZyA+IG1heFdpZHRoKSB7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAoaSA+IDAgPyAwIDogMSldID0gMDtcbiAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuXG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0OiAwLCB0b3AsIHJvdywgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcblxuICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICs9IGl0ZW1XaWR0aCArIHBhZGRpbmc7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG90YWxIZWlnaHQ7XG4gIH1cblxuICBfZml0Q29scyh0aXRsZUhlaWdodCwgbGFiZWxGb250LCBib3hXaWR0aCwgX2l0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhIZWlnaHQsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCBjb2x1bW5TaXplcyA9IHRoaXMuY29sdW1uU2l6ZXMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRMaW1pdCA9IG1heEhlaWdodCAtIHRpdGxlSGVpZ2h0O1xuXG4gICAgbGV0IHRvdGFsV2lkdGggPSBwYWRkaW5nO1xuICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSAwO1xuICAgIGxldCBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcblxuICAgIGxldCBsZWZ0ID0gMDtcbiAgICBsZXQgY29sID0gMDtcblxuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3Qge2l0ZW1XaWR0aCwgaXRlbUhlaWdodH0gPSBjYWxjdWxhdGVJdGVtU2l6ZShib3hXaWR0aCwgbGFiZWxGb250LCBjdHgsIGxlZ2VuZEl0ZW0sIF9pdGVtSGVpZ2h0KTtcblxuICAgICAgLy8gSWYgdG9vIHRhbGwsIGdvIHRvIG5ldyBjb2x1bW5cbiAgICAgIGlmIChpID4gMCAmJiBjdXJyZW50Q29sSGVpZ2h0ICsgaXRlbUhlaWdodCArIDIgKiBwYWRkaW5nID4gaGVpZ2h0TGltaXQpIHtcbiAgICAgICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTsgLy8gcHJldmlvdXMgY29sdW1uIHNpemVcbiAgICAgICAgbGVmdCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2wrKztcbiAgICAgICAgY3VycmVudENvbFdpZHRoID0gY3VycmVudENvbEhlaWdodCA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBoaXRib3ggd2lkdGggYW5kIGhlaWdodCBoZXJlLiBGaW5hbCBwb3NpdGlvbiB3aWxsIGJlIHVwZGF0ZWQgaW4gYGRyYXdgXG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0LCB0b3A6IGN1cnJlbnRDb2xIZWlnaHQsIGNvbCwgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcblxuICAgICAgLy8gR2V0IG1heCB3aWR0aFxuICAgICAgY3VycmVudENvbFdpZHRoID0gTWF0aC5tYXgoY3VycmVudENvbFdpZHRoLCBpdGVtV2lkdGgpO1xuICAgICAgY3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB9KTtcblxuICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pOyAvLyBwcmV2aW91cyBjb2x1bW4gc2l6ZVxuXG4gICAgcmV0dXJuIHRvdGFsV2lkdGg7XG4gIH1cblxuICBhZGp1c3RIaXRCb3hlcygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2xlZ2VuZEhpdEJveGVzOiBoaXRib3hlcywgb3B0aW9uczoge2FsaWduLCBsYWJlbHM6IHtwYWRkaW5nfSwgcnRsfX0gPSB0aGlzO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIocnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBsZXQgcm93ID0gMDtcbiAgICAgIGxldCBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAocm93ICE9PSBoaXRib3gucm93KSB7XG4gICAgICAgICAgcm93ID0gaGl0Ym94LnJvdztcbiAgICAgICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCArPSB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChsZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgbGVmdCArPSBoaXRib3gud2lkdGggKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29sID0gMDtcbiAgICAgIGxldCB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAoaGl0Ym94LmNvbCAhPT0gY29sKSB7XG4gICAgICAgICAgY29sID0gaGl0Ym94LmNvbDtcbiAgICAgICAgICB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCA9IHRvcDtcbiAgICAgICAgaGl0Ym94LmxlZnQgKz0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChoaXRib3gubGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIHRvcCArPSBoaXRib3guaGVpZ2h0ICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGNsaXBBcmVhKGN0eCwgdGhpcyk7XG5cbiAgICAgIHRoaXMuX2RyYXcoKTtcblxuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXcoKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IG9wdHMsIGNvbHVtblNpemVzLCBsaW5lV2lkdGhzLCBjdHh9ID0gdGhpcztcbiAgICBjb25zdCB7YWxpZ24sIGxhYmVsczogbGFiZWxPcHRzfSA9IG9wdHM7XG4gICAgY29uc3QgZGVmYXVsdENvbG9yID0gZGVmYXVsdHMuY29sb3I7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHtwYWRkaW5nfSA9IGxhYmVsT3B0cztcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IGZvbnRTaXplIC8gMjtcbiAgICBsZXQgY3Vyc29yO1xuXG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcblxuICAgIC8vIENhbnZhcyBzZXR1cFxuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKCdsZWZ0Jyk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5saW5lV2lkdGggPSAwLjU7XG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG4gICAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHQsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcblxuICAgIC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgICBjb25zdCBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgaWYgKGlzTmFOKGJveFdpZHRoKSB8fCBib3hXaWR0aCA8PSAwIHx8IGlzTmFOKGJveEhlaWdodCkgfHwgYm94SGVpZ2h0IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgY3R4IGZvciB0aGUgYm94XG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICBjb25zdCBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgMSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUNhcCwgJ2J1dHQnKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIDApO1xuICAgICAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lSm9pbiwgJ21pdGVyJyk7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcblxuICAgICAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2gsIFtdKSk7XG5cbiAgICAgIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgICAvLyBSZWNhbGN1bGF0ZSB4IGFuZCB5IGZvciBkcmF3UG9pbnQoKSBiZWNhdXNlIGl0cyBleHBlY3RpbmdcbiAgICAgICAgLy8geCBhbmQgeSB0byBiZSBjZW50ZXIgb2YgZmlndXJlIChpbnN0ZWFkIG9mIHRvcCBsZWZ0KVxuICAgICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgICByYWRpdXM6IGJveEhlaWdodCAqIE1hdGguU1FSVDIgLyAyLFxuICAgICAgICAgIHBvaW50U3R5bGU6IGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSxcbiAgICAgICAgICByb3RhdGlvbjogbGVnZW5kSXRlbS5yb3RhdGlvbixcbiAgICAgICAgICBib3JkZXJXaWR0aDogbGluZVdpZHRoXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIueFBsdXMoeCwgYm94V2lkdGggLyAyKTtcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IHkgKyBoYWxmRm9udFNpemU7XG5cbiAgICAgICAgLy8gRHJhdyBwb2ludFN0eWxlIGFzIGxlZ2VuZCBzeW1ib2xcbiAgICAgICAgZHJhd1BvaW50TGVnZW5kKGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclksIGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggJiYgYm94V2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRHJhdyBib3ggYXMgbGVnZW5kIHN5bWJvbFxuICAgICAgICAvLyBBZGp1c3QgcG9zaXRpb24gd2hlbiBib3hIZWlnaHQgPCBmb250U2l6ZSAod2FudCBpdCBjZW50ZXJlZClcbiAgICAgICAgY29uc3QgeUJveFRvcCA9IHkgKyBNYXRoLm1heCgoZm9udFNpemUgLSBib3hIZWlnaHQpIC8gMiwgMCk7XG4gICAgICAgIGNvbnN0IHhCb3hMZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIoeCwgYm94V2lkdGgpO1xuICAgICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxlZ2VuZEl0ZW0uYm9yZGVyUmFkaXVzKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgICB4OiB4Qm94TGVmdCxcbiAgICAgICAgICAgIHk6IHlCb3hUb3AsXG4gICAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5yZWN0KHhCb3hMZWZ0LCB5Qm94VG9wLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggIT09IDApIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmlsbFRleHQgPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGVnZW5kSXRlbS50ZXh0LCB4LCB5ICsgKGl0ZW1IZWlnaHQgLyAyKSwgbGFiZWxGb250LCB7XG4gICAgICAgIHN0cmlrZXRocm91Z2g6IGxlZ2VuZEl0ZW0uaGlkZGVuLFxuICAgICAgICB0ZXh0QWxpZ246IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24pXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gSG9yaXpvbnRhbFxuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1swXSksXG4gICAgICAgIHk6IHRoaXMudG9wICsgcGFkZGluZyArIHRpdGxlSGVpZ2h0LFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IHRoaXMubGVmdCArIHBhZGRpbmcsXG4gICAgICAgIHk6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1swXS5oZWlnaHQpLFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcblxuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yOyAvLyBmb3Igc3RyaWtldGhyb3VnaCBlZmZlY3RcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cbiAgICAgIGNvbnN0IHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbiB8fCAobGVnZW5kSXRlbS50ZXh0QWxpZ24gPSBsYWJlbE9wdHMudGV4dEFsaWduKSk7XG4gICAgICBjb25zdCB3aWR0aCA9IGJveFdpZHRoICsgaGFsZkZvbnRTaXplICsgdGV4dFdpZHRoO1xuICAgICAgbGV0IHggPSBjdXJzb3IueDtcbiAgICAgIGxldCB5ID0gY3Vyc29yLnk7XG5cbiAgICAgIHJ0bEhlbHBlci5zZXRXaWR0aCh0aGlzLndpZHRoKTtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgcGFkZGluZyA+IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICB5ID0gY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICAgIHggPSBjdXJzb3IueCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBsaW5lSGVpZ2h0ID4gdGhpcy5ib3R0b20pIHtcbiAgICAgICAgeCA9IGN1cnNvci54ID0geCArIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS53aWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgIHkgPSBjdXJzb3IueSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0uaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVhbFggPSBydGxIZWxwZXIueCh4KTtcblxuICAgICAgZHJhd0xlZ2VuZEJveChyZWFsWCwgeSwgbGVnZW5kSXRlbSk7XG5cbiAgICAgIHggPSBfdGV4dFgodGV4dEFsaWduLCB4ICsgYm94V2lkdGggKyBoYWxmRm9udFNpemUsIGlzSG9yaXpvbnRhbCA/IHggKyB3aWR0aCA6IHRoaXMucmlnaHQsIG9wdHMucnRsKTtcblxuICAgICAgLy8gRmlsbCB0aGUgYWN0dWFsIGxhYmVsXG4gICAgICBmaWxsVGV4dChydGxIZWxwZXIueCh4KSwgeSwgbGVnZW5kSXRlbSk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgY3Vyc29yLnggKz0gd2lkdGggKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGVnZW5kSXRlbS50ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBmb250TGluZUhlaWdodCA9IGxhYmVsRm9udC5saW5lSGVpZ2h0O1xuICAgICAgICBjdXJzb3IueSArPSBjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0KGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSArIHBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVzdG9yZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gb3B0cy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG5cbiAgICBpZiAoIXRpdGxlT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRpdGxlT3B0cy5wb3NpdGlvbjtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSB0aXRsZUZvbnQuc2l6ZSAvIDI7XG4gICAgY29uc3QgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgPSB0aXRsZVBhZGRpbmcudG9wICsgaGFsZkZvbnRTaXplO1xuICAgIGxldCB5O1xuXG4gICAgLy8gVGhlc2UgZGVmYXVsdHMgYXJlIHVzZWQgd2hlbiB0aGUgbGVnZW5kIGlzIHZlcnRpY2FsLlxuICAgIC8vIFdoZW4gaG9yaXpvbnRhbCwgdGhleSBhcmUgY29tcHV0ZWQgYmVsb3cuXG4gICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgbGV0IG1heFdpZHRoID0gdGhpcy53aWR0aDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAvLyBNb3ZlIGxlZnQgLyByaWdodCBzbyB0aGF0IHRoZSB0aXRsZSBpcyBhYm92ZSB0aGUgbGVnZW5kIGxpbmVzXG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KC4uLnRoaXMubGluZVdpZHRocyk7XG4gICAgICB5ID0gdGhpcy50b3AgKyB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZTtcbiAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCBsZWZ0LCB0aGlzLnJpZ2h0IC0gbWF4V2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGRvd24gc28gdGhhdCB0aGUgdGl0bGUgaXMgYWJvdmUgdGhlIGxlZ2VuZCBzdGFjayBpbiBldmVyeSBhbGlnbm1lbnRcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuY29sdW1uU2l6ZXMucmVkdWNlKChhY2MsIHNpemUpID0+IE1hdGgubWF4KGFjYywgc2l6ZS5oZWlnaHQpLCAwKTtcbiAgICAgIHkgPSB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSArIF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIHRoaXMudG9wLCB0aGlzLmJvdHRvbSAtIG1heEhlaWdodCAtIG9wdHMubGFiZWxzLnBhZGRpbmcgLSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKSk7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2Uga25vdyB0aGUgbGVmdCBlZGdlIG9mIHRoZSBpbm5lciBsZWdlbmQgYm94LCBjb21wdXRlIHRoZSBjb3JyZWN0XG4gICAgLy8gWCBjb29yZGluYXRlIGZyb20gdGhlIHRpdGxlIGFsaWdubWVudFxuICAgIGNvbnN0IHggPSBfYWxpZ25TdGFydEVuZChwb3NpdGlvbiwgbGVmdCwgbGVmdCArIG1heFdpZHRoKTtcblxuICAgIC8vIENhbnZhcyBzZXR1cFxuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKF90b0xlZnRSaWdodENlbnRlcihwb3NpdGlvbikpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG5cbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGVPcHRzLnRleHQsIHgsIHksIHRpdGxlRm9udCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlVGl0bGVIZWlnaHQoKSB7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICByZXR1cm4gdGl0bGVPcHRzLmRpc3BsYXkgPyB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlUGFkZGluZy5oZWlnaHQgOiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGVnZW5kSXRlbUF0KHgsIHkpIHtcbiAgICBsZXQgaSwgaGl0Qm94LCBsaDtcblxuICAgIGlmIChfaXNCZXR3ZWVuKHgsIHRoaXMubGVmdCwgdGhpcy5yaWdodClcbiAgICAgICYmIF9pc0JldHdlZW4oeSwgdGhpcy50b3AsIHRoaXMuYm90dG9tKSkge1xuICAgICAgLy8gU2VlIGlmIHdlIGFyZSB0b3VjaGluZyBvbmUgb2YgdGhlIGRhdGFzZXQgYm94ZXNcbiAgICAgIGxoID0gdGhpcy5sZWdlbmRIaXRCb3hlcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaC5sZW5ndGg7ICsraSkge1xuICAgICAgICBoaXRCb3ggPSBsaFtpXTtcblxuICAgICAgICBpZiAoX2lzQmV0d2Vlbih4LCBoaXRCb3gubGVmdCwgaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGgpXG4gICAgICAgICAgJiYgX2lzQmV0d2Vlbih5LCBoaXRCb3gudG9wLCBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkpIHtcbiAgICAgICAgICAvLyBUb3VjaGluZyBhbiBlbGVtZW50XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGVnZW5kSXRlbXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKi9cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFpc0xpc3RlbmVkKGUudHlwZSwgb3B0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGFydCBldmVudCBhbHJlYWR5IGhhcyByZWxhdGl2ZSBwb3NpdGlvbiBpbiBpdFxuICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gdGhpcy5fZ2V0TGVnZW5kSXRlbUF0KGUueCwgZS55KTtcblxuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLl9ob3ZlcmVkSXRlbTtcbiAgICAgIGNvbnN0IHNhbWVJdGVtID0gaXRlbXNFcXVhbChwcmV2aW91cywgaG92ZXJlZEl0ZW0pO1xuICAgICAgaWYgKHByZXZpb3VzICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsKG9wdHMub25MZWF2ZSwgW2UsIHByZXZpb3VzLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gaG92ZXJlZEl0ZW07XG5cbiAgICAgIGlmIChob3ZlcmVkSXRlbSAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbChvcHRzLm9uSG92ZXIsIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0pIHtcbiAgICAgIGNhbGwob3B0cy5vbkNsaWNrLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSXRlbVNpemUoYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4LCBsZWdlbmRJdGVtLCBfaXRlbUhlaWdodCkge1xuICBjb25zdCBpdGVtV2lkdGggPSBjYWxjdWxhdGVJdGVtV2lkdGgobGVnZW5kSXRlbSwgYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4KTtcbiAgY29uc3QgaXRlbUhlaWdodCA9IGNhbGN1bGF0ZUl0ZW1IZWlnaHQoX2l0ZW1IZWlnaHQsIGxlZ2VuZEl0ZW0sIGxhYmVsRm9udC5saW5lSGVpZ2h0KTtcbiAgcmV0dXJuIHtpdGVtV2lkdGgsIGl0ZW1IZWlnaHR9O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJdGVtV2lkdGgobGVnZW5kSXRlbSwgYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4KSB7XG4gIGxldCBsZWdlbmRJdGVtVGV4dCA9IGxlZ2VuZEl0ZW0udGV4dDtcbiAgaWYgKGxlZ2VuZEl0ZW1UZXh0ICYmIHR5cGVvZiBsZWdlbmRJdGVtVGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICBsZWdlbmRJdGVtVGV4dCA9IGxlZ2VuZEl0ZW1UZXh0LnJlZHVjZSgoYSwgYikgPT4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiKTtcbiAgfVxuICByZXR1cm4gYm94V2lkdGggKyAobGFiZWxGb250LnNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtVGV4dCkud2lkdGg7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1IZWlnaHQoX2l0ZW1IZWlnaHQsIGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSB7XG4gIGxldCBpdGVtSGVpZ2h0ID0gX2l0ZW1IZWlnaHQ7XG4gIGlmICh0eXBlb2YgbGVnZW5kSXRlbS50ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgIGl0ZW1IZWlnaHQgPSBjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0KGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gaXRlbUhlaWdodDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkge1xuICBjb25zdCBsYWJlbEhlaWdodCA9IGxlZ2VuZEl0ZW0udGV4dCA/IGxlZ2VuZEl0ZW0udGV4dC5sZW5ndGggOiAwO1xuICByZXR1cm4gZm9udExpbmVIZWlnaHQgKiBsYWJlbEhlaWdodDtcbn1cblxuZnVuY3Rpb24gaXNMaXN0ZW5lZCh0eXBlLCBvcHRzKSB7XG4gIGlmICgodHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgdHlwZSA9PT0gJ21vdXNlb3V0JykgJiYgKG9wdHMub25Ib3ZlciB8fCBvcHRzLm9uTGVhdmUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9wdHMub25DbGljayAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAnbW91c2V1cCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnbGVnZW5kJyxcblxuICAvKipcblx0ICogRm9yIHRlc3RzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZWxlbWVudDogTGVnZW5kLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZCA9IG5ldyBMZWdlbmQoe2N0eDogY2hhcnQuY3R4LCBvcHRpb25zLCBjaGFydH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCBsZWdlbmQpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgY2hhcnQubGVnZW5kKTtcbiAgICBkZWxldGUgY2hhcnQubGVnZW5kO1xuICB9LFxuXG4gIC8vIER1cmluZyB0aGUgYmVmb3JlVXBkYXRlIHN0ZXAsIHRoZSBsYXlvdXQgY29uZmlndXJhdGlvbiBuZWVkcyB0byBydW5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgaWYgdGhlIGxlZ2VuZCBwb3NpdGlvbiBjaGFuZ2VzICh2aWEgYW4gb3B0aW9uIHVwZGF0ZSlcbiAgLy8gdGhlIGxheW91dCBzeXN0ZW0gcmVzcGVjdHMgdGhlIGNoYW5nZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy83NTI3XG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGVnZW5kLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIC8vIFRoZSBsYWJlbHMgbmVlZCB0byBiZSBidWlsdCBhZnRlciBkYXRhc2V0cyBhcmUgdXBkYXRlZCB0byBlbnN1cmUgdGhhdCBjb2xvcnNcbiAgLy8gYW5kIG90aGVyIHN0eWxpbmcgYXJlIGNvcnJlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNjk2OFxuICBhZnRlclVwZGF0ZShjaGFydCkge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsZWdlbmQuYnVpbGRMYWJlbHMoKTtcbiAgICBsZWdlbmQuYWRqdXN0SGl0Qm94ZXMoKTtcbiAgfSxcblxuXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MucmVwbGF5KSB7XG4gICAgICBjaGFydC5sZWdlbmQuaGFuZGxlRXZlbnQoYXJncy5ldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHJldmVyc2U6IGZhbHNlLFxuICAgIHdlaWdodDogMTAwMCxcblxuICAgIC8vIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGhhbmRsZVxuICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4O1xuICAgICAgY29uc3QgY2kgPSBsZWdlbmQuY2hhcnQ7XG4gICAgICBpZiAoY2kuaXNEYXRhc2V0VmlzaWJsZShpbmRleCkpIHtcbiAgICAgICAgY2kuaGlkZShpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpLnNob3coaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkhvdmVyOiBudWxsLFxuICAgIG9uTGVhdmU6IG51bGwsXG5cbiAgICBsYWJlbHM6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGJveFdpZHRoOiA0MCxcbiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgLy8gR2VuZXJhdGVzIGxhYmVscyBzaG93biBpbiB0aGUgbGVnZW5kXG4gICAgICAvLyBWYWxpZCBwcm9wZXJ0aWVzIHRvIHJldHVybjpcbiAgICAgIC8vIHRleHQgOiB0ZXh0IHRvIGRpc3BsYXlcbiAgICAgIC8vIGZpbGxTdHlsZSA6IGZpbGwgb2YgY29sb3VyZWQgYm94XG4gICAgICAvLyBzdHJva2VTdHlsZTogc3Ryb2tlIG9mIGNvbG91cmVkIGJveFxuICAgICAgLy8gaGlkZGVuIDogaWYgdGhpcyBsZWdlbmQgaXRlbSByZWZlcnMgdG8gYSBoaWRkZW4gaXRlbVxuICAgICAgLy8gbGluZUNhcCA6IGNhcCBzdHlsZSBmb3IgbGluZVxuICAgICAgLy8gbGluZURhc2hcbiAgICAgIC8vIGxpbmVEYXNoT2Zmc2V0IDpcbiAgICAgIC8vIGxpbmVKb2luIDpcbiAgICAgIC8vIGxpbmVXaWR0aCA6XG4gICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG4gICAgICAgIGNvbnN0IHtsYWJlbHM6IHt1c2VQb2ludFN0eWxlLCBwb2ludFN0eWxlLCB0ZXh0QWxpZ24sIGNvbG9yLCB1c2VCb3JkZXJSYWRpdXMsIGJvcmRlclJhZGl1c319ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKS5tYXAoKG1ldGEpID0+IHtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh1c2VQb2ludFN0eWxlID8gMCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSB0b1BhZGRpbmcoc3R5bGUuYm9yZGVyV2lkdGgpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGRhdGFzZXRzW21ldGEuaW5kZXhdLmxhYmVsLFxuICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgaGlkZGVuOiAhbWV0YS52aXNpYmxlLFxuICAgICAgICAgICAgbGluZUNhcDogc3R5bGUuYm9yZGVyQ2FwU3R5bGUsXG4gICAgICAgICAgICBsaW5lRGFzaDogc3R5bGUuYm9yZGVyRGFzaCxcbiAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgbGluZUpvaW46IHN0eWxlLmJvcmRlckpvaW5TdHlsZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogKGJvcmRlcldpZHRoLndpZHRoICsgYm9yZGVyV2lkdGguaGVpZ2h0KSAvIDQsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlIHx8IHN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgICAgICByb3RhdGlvbjogc3R5bGUucm90YXRpb24sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbiB8fCBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHVzZUJvcmRlclJhZGl1cyAmJiAoYm9yZGVyUmFkaXVzIHx8IHN0eWxlLmJvcmRlclJhZGl1cyksXG5cbiAgICAgICAgICAgIC8vIEJlbG93IGlzIGV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGRhdGFzZXRzXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdGl0bGU6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICAgICAgdGV4dDogJycsXG4gICAgfVxuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICAgIGxhYmVsczoge1xuICAgICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhWydnZW5lcmF0ZUxhYmVscycsICdmaWx0ZXInLCAnc29ydCddLmluY2x1ZGVzKG5hbWUpLFxuICAgIH1cbiAgfSxcbn07XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi4vY29yZS9jb3JlLmxheW91dHMuanMnO1xuaW1wb3J0IHtQSSwgaXNBcnJheSwgdG9QYWRkaW5nLCB0b0ZvbnR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfdG9MZWZ0UmlnaHRDZW50ZXIsIF9hbGlnblN0YXJ0RW5kfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcbmltcG9ydCB7cmVuZGVyVGV4dH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5cbmV4cG9ydCBjbGFzcyBUaXRsZSBleHRlbmRzIEVsZW1lbnQge1xuICAvKipcblx0ICogQHBhcmFtIHt7IGN0eDogYW55OyBvcHRpb25zOiBhbnk7IGNoYXJ0OiBhbnk7IH19IGNvbmZpZ1xuXHQgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMuX3BhZGRpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB0aGlzLmxlZnQgPSAwO1xuICAgIHRoaXMudG9wID0gMDtcblxuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSB0aGlzLnJpZ2h0ID0gdGhpcy5ib3R0b20gPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMud2lkdGggPSB0aGlzLnJpZ2h0ID0gbWF4V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmJvdHRvbSA9IG1heEhlaWdodDtcblxuICAgIGNvbnN0IGxpbmVDb3VudCA9IGlzQXJyYXkob3B0cy50ZXh0KSA/IG9wdHMudGV4dC5sZW5ndGggOiAxO1xuICAgIHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5wYWRkaW5nKTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IGxpbmVDb3VudCAqIHRvRm9udChvcHRzLmZvbnQpLmxpbmVIZWlnaHQgKyB0aGlzLl9wYWRkaW5nLmhlaWdodDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRleHRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGV4dFNpemU7XG4gICAgfVxuICB9XG5cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zID09PSAndG9wJyB8fCBwb3MgPT09ICdib3R0b20nO1xuICB9XG5cbiAgX2RyYXdBcmdzKG9mZnNldCkge1xuICAgIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBhbGlnbiA9IG9wdGlvbnMuYWxpZ247XG4gICAgbGV0IHJvdGF0aW9uID0gMDtcbiAgICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgICB0aXRsZVkgPSB0b3AgKyBvZmZzZXQ7XG4gICAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICB0aXRsZVggPSBsZWZ0ICsgb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogLTAuNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlWCA9IHJpZ2h0IC0gb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdG9wLCBib3R0b20pO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogMC41O1xuICAgICAgfVxuICAgICAgbWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG4gICAgfVxuICAgIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbnRPcHRzID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGZvbnRPcHRzLmxpbmVIZWlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbGluZUhlaWdodCAvIDIgKyB0aGlzLl9wYWRkaW5nLnRvcDtcbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aGlzLl9kcmF3QXJncyhvZmZzZXQpO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIG9wdHMudGV4dCwgMCwgMCwgZm9udE9wdHMsIHtcbiAgICAgIGNvbG9yOiBvcHRzLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogX3RvTGVmdFJpZ2h0Q2VudGVyKG9wdHMuYWxpZ24pLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpdGxlKGNoYXJ0LCB0aXRsZU9wdHMpIHtcbiAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgIGN0eDogY2hhcnQuY3R4LFxuICAgIG9wdGlvbnM6IHRpdGxlT3B0cyxcbiAgICBjaGFydFxuICB9KTtcblxuICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIHRpdGxlT3B0cyk7XG4gIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gIGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ3RpdGxlJyxcblxuICAvKipcblx0ICogRm9yIHRlc3RzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZWxlbWVudDogVGl0bGUsXG5cbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY3JlYXRlVGl0bGUoY2hhcnQsIG9wdGlvbnMpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG4gICAgZGVsZXRlIGNoYXJ0LnRpdGxlQmxvY2s7XG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMTAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMjAwMCAgICAgICAgIC8vIGJ5IGRlZmF1bHQgZ3JlYXRlciB0aGFuIGxlZ2VuZCAoMTAwMCkgdG8gYmUgYWJvdmVcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcbiIsICJpbXBvcnQge1RpdGxlfSBmcm9tICcuL3BsdWdpbi50aXRsZS5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuLi9jb3JlL2NvcmUubGF5b3V0cy5qcyc7XG5cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdzdWJ0aXRsZScsXG5cbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgICAgY3R4OiBjaGFydC5jdHgsXG4gICAgICBvcHRpb25zLFxuICAgICAgY2hhcnRcbiAgICB9KTtcblxuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgICBtYXAuc2V0KGNoYXJ0LCB0aXRsZSk7XG4gIH0sXG5cbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBtYXAuZ2V0KGNoYXJ0KSk7XG4gICAgbWFwLmRlbGV0ZShjaGFydCk7XG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbWFwLmdldChjaGFydCk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdub3JtYWwnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAxNTAwICAgICAgICAgLy8gYnkgZGVmYXVsdCBncmVhdGVyIHRoYW4gbGVnZW5kICgxMDAwKSBhbmQgc21hbGxlciB0aGFuIHRpdGxlICgyMDAwKVxuICB9LFxuXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuIiwgImltcG9ydCBBbmltYXRpb25zIGZyb20gJy4uL2NvcmUvY29yZS5hbmltYXRpb25zLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRofSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7ZWFjaCwgbm9vcCwgaXNOdWxsT3JVbmRlZiwgaXNBcnJheSwgX2VsZW1lbnRzRXF1YWwsIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvRm9udCwgdG9QYWRkaW5nLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2dldFJ0bEFkYXB0ZXIsIG92ZXJyaWRlVGV4dERpcmVjdGlvbiwgcmVzdG9yZVRleHREaXJlY3Rpb259IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5ydGwuanMnO1xuaW1wb3J0IHtkaXN0YW5jZUJldHdlZW5Qb2ludHMsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIGRyYXdQb2ludH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2UuanMnKS5DaGFydCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQWN0aXZlRWxlbWVudCB9IEFjdGl2ZUVsZW1lbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuaW50ZXJhY3Rpb24uanMnKS5JbnRlcmFjdGlvbkl0ZW0gfSBJbnRlcmFjdGlvbkl0ZW1cbiAqL1xuXG5jb25zdCBwb3NpdGlvbmVycyA9IHtcbiAgLyoqXG5cdCAqIEF2ZXJhZ2UgbW9kZSBwbGFjZXMgdGhlIHRvb2x0aXAgYXQgdGhlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnRzIHNob3duXG5cdCAqL1xuICBhdmVyYWdlKGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgaSwgbGVuO1xuICAgIGxldCB4U2V0ID0gbmV3IFNldCgpO1xuICAgIGxldCB5ID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGVsLnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgICB4U2V0LmFkZChwb3MueCk7XG4gICAgICAgIHkgKz0gcG9zLnk7XG4gICAgICAgICsrY291bnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeEF2ZXJhZ2UgPSBbLi4ueFNldF0ucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyB4U2V0LnNpemU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeEF2ZXJhZ2UsXG4gICAgICB5OiB5IC8gY291bnRcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSB0b29sdGlwIHBvc2l0aW9uIG5lYXJlc3Qgb2YgdGhlIGl0ZW0gbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb25cblx0ICovXG4gIG5lYXJlc3QoaXRlbXMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCB4ID0gZXZlbnRQb3NpdGlvbi54O1xuICAgIGxldCB5ID0gZXZlbnRQb3NpdGlvbi55O1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgICBjb25zdCBkID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGV2ZW50UG9zaXRpb24sIGNlbnRlcik7XG5cbiAgICAgICAgaWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZDtcbiAgICAgICAgICBuZWFyZXN0RWxlbWVudCA9IGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lYXJlc3RFbGVtZW50KSB7XG4gICAgICBjb25zdCB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgeCA9IHRwLng7XG4gICAgICB5ID0gdHAueTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG59O1xuXG4vLyBIZWxwZXIgdG8gcHVzaCBvciBjb25jYXQgYmFzZWQgb24gaWYgdGhlIDJuZCBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3Igbm90XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG4gIGlmICh0b1B1c2gpIHtcbiAgICBpZiAoaXNBcnJheSh0b1B1c2gpKSB7XG4gICAgICAvLyBiYXNlID0gYmFzZS5jb25jYXQodG9QdXNoKTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJhc2UsIHRvUHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UucHVzaCh0b1B1c2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYXJyYXkgb2Ygc3RyaW5ncyBzcGxpdCBieSBuZXdsaW5lXG4gKiBAcGFyYW0geyp9IHN0ciAtIFRoZSB2YWx1ZSB0byBzcGxpdCBieSBuZXdsaW5lLlxuICogQHJldHVybnMge3N0cmluZ3xzdHJpbmdbXX0gdmFsdWUgaWYgbmV3bGluZSBwcmVzZW50IC0gUmV0dXJuZWQgZnJvbSBTdHJpbmcgc3BsaXQoKSBtZXRob2RcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBzcGxpdE5ld2xpbmVzKHN0cikge1xuICBpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG5cbi8qKlxuICogUHJpdmF0ZSBoZWxwZXIgdG8gY3JlYXRlIGEgdG9vbHRpcCBpdGVtIG1vZGVsXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuICogQHBhcmFtIHtBY3RpdmVFbGVtZW50fSBpdGVtIC0ge2VsZW1lbnQsIGluZGV4LCBkYXRhc2V0SW5kZXh9IHRvIGNyZWF0ZSB0aGUgdG9vbHRpcCBpdGVtIGZvclxuICogQHJldHVybiBuZXcgdG9vbHRpcCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGNoYXJ0LCBpdGVtKSB7XG4gIGNvbnN0IHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSA9IGl0ZW07XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gIGNvbnN0IHtsYWJlbCwgdmFsdWV9ID0gY29udHJvbGxlci5nZXRMYWJlbEFuZFZhbHVlKGluZGV4KTtcblxuICByZXR1cm4ge1xuICAgIGNoYXJ0LFxuICAgIGxhYmVsLFxuICAgIHBhcnNlZDogY29udHJvbGxlci5nZXRQYXJzZWQoaW5kZXgpLFxuICAgIHJhdzogY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdLFxuICAgIGZvcm1hdHRlZFZhbHVlOiB2YWx1ZSxcbiAgICBkYXRhc2V0OiBjb250cm9sbGVyLmdldERhdGFzZXQoKSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIGRhdGFzZXRJbmRleCxcbiAgICBlbGVtZW50XG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIHRoZSB0b29sdGlwXG4gKi9cbmZ1bmN0aW9uIGdldFRvb2x0aXBTaXplKHRvb2x0aXAsIG9wdGlvbnMpIHtcbiAgY29uc3QgY3R4ID0gdG9vbHRpcC5jaGFydC5jdHg7XG4gIGNvbnN0IHtib2R5LCBmb290ZXIsIHRpdGxlfSA9IHRvb2x0aXA7XG4gIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0fSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICBjb25zdCBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gIGNvbnN0IHRpdGxlTGluZUNvdW50ID0gdGl0bGUubGVuZ3RoO1xuICBjb25zdCBmb290ZXJMaW5lQ291bnQgPSBmb290ZXIubGVuZ3RoO1xuICBjb25zdCBib2R5TGluZUl0ZW1Db3VudCA9IGJvZHkubGVuZ3RoO1xuXG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgbGV0IGhlaWdodCA9IHBhZGRpbmcuaGVpZ2h0O1xuICBsZXQgd2lkdGggPSAwO1xuXG4gIC8vIENvdW50IG9mIGFsbCBsaW5lcyBpbiB0aGUgYm9keVxuICBsZXQgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoKGNvdW50LCBib2R5SXRlbSkgPT4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoLCAwKTtcbiAgY29tYmluZWRCb2R5TGVuZ3RoICs9IHRvb2x0aXAuYmVmb3JlQm9keS5sZW5ndGggKyB0b29sdGlwLmFmdGVyQm9keS5sZW5ndGg7XG5cbiAgaWYgKHRpdGxlTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ICogdGl0bGVGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKHRpdGxlTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLnRpdGxlU3BhY2luZ1xuXHRcdFx0KyBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tO1xuICB9XG4gIGlmIChjb21iaW5lZEJvZHlMZW5ndGgpIHtcbiAgICAvLyBCb2R5IGxpbmVzIG1heSBpbmNsdWRlIHNvbWUgZXh0cmEgaGVpZ2h0IGRlcGVuZGluZyBvbiBib3hIZWlnaHRcbiAgICBjb25zdCBib2R5TGluZUhlaWdodCA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IE1hdGgubWF4KGJveEhlaWdodCwgYm9keUZvbnQubGluZUhlaWdodCkgOiBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGhlaWdodCArPSBib2R5TGluZUl0ZW1Db3VudCAqIGJvZHlMaW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSBib2R5TGluZUl0ZW1Db3VudCkgKiBib2R5Rm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG9wdGlvbnMuYm9keVNwYWNpbmc7XG4gIH1cbiAgaWYgKGZvb3RlckxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcFxuXHRcdFx0KyBmb290ZXJMaW5lQ291bnQgKiBmb290ZXJGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGZvb3RlckxpbmVDb3VudCAtIDEpICogb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICB9XG5cbiAgLy8gVGl0bGUgd2lkdGhcbiAgbGV0IHdpZHRoUGFkZGluZyA9IDA7XG4gIGNvbnN0IG1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGggKyB3aWR0aFBhZGRpbmcpO1xuICB9O1xuXG4gIGN0eC5zYXZlKCk7XG5cbiAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAudGl0bGUsIG1heExpbmVXaWR0aCk7XG5cbiAgLy8gQm9keSB3aWR0aFxuICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmJlZm9yZUJvZHkuY29uY2F0KHRvb2x0aXAuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcblxuICAvLyBCb2R5IGxpbmVzIG1heSBpbmNsdWRlIHNvbWUgZXh0cmEgd2lkdGggZHVlIHRvIHRoZSBjb2xvciBib3hcbiAgd2lkdGhQYWRkaW5nID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gKGJveFdpZHRoICsgMiArIG9wdGlvbnMuYm94UGFkZGluZykgOiAwO1xuICBlYWNoKGJvZHksIChib2R5SXRlbSkgPT4ge1xuICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgYmFjayB0byAwXG4gIHdpZHRoUGFkZGluZyA9IDA7XG5cbiAgLy8gRm9vdGVyIHdpZHRoXG4gIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5mb290ZXIsIG1heExpbmVXaWR0aCk7XG5cbiAgY3R4LnJlc3RvcmUoKTtcblxuICAvLyBBZGQgcGFkZGluZ1xuICB3aWR0aCArPSBwYWRkaW5nLndpZHRoO1xuXG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSkge1xuICBjb25zdCB7eSwgaGVpZ2h0fSA9IHNpemU7XG5cbiAgaWYgKHkgPCBoZWlnaHQgLyAyKSB7XG4gICAgcmV0dXJuICd0b3AnO1xuICB9IGVsc2UgaWYgKHkgPiAoY2hhcnQuaGVpZ2h0IC0gaGVpZ2h0IC8gMikpIHtcbiAgICByZXR1cm4gJ2JvdHRvbSc7XG4gIH1cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuXG5mdW5jdGlvbiBkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IGNhcmV0ID0gb3B0aW9ucy5jYXJldFNpemUgKyBvcHRpb25zLmNhcmV0UGFkZGluZztcbiAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnICYmIHggKyB3aWR0aCArIGNhcmV0ID4gY2hhcnQud2lkdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcgJiYgeCAtIHdpZHRoIC0gY2FyZXQgPCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IHt3aWR0aDogY2hhcnRXaWR0aCwgY2hhcnRBcmVhOiB7bGVmdCwgcmlnaHR9fSA9IGNoYXJ0O1xuICBsZXQgeEFsaWduID0gJ2NlbnRlcic7XG5cbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4QWxpZ24gPSB4IDw9IChsZWZ0ICsgcmlnaHQpIC8gMiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH0gZWxzZSBpZiAoeCA8PSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoeCA+PSBjaGFydFdpZHRoIC0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ3JpZ2h0JztcbiAgfVxuXG4gIGlmIChkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpKSB7XG4gICAgeEFsaWduID0gJ2NlbnRlcic7XG4gIH1cblxuICByZXR1cm4geEFsaWduO1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgdGhlIGFsaWdubWVudCBvZiBhIHRvb2x0aXAgZ2l2ZW4gdGhlIHNpemVcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHlBbGlnbiA9IHNpemUueUFsaWduIHx8IG9wdGlvbnMueUFsaWduIHx8IGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB4QWxpZ246IHNpemUueEFsaWduIHx8IG9wdGlvbnMueEFsaWduIHx8IGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSxcbiAgICB5QWxpZ25cbiAgfTtcbn1cblxuZnVuY3Rpb24gYWxpZ25YKHNpemUsIHhBbGlnbikge1xuICBsZXQge3gsIHdpZHRofSA9IHNpemU7XG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgeSArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSAtPSBoZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICB5IC09IChoZWlnaHQgLyAyKTtcbiAgfVxuICByZXR1cm4geTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBsb2NhdGlvbiBhIHRvb2x0aXAgbmVlZHMgdG8gYmUgcGxhY2VkIGF0IGdpdmVuIHRoZSBpbml0aWFsIHBvc2l0aW9uICh2aWEgdGhlIHZtKSBhbmQgdGhlIHNpemUgYW5kIGFsaWdubWVudFxuICovXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xuICBjb25zdCB7Y2FyZXRTaXplLCBjYXJldFBhZGRpbmcsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gYWxpZ25tZW50O1xuICBjb25zdCBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcbiAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG5cbiAgbGV0IHggPSBhbGlnblgoc2l6ZSwgeEFsaWduKTtcbiAgY29uc3QgeSA9IGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKTtcblxuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgeCArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgeCAtPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICB4IC09IE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgY2FyZXRTaXplO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggKz0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSArIGNhcmV0U2l6ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogX2xpbWl0VmFsdWUoeCwgMCwgY2hhcnQud2lkdGggLSBzaXplLndpZHRoKSxcbiAgICB5OiBfbGltaXRWYWx1ZSh5LCAwLCBjaGFydC5oZWlnaHQgLSBzaXplLmhlaWdodClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodG9vbHRpcCwgYWxpZ24sIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuXG4gIHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcbiAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLyAyXG4gICAgOiBhbGlnbiA9PT0gJ3JpZ2h0J1xuICAgICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC0gcGFkZGluZy5yaWdodFxuICAgICAgOiB0b29sdGlwLnggKyBwYWRkaW5nLmxlZnQ7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGJ1aWxkIGJlZm9yZSBhbmQgYWZ0ZXIgYm9keSBsaW5lc1xuICovXG5mdW5jdGlvbiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhjYWxsYmFjaykge1xuICByZXR1cm4gcHVzaE9yQ29uY2F0KFtdLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBDb250ZXh0KHBhcmVudCwgdG9vbHRpcCwgdG9vbHRpcEl0ZW1zKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRvb2x0aXAsXG4gICAgdG9vbHRpcEl0ZW1zLFxuICAgIHR5cGU6ICd0b29sdGlwJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gY29udGV4dCAmJiBjb250ZXh0LmRhdGFzZXQgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAuY2FsbGJhY2tzO1xuICByZXR1cm4gb3ZlcnJpZGUgPyBjYWxsYmFja3Mub3ZlcnJpZGUob3ZlcnJpZGUpIDogY2FsbGJhY2tzO1xufVxuXG5jb25zdCBkZWZhdWx0Q2FsbGJhY2tzID0ge1xuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYmVmb3JlVGl0bGU6IG5vb3AsXG4gIHRpdGxlKHRvb2x0aXBJdGVtcykge1xuICAgIGlmICh0b29sdGlwSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcbiAgICAgIGNvbnN0IGxhYmVscyA9IGl0ZW0uY2hhcnQuZGF0YS5sYWJlbHM7XG4gICAgICBjb25zdCBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0ubGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubGFiZWw7XG4gICAgICB9IGVsc2UgaWYgKGxhYmVsQ291bnQgPiAwICYmIGl0ZW0uZGF0YUluZGV4IDwgbGFiZWxDb3VudCkge1xuICAgICAgICByZXR1cm4gbGFiZWxzW2l0ZW0uZGF0YUluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH0sXG4gIGFmdGVyVGl0bGU6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZUJvZHk6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcbiAgYmVmb3JlTGFiZWw6IG5vb3AsXG4gIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgIHJldHVybiB0b29sdGlwSXRlbS5sYWJlbCArICc6ICcgKyB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZSB8fCB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICB9XG5cbiAgICBsZXQgbGFiZWwgPSB0b29sdGlwSXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuXG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICBsYWJlbCArPSAnOiAnO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIGxhYmVsICs9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWw7XG4gIH0sXG4gIGxhYmVsQ29sb3IodG9vbHRpcEl0ZW0pIHtcbiAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIH07XG4gIH0sXG4gIGxhYmVsVGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm9keUNvbG9yO1xuICB9LFxuICBsYWJlbFBvaW50U3R5bGUodG9vbHRpcEl0ZW0pIHtcbiAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcbiAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuICAgIH07XG4gIH0sXG4gIGFmdGVyTGFiZWw6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGFmdGVyQm9keTogbm9vcCxcblxuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYmVmb3JlRm9vdGVyOiBub29wLFxuICBmb290ZXI6IG5vb3AsXG4gIGFmdGVyRm9vdGVyOiBub29wXG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayBmcm9tIG9iamVjdCB3aXRoIGNvbnRleHQgYW5kIGFyZ3VtZW50cy5cbiAqIElmIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAsIHRoZW4gd2lsbCBiZSBpbnZva2VkIGRlZmF1bHQgY2FsbGJhY2suXG4gKiBAcGFyYW0ge1JlY29yZDxrZXlvZiB0eXBlb2YgZGVmYXVsdENhbGxiYWNrcywgRnVuY3Rpb24+fSBjYWxsYmFja3NcbiAqIEBwYXJhbSB7a2V5b2YgdHlwZW9mIGRlZmF1bHRDYWxsYmFja3N9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gY3R4XG4gKiBAcGFyYW0geyp9IGFyZ1xuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCBuYW1lLCBjdHgsIGFyZykge1xuICBjb25zdCByZXN1bHQgPSBjYWxsYmFja3NbbmFtZV0uY2FsbChjdHgsIGFyZyk7XG5cbiAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRDYWxsYmFja3NbbmFtZV0uY2FsbChjdHgsIGFyZyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgY2xhc3MgVG9vbHRpcCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnNcbiAgICovXG4gIHN0YXRpYyBwb3NpdGlvbmVycyA9IHBvc2l0aW9uZXJzO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wYWNpdHkgPSAwO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IFtdO1xuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpdGxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmVmb3JlQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hZnRlckJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb290ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRZID0gdW5kZWZpbmVkO1xuICAgIC8vIFRPRE86IFY0LCBtYWtlIHRoaXMgcHJpdmF0ZSwgcmVuYW1lIHRvIGBfbGFiZWxTdHlsZXNgLCBhbmQgY29tYmluZSB3aXRoIGBsYWJlbFBvaW50U3R5bGVzYFxuICAgIC8vIGFuZCBgbGFiZWxUZXh0Q29sb3JzYCB0byBjcmVhdGUgYSBzaW5nbGUgdmFyaWFibGVcbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUFuaW1hdGlvbnMoKSB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVkQW5pbWF0aW9ucztcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMuZW5hYmxlZCAmJiBjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKHRoaXMuY2hhcnQsIG9wdHMpO1xuICAgIGlmIChvcHRzLl9jYWNoZWFibGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlVG9vbHRpcENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMsIHRoaXMuX3Rvb2x0aXBJdGVtcykpO1xuICB9XG5cbiAgZ2V0VGl0bGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGJlZm9yZVRpdGxlID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYmVmb3JlVGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcbiAgICBjb25zdCB0aXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ3RpdGxlJywgdGhpcywgY29udGV4dCk7XG4gICAgY29uc3QgYWZ0ZXJUaXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2FmdGVyVGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcblxuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG5cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cblxuICBnZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhcbiAgICAgIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKG9wdGlvbnMuY2FsbGJhY2tzLCAnYmVmb3JlQm9keScsIHRoaXMsIHRvb2x0aXBJdGVtcylcbiAgICApO1xuICB9XG5cbiAgZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUl0ZW1zID0gW107XG5cbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGJvZHlJdGVtID0ge1xuICAgICAgICBiZWZvcmU6IFtdLFxuICAgICAgICBsaW5lczogW10sXG4gICAgICAgIGFmdGVyOiBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2JlZm9yZUxhYmVsJywgdGhpcywgY29udGV4dCkpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWwnLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnYWZ0ZXJMYWJlbCcsIHRoaXMsIGNvbnRleHQpKSk7XG5cbiAgICAgIGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBib2R5SXRlbXM7XG4gIH1cblxuICBnZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKFxuICAgICAgaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2sob3B0aW9ucy5jYWxsYmFja3MsICdhZnRlckJvZHknLCB0aGlzLCB0b29sdGlwSXRlbXMpXG4gICAgKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgZm9vdGVyIGFuZCBiZWZvcmVGb290ZXIgYW5kIGFmdGVyRm9vdGVyIGxpbmVzXG4gIGdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBiZWZvcmVGb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdiZWZvcmVGb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuICAgIGNvbnN0IGZvb3RlciA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2Zvb3RlcicsIHRoaXMsIHRvb2x0aXBJdGVtcyk7XG4gICAgY29uc3QgYWZ0ZXJGb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdhZnRlckZvb3RlcicsIHRoaXMsIHRvb2x0aXBJdGVtcyk7XG5cbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVGb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhmb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlckZvb3RlcikpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY3JlYXRlSXRlbXMob3B0aW9ucykge1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gW107XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlcyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbSh0aGlzLmNoYXJ0LCBhY3RpdmVbaV0pKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIGZpbHRlciBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xuICAgIGlmIChvcHRpb25zLmZpbHRlcikge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBvcHRpb25zLmZpbHRlcihlbGVtZW50LCBpbmRleCwgYXJyYXksIGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIHNvcnRpbmcgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcbiAgICBpZiAob3B0aW9ucy5pdGVtU29ydCkge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoKGEsIGIpID0+IG9wdGlvbnMuaXRlbVNvcnQoYSwgYiwgZGF0YSkpO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBjb2xvcnMgZm9yIGJveGVzXG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhvcHRpb25zLmNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBsYWJlbENvbG9ycy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsQ29sb3InLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFBvaW50U3R5bGVzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxQb2ludFN0eWxlJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxUZXh0Q29sb3JzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxUZXh0Q29sb3InLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gbGFiZWxQb2ludFN0eWxlcztcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB0b29sdGlwSXRlbXM7XG4gICAgcmV0dXJuIHRvb2x0aXBJdGVtcztcbiAgfVxuXG4gIHVwZGF0ZShjaGFuZ2VkLCByZXBsYXkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBsZXQgcHJvcGVydGllcztcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG5cbiAgICBpZiAoIWFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdGhpcy5fY3JlYXRlSXRlbXMob3B0aW9ucyk7XG5cbiAgICAgIHRoaXMudGl0bGUgPSB0aGlzLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJlZm9yZUJvZHkgPSB0aGlzLmdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYm9keSA9IHRoaXMuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5hZnRlckJvZHkgPSB0aGlzLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5mb290ZXIgPSB0aGlzLmdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHNpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMuY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kUG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIHRoaXMuY2hhcnQpO1xuXG4gICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cbiAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHg6IGJhY2tncm91bmRQb2ludC54LFxuICAgICAgICB5OiBiYWNrZ3JvdW5kUG9pbnQueSxcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgIGNhcmV0WDogcG9zaXRpb24ueCxcbiAgICAgICAgY2FyZXRZOiBwb3NpdGlvbi55XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcztcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VkICYmIG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgIG9wdGlvbnMuZXh0ZXJuYWwuY2FsbCh0aGlzLCB7Y2hhcnQ6IHRoaXMuY2hhcnQsIHRvb2x0aXA6IHRoaXMsIHJlcGxheX0pO1xuICAgIH1cbiAgfVxuXG4gIGRyYXdDYXJldCh0b29sdGlwUG9pbnQsIGN0eCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKTtcblxuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngyLCBjYXJldFBvc2l0aW9uLnkyKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xuICB9XG5cbiAgZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7Y2FyZXRTaXplLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgICBjb25zdCB7eDogcHRYLCB5OiBwdFl9ID0gdG9vbHRpcFBvaW50O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNpemU7XG4gICAgbGV0IHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XG5cbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgeTIgPSBwdFkgKyAoaGVpZ2h0IC8gMik7XG5cbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MSA9IHB0WDtcbiAgICAgICAgeDIgPSB4MSAtIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBMZWZ0IGRyYXdzIGJvdHRvbSAtPiB0b3AsIHRoaXMgeTEgaXMgb24gdGhlIGJvdHRvbVxuICAgICAgICB5MSA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDEgPSBwdFggKyB3aWR0aDtcbiAgICAgICAgeDIgPSB4MSArIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBSaWdodCBkcmF3cyB0b3AgLT4gYm90dG9tLCB0aHVzIHkxIGlzIG9uIHRoZSB0b3BcbiAgICAgICAgeTEgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgIH1cblxuICAgICAgeDMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyAoY2FyZXRTaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgd2lkdGggLSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB0aGlzLmNhcmV0WDtcbiAgICAgIH1cblxuICAgICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgeTEgPSBwdFk7XG4gICAgICAgIHkyID0geTEgLSBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gVG9wIGRyYXdzIGxlZnQgLT4gcmlnaHQsIHRodXMgeDEgaXMgb24gdGhlIGxlZnRcbiAgICAgICAgeDEgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkxID0gcHRZICsgaGVpZ2h0O1xuICAgICAgICB5MiA9IHkxICsgY2FyZXRTaXplO1xuXG4gICAgICAgIC8vIEJvdHRvbSBkcmF3cyByaWdodCAtPiBsZWZ0LCB0aHVzIHgxIGlzIG9uIHRoZSByaWdodFxuICAgICAgICB4MSA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgfVxuICAgICAgeTMgPSB5MTtcbiAgICB9XG4gICAgcmV0dXJuIHt4MSwgeDIsIHgzLCB5MSwgeTIsIHkzfTtcbiAgfVxuXG4gIGRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRpdGxlLmxlbmd0aDtcbiAgICBsZXQgdGl0bGVGb250LCB0aXRsZVNwYWNpbmcsIGk7XG5cbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuXG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy50aXRsZUFsaWduLCBvcHRpb25zKTtcblxuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy50aXRsZUFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgICAgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgICAgIHRpdGxlU3BhY2luZyA9IG9wdGlvbnMudGl0bGVTcGFjaW5nO1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy50aXRsZUNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIHRpdGxlRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVNwYWNpbmc7IC8vIExpbmUgSGVpZ2h0IGFuZCBzcGFjaW5nXG5cbiAgICAgICAgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBwdC55ICs9IG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7IC8vIElmIExhc3QsIGFkZCBtYXJnaW4sIHJlbW92ZSBzcGFjaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGFiZWxDb2xvciA9IHRoaXMubGFiZWxDb2xvcnNbaV07XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlID0gdGhpcy5sYWJlbFBvaW50U3R5bGVzW2ldO1xuICAgIGNvbnN0IHtib3hIZWlnaHQsIGJveFdpZHRofSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgY29uc3QgY29sb3JYID0gZ2V0QWxpZ25lZFgodGhpcywgJ2xlZnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBydGxDb2xvclggPSBydGxIZWxwZXIueChjb2xvclgpO1xuICAgIGNvbnN0IHlPZmZTZXQgPSBib3hIZWlnaHQgPCBib2R5Rm9udC5saW5lSGVpZ2h0ID8gKGJvZHlGb250LmxpbmVIZWlnaHQgLSBib3hIZWlnaHQpIC8gMiA6IDA7XG4gICAgY29uc3QgY29sb3JZID0gcHQueSArIHlPZmZTZXQ7XG5cbiAgICBpZiAob3B0aW9ucy51c2VQb2ludFN0eWxlKSB7XG4gICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgcmFkaXVzOiBNYXRoLm1pbihib3hXaWR0aCwgYm94SGVpZ2h0KSAvIDIsIC8vIGZpdCB0aGUgY2lyY2xlIGluIHRoZSBib3hcbiAgICAgICAgcG9pbnRTdHlsZTogbGFiZWxQb2ludFN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgIHJvdGF0aW9uOiBsYWJlbFBvaW50U3R5bGUucm90YXRpb24sXG4gICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICB9O1xuICAgICAgLy8gUmVjYWxjdWxhdGUgeCBhbmQgeSBmb3IgZHJhd1BvaW50KCkgYmVjYXVzZSBpdHMgZXhwZWN0aW5nXG4gICAgICAvLyB4IGFuZCB5IHRvIGJlIGNlbnRlciBvZiBmaWd1cmUgKGluc3RlYWQgb2YgdG9wIGxlZnQpXG4gICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCkgKyBib3hXaWR0aCAvIDI7XG4gICAgICBjb25zdCBjZW50ZXJZID0gY29sb3JZICsgYm94SGVpZ2h0IC8gMjtcblxuICAgICAgLy8gRmlsbCB0aGUgcG9pbnQgd2l0aCB3aGl0ZSBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG5cbiAgICAgIC8vIERyYXcgdGhlIHBvaW50XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9yLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3IuYmFja2dyb3VuZENvbG9yO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3JkZXJcbiAgICAgIGN0eC5saW5lV2lkdGggPSBpc09iamVjdChsYWJlbENvbG9yLmJvcmRlcldpZHRoKSA/IE1hdGgubWF4KC4uLk9iamVjdC52YWx1ZXMobGFiZWxDb2xvci5ib3JkZXJXaWR0aCkpIDogKGxhYmVsQ29sb3IuYm9yZGVyV2lkdGggfHwgMSk7IC8vIFRPRE8sIHY0IHJlbW92ZSBmYWxsYmFja1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvci5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChsYWJlbENvbG9yLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGFiZWxDb2xvci5ib3JkZXJEYXNoT2Zmc2V0IHx8IDA7XG5cbiAgICAgIC8vIEZpbGwgYSB3aGl0ZSByZWN0IHNvIHRoYXQgY29sb3VycyBtZXJnZSBuaWNlbHkgaWYgdGhlIG9wYWNpdHkgaXMgPCAxXG4gICAgICBjb25zdCBvdXRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoKTtcbiAgICAgIGNvbnN0IGlubmVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54UGx1cyhydGxDb2xvclgsIDEpLCBib3hXaWR0aCAtIDIpO1xuICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsYWJlbENvbG9yLmJvcmRlclJhZGl1cyk7XG5cbiAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogb3V0ZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSxcbiAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgLy8gSW5uZXIgc3F1YXJlXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogaW5uZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSArIDEsXG4gICAgICAgICAgdzogYm94V2lkdGggLSAyLFxuICAgICAgICAgIGg6IGJveEhlaWdodCAtIDIsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9ybWFsIHJlY3RcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBjdHguZmlsbFJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICBjdHguc3Ryb2tlUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIC8vIElubmVyIHNxdWFyZVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChpbm5lclgsIGNvbG9yWSArIDEsIGJveFdpZHRoIC0gMiwgYm94SGVpZ2h0IC0gMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVzdG9yZSBmaWxsU3R5bGVcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gIH1cblxuICBkcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2JvZHl9ID0gdGhpcztcbiAgICBjb25zdCB7Ym9keVNwYWNpbmcsIGJvZHlBbGlnbiwgZGlzcGxheUNvbG9ycywgYm94SGVpZ2h0LCBib3hXaWR0aCwgYm94UGFkZGluZ30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGxldCBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgbGV0IHhMaW5lUGFkZGluZyA9IDA7XG5cbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuXG4gICAgY29uc3QgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBjdHguZmlsbFRleHQobGluZSwgcnRsSGVscGVyLngocHQueCArIHhMaW5lUGFkZGluZyksIHB0LnkgKyBib2R5TGluZUhlaWdodCAvIDIpO1xuICAgICAgcHQueSArPSBib2R5TGluZUhlaWdodCArIGJvZHlTcGFjaW5nO1xuICAgIH07XG5cbiAgICBjb25zdCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oYm9keUFsaWduKTtcbiAgICBsZXQgYm9keUl0ZW0sIHRleHRDb2xvciwgbGluZXMsIGksIGosIGlsZW4sIGpsZW47XG5cbiAgICBjdHgudGV4dEFsaWduID0gYm9keUFsaWduO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcblxuICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiwgb3B0aW9ucyk7XG5cbiAgICAvLyBCZWZvcmUgYm9keSBsaW5lc1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJvZHlDb2xvcjtcbiAgICBlYWNoKHRoaXMuYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuXG4gICAgeExpbmVQYWRkaW5nID0gZGlzcGxheUNvbG9ycyAmJiBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiAhPT0gJ3JpZ2h0J1xuICAgICAgPyBib2R5QWxpZ24gPT09ICdjZW50ZXInID8gKGJveFdpZHRoIC8gMiArIGJveFBhZGRpbmcpIDogKGJveFdpZHRoICsgMiArIGJveFBhZGRpbmcpXG4gICAgICA6IDA7XG5cbiAgICAvLyBEcmF3IGJvZHkgbGluZXMgbm93XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGJvZHkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBib2R5SXRlbSA9IGJvZHlbaV07XG4gICAgICB0ZXh0Q29sb3IgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcbiAgICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBmaWxsTGluZU9mVGV4dCk7XG5cbiAgICAgIGxpbmVzID0gYm9keUl0ZW0ubGluZXM7XG4gICAgICAvLyBEcmF3IExlZ2VuZC1saWtlIGJveGVzIGlmIG5lZWRlZFxuICAgICAgaWYgKGRpc3BsYXlDb2xvcnMgJiYgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IE1hdGgubWF4KGJvZHlGb250LmxpbmVIZWlnaHQsIGJveEhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsaW5lcy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgZmlsbExpbmVPZlRleHQobGluZXNbal0pO1xuICAgICAgICAvLyBSZXNldCBmb3IgYW55IGxpbmVzIHRoYXQgZG9uJ3QgaW5jbHVkZSBjb2xvcmJveFxuICAgICAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBiYWNrIHRvIDAgZm9yIGFmdGVyIGJvZHlcbiAgICB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcblxuICAgIC8vIEFmdGVyIGJvZHkgbGluZXNcbiAgICBlYWNoKHRoaXMuYWZ0ZXJCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgcHQueSAtPSBib2R5U3BhY2luZzsgLy8gUmVtb3ZlIGxhc3QgYm9keSBzcGFjaW5nXG4gIH1cblxuICBkcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb290ZXIgPSB0aGlzLmZvb3RlcjtcbiAgICBjb25zdCBsZW5ndGggPSBmb290ZXIubGVuZ3RoO1xuICAgIGxldCBmb290ZXJGb250LCBpO1xuXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMuZm9vdGVyQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgcHQueSArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcDtcblxuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy5mb290ZXJBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICAgIGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZm9vdGVyQ29sb3I7XG4gICAgICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGZvb3RlcltpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyBmb290ZXJGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSBmb290ZXJGb250LmxpbmVIZWlnaHQgKyBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7eCwgeX0gPSBwdDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0b29sdGlwU2l6ZTtcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMob3B0aW9ucy5jb3JuZXJSYWRpdXMpO1xuXG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgdG9wTGVmdCwgeSk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSB0b3BSaWdodCwgeSk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyB0b3BSaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gYm90dG9tUmlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gYm90dG9tUmlnaHQsIHkgKyBoZWlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIGJvdHRvbUxlZnQsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSBib3R0b21MZWZ0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHgsIHkgKyB0b3BMZWZ0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgdG9wTGVmdCwgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgY3R4LmZpbGwoKTtcblxuICAgIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGUgeC95IGFuaW1hdGlvbiB0YXJnZXRzIHdoZW4gX2FjdGl2ZSBlbGVtZW50cyBhcmUgYW5pbWF0aW5nIHRvb1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltWCA9IGFuaW1zICYmIGFuaW1zLng7XG4gICAgY29uc3QgYW5pbVkgPSBhbmltcyAmJiBhbmltcy55O1xuICAgIGlmIChhbmltWCB8fCBhbmltWSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIHRoaXMuX2FjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgdGhpcy5fc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBwb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgY2hhcnQpO1xuICAgICAgaWYgKGFuaW1YLl90byAhPT0gcG9pbnQueCB8fCBhbmltWS5fdG8gIT09IHBvaW50LnkpIHtcbiAgICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICAgIHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhcmV0WCA9IHBvc2l0aW9uLng7XG4gICAgICAgIHRoaXMuY2FyZXRZID0gcG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcG9pbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHRvb2x0aXAgd2lsbCBkcmF3IGFueXRoaW5nXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0b29sdGlwIHdpbGwgcmVuZGVyXG4gICAqL1xuICBfd2lsbFJlbmRlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLm9wYWNpdHk7XG4gIH1cblxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgbGV0IG9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICBpZiAoIW9wYWNpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucyk7XG5cbiAgICBjb25zdCB0b29sdGlwU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcHQgPSB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnlcbiAgICB9O1xuXG4gICAgLy8gSUUxMS9FZGdlIGRvZXMgbm90IGxpa2UgdmVyeSBzbWFsbCBvcGFjaXRpZXMsIHNvIHNuYXAgdG8gMFxuICAgIG9wYWNpdHkgPSBNYXRoLmFicyhvcGFjaXR5KSA8IDFlLTMgPyAwIDogb3BhY2l0eTtcblxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcblxuICAgIC8vIFRydXRoeS9mYWxzZXkgdmFsdWUgZm9yIGVtcHR5IHRvb2x0aXBcbiAgICBjb25zdCBoYXNUb29sdGlwQ29udGVudCA9IHRoaXMudGl0bGUubGVuZ3RoIHx8IHRoaXMuYmVmb3JlQm9keS5sZW5ndGggfHwgdGhpcy5ib2R5Lmxlbmd0aCB8fCB0aGlzLmFmdGVyQm9keS5sZW5ndGggfHwgdGhpcy5mb290ZXIubGVuZ3RoO1xuXG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAmJiBoYXNUb29sdGlwQ29udGVudCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG5cbiAgICAgIC8vIERyYXcgQmFja2dyb3VuZFxuICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG5cbiAgICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG5cbiAgICAgIHB0LnkgKz0gcGFkZGluZy50b3A7XG5cbiAgICAgIC8vIFRpdGxlc1xuICAgICAgdGhpcy5kcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIEJvZHlcbiAgICAgIHRoaXMuZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIEZvb3RlclxuICAgICAgdGhpcy5kcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEdldCBhY3RpdmUgZWxlbWVudHMgaW4gdGhlIHRvb2x0aXBcblx0ICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSBhY3RpdmUgaW4gdGhlIHRvb2x0aXBcblx0ICovXG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cblxuICAvKipcblx0ICogU2V0IGFjdGl2ZSBlbGVtZW50cyBpbiB0aGUgdG9vbHRpcFxuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmVFbGVtZW50cyBBcnJheSBvZiBhY3RpdmUgZGF0YXNldEluZGV4L2luZGV4IHBhaXJzLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRQb3NpdGlvbiBTeW50aGV0aWMgZXZlbnQgcG9zaXRpb24gdXNlZCBpbiBwb3NpdGlvbmluZ1xuXHQgKi9cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBhIGRhdGFzZXQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBldmVudFBvc2l0aW9uKTtcblxuICAgIGlmIChjaGFuZ2VkIHx8IHBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IGV2ZW50UG9zaXRpb247XG4gICAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcGxheV0gLSBUaGlzIGlzIGEgcmVwbGF5ZWQgZXZlbnQgKGZyb20gdXBkYXRlKVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSBUaGUgZXZlbnQgaXMgaW5zaWRlIGNoYXJ0QXJlYVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdG9vbHRpcCBjaGFuZ2VkXG5cdCAqL1xuICBoYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhID0gdHJ1ZSkge1xuICAgIGlmIChyZXBsYXkgJiYgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaXRlbXMgc2hvd24sIGJ1dCB0aGUgdG9vbHRpcCBwb3NpdGlvbiBpcyBuZWFyZXN0IG1vZGVcbiAgICAvLyBhbiB1cGRhdGUgbWF5IG5lZWQgdG8gYmUgbWFkZSBiZWNhdXNlIG91ciBwb3NpdGlvbiBtYXkgaGF2ZSBjaGFuZ2VkIGV2ZW4gdGhvdWdoXG4gICAgLy8gdGhlIGl0ZW1zIGFyZSB0aGUgc2FtZSBhcyBiZWZvcmUuXG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSk7XG5cbiAgICAvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcbiAgICBjb25zdCBjaGFuZ2VkID0gcmVwbGF5IHx8ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpIHx8IHBvc2l0aW9uQ2hhbmdlZDtcblxuICAgIC8vIE9ubHkgaGFuZGxlIHRhcmdldCBldmVudCBvbiB0b29sdGlwIGNoYW5nZVxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG5cbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IGUueCxcbiAgICAgICAgICB5OiBlLnlcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlLCByZXBsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEhlbHBlciBmb3IgZGV0ZXJtaW5pbmcgdGhlIGFjdGl2ZSBlbGVtZW50cyBmb3IgZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uSXRlbVtdfSBsYXN0QWN0aXZlIC0gUHJldmlvdXNseSBhY3RpdmUgZWxlbWVudHNcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVwbGF5XSAtIFRoaXMgaXMgYSByZXBsYXllZCBldmVudCAoZnJvbSB1cGRhdGUpXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luQ2hhcnRBcmVhXSAtIFRoZSBldmVudCBpcyBpbnNpZGUgY2hhcnRBcmVhXG5cdCAqIEByZXR1cm5zIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBBY3RpdmUgZWxlbWVudHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICAvLyBMZXQgdXNlciBjb250cm9sIHRoZSBhY3RpdmUgZWxlbWVudHMgb3V0c2lkZSBjaGFydEFyZWEuIEVnLiB1c2luZyBMZWdlbmQuXG4gICAgICAvLyBCdXQgbWFrZSBzdXJlIHRoYXQgYWN0aXZlIGVsZW1lbnRzIGFyZSBzdGlsbCB2YWxpZC5cbiAgICAgIHJldHVybiBsYXN0QWN0aXZlLmZpbHRlcihpID0+XG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tpLmRhdGFzZXRJbmRleF0gJiZcbiAgICAgICAgdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpLmRhdGFzZXRJbmRleCkuY29udHJvbGxlci5nZXRQYXJzZWQoaS5pbmRleCkgIT09IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIEFjdGl2ZSBFbGVtZW50cyBmb3IgdG9vbHRpcHNcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmNoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgb3B0aW9ucy5tb2RlLCBvcHRpb25zLCByZXBsYXkpO1xuXG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aXZlO1xuICB9XG5cbiAgLyoqXG5cdCAqIERldGVybWluZSBpZiB0aGUgYWN0aXZlIGVsZW1lbnRzICsgZXZlbnQgY29tYmluYXRpb24gY2hhbmdlcyB0aGVcblx0ICogdG9vbHRpcCBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmUgLSBBY3RpdmUgZWxlbWVudHNcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gRXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIHBvc2l0aW9uIGNoYW5nZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcG9zaXRpb24gaGFzIGNoYW5nZWRcblx0ICovXG4gIF9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKSB7XG4gICAgY29uc3Qge2NhcmV0WCwgY2FyZXRZLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgZSk7XG4gICAgcmV0dXJuIHBvc2l0aW9uICE9PSBmYWxzZSAmJiAoY2FyZXRYICE9PSBwb3NpdGlvbi54IHx8IGNhcmV0WSAhPT0gcG9zaXRpb24ueSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ3Rvb2x0aXAnLFxuICBfZWxlbWVudDogVG9vbHRpcCxcbiAgcG9zaXRpb25lcnMsXG5cbiAgYWZ0ZXJJbml0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjaGFydC50b29sdGlwID0gbmV3IFRvb2x0aXAoe2NoYXJ0LCBvcHRpb25zfSk7XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICByZXNldChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICBhZnRlckRyYXcoY2hhcnQpIHtcbiAgICBjb25zdCB0b29sdGlwID0gY2hhcnQudG9vbHRpcDtcblxuICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAuX3dpbGxSZW5kZXIoKSkge1xuICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgdG9vbHRpcFxuICAgICAgfTtcblxuICAgICAgaWYgKGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVRvb2x0aXBEcmF3Jywgey4uLmFyZ3MsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b29sdGlwLmRyYXcoY2hhcnQuY3R4KTtcblxuICAgICAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJUb29sdGlwRHJhdycsIGFyZ3MpO1xuICAgIH1cbiAgfSxcblxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIC8vIElmIHRoZSBldmVudCBpcyByZXBsYXllZCBmcm9tIGB1cGRhdGVgLCB3ZSBzaG91bGQgZXZhbHVhdGUgd2l0aCB0aGUgZmluYWwgcG9zaXRpb25zLlxuICAgICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IGFyZ3MucmVwbGF5O1xuICAgICAgaWYgKGNoYXJ0LnRvb2x0aXAuaGFuZGxlRXZlbnQoYXJncy5ldmVudCwgdXNlRmluYWxQb3NpdGlvbiwgYXJncy5pbkNoYXJ0QXJlYSkpIHtcbiAgICAgICAgLy8gbm90aWZ5IGNoYXJ0IGFib3V0IHRoZSBjaGFuZ2UsIHNvIGl0IHdpbGwgcmVuZGVyXG4gICAgICAgIGFyZ3MuY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBleHRlcm5hbDogbnVsbCxcbiAgICBwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgdGl0bGVDb2xvcjogJyNmZmYnLFxuICAgIHRpdGxlRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICB0aXRsZVNwYWNpbmc6IDIsXG4gICAgdGl0bGVNYXJnaW5Cb3R0b206IDYsXG4gICAgdGl0bGVBbGlnbjogJ2xlZnQnLFxuICAgIGJvZHlDb2xvcjogJyNmZmYnLFxuICAgIGJvZHlTcGFjaW5nOiAyLFxuICAgIGJvZHlGb250OiB7XG4gICAgfSxcbiAgICBib2R5QWxpZ246ICdsZWZ0JyxcbiAgICBmb290ZXJDb2xvcjogJyNmZmYnLFxuICAgIGZvb3RlclNwYWNpbmc6IDIsXG4gICAgZm9vdGVyTWFyZ2luVG9wOiA2LFxuICAgIGZvb3RlckZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZm9vdGVyQWxpZ246ICdsZWZ0JyxcbiAgICBwYWRkaW5nOiA2LFxuICAgIGNhcmV0UGFkZGluZzogMixcbiAgICBjYXJldFNpemU6IDUsXG4gICAgY29ybmVyUmFkaXVzOiA2LFxuICAgIGJveEhlaWdodDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIGJveFdpZHRoOiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgbXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgZGlzcGxheUNvbG9yczogdHJ1ZSxcbiAgICBib3hQYWRkaW5nOiAwLFxuICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwLFxuICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcsICdjYXJldFgnLCAnY2FyZXRZJ10sXG4gICAgICB9LFxuICAgICAgb3BhY2l0eToge1xuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICB9XG4gICAgfSxcbiAgICBjYWxsYmFja3M6IGRlZmF1bHRDYWxsYmFja3NcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgYm9keUZvbnQ6ICdmb250JyxcbiAgICBmb290ZXJGb250OiAnZm9udCcsXG4gICAgdGl0bGVGb250OiAnZm9udCdcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSAhPT0gJ2l0ZW1Tb3J0JyAmJiBuYW1lICE9PSAnZXh0ZXJuYWwnLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIF9mYWxsYmFjazogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbidcbiAgICB9XG4gIH0sXG5cbiAgLy8gUmVzb2x2ZSBhZGRpdGlvbmFsbHkgZnJvbSBgaW50ZXJhY3Rpb25gIG9wdGlvbnMgYW5kIGRlZmF1bHRzLlxuICBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzOiBbJ2ludGVyYWN0aW9uJ11cbn07XG4iLCAiaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0LCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmNvbnN0IGFkZElmU3RyaW5nID0gKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpID0+IHtcbiAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgaW5kZXggPSBsYWJlbHMucHVzaChyYXcpIC0gMTtcbiAgICBhZGRlZExhYmVscy51bnNoaWZ0KHtpbmRleCwgbGFiZWw6IHJhd30pO1xuICB9IGVsc2UgaWYgKGlzTmFOKHJhdykpIHtcbiAgICBpbmRleCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufTtcblxuZnVuY3Rpb24gZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykge1xuICBjb25zdCBmaXJzdCA9IGxhYmVscy5pbmRleE9mKHJhdyk7XG4gIGlmIChmaXJzdCA9PT0gLTEpIHtcbiAgICByZXR1cm4gYWRkSWZTdHJpbmcobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscyk7XG4gIH1cbiAgY29uc3QgbGFzdCA9IGxhYmVscy5sYXN0SW5kZXhPZihyYXcpO1xuICByZXR1cm4gZmlyc3QgIT09IGxhc3QgPyBpbmRleCA6IGZpcnN0O1xufVxuXG5jb25zdCB2YWxpZEluZGV4ID0gKGluZGV4LCBtYXgpID0+IGluZGV4ID09PSBudWxsID8gbnVsbCA6IF9saW1pdFZhbHVlKE1hdGgucm91bmQoaW5kZXgpLCAwLCBtYXgpO1xuXG5mdW5jdGlvbiBfZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuXG4gIGlmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDwgbGFiZWxzLmxlbmd0aCkge1xuICAgIHJldHVybiBsYWJlbHNbdmFsdWVdO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2F0ZWdvcnlTY2FsZSBleHRlbmRzIFNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAnY2F0ZWdvcnknO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIHRpY2tzOiB7XG4gICAgICBjYWxsYmFjazogX2dldExhYmVsRm9yVmFsdWVcbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgfVxuXG4gIGluaXQoc2NhbGVPcHRpb25zKSB7XG4gICAgY29uc3QgYWRkZWQgPSB0aGlzLl9hZGRlZExhYmVscztcbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgICAgZm9yIChjb25zdCB7aW5kZXgsIGxhYmVsfSBvZiBhZGRlZCkge1xuICAgICAgICBpZiAobGFiZWxzW2luZGV4XSA9PT0gbGFiZWwpIHtcbiAgICAgICAgICBsYWJlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgICB9XG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdGlvbnMpO1xuICB9XG5cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGluZGV4ID0gaXNGaW5pdGUoaW5kZXgpICYmIGxhYmVsc1tpbmRleF0gPT09IHJhdyA/IGluZGV4XG4gICAgICA6IGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCB2YWx1ZU9yRGVmYXVsdChpbmRleCwgcmF3KSwgdGhpcy5fYWRkZWRMYWJlbHMpO1xuICAgIHJldHVybiB2YWxpZEluZGV4KGluZGV4LCBsYWJlbHMubGVuZ3RoIC0gMSk7XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gdGhpcy5nZXRMYWJlbHMoKS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG5cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9wdGlvbnMub2Zmc2V0O1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgbGV0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG5cbiAgICAvLyBJZiB3ZSBhcmUgdmlld2luZyBzb21lIHN1YnNldCBvZiBsYWJlbHMsIHNsaWNlIHRoZSBvcmlnaW5hbCBhcnJheVxuICAgIGxhYmVscyA9IChtaW4gPT09IDAgJiYgbWF4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWluLCBtYXggKyAxKTtcblxuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBNYXRoLm1heChsYWJlbHMubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSwgMSk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMubWluIC0gKG9mZnNldCA/IDAuNSA6IDApO1xuXG4gICAgZm9yIChsZXQgdmFsdWUgPSBtaW47IHZhbHVlIDw9IG1heDsgdmFsdWUrKykge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWV9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBfZ2V0TGFiZWxGb3JWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG5cbiAgICBpZiAoIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB2ZXJ0aWNhbCBjYXRlZ29yeSBzY2FsZSByZXZlcnNlIGlzIGludmVydGVkLlxuICAgICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9ICF0aGlzLl9yZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZWQgdG8gZ2V0IGRhdGEgdmFsdWUgbG9jYXRpb25zLiBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgLy8gTXVzdCBvdmVycmlkZSBiYXNlIGltcGxlbWVudGF0aW9uIGJlY2F1c2UgaXQgY2FsbHMgZ2V0UGl4ZWxGb3JWYWx1ZVxuICAvLyBhbmQgY2F0ZWdvcnkgc2NhbGUgY2FuIGhhdmUgZHVwbGljYXRlIHZhbHVlc1xuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cblxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmJvdHRvbTtcbiAgfVxufVxuIiwgImltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHthbG1vc3RFcXVhbHMsIGFsbW9zdFdob2xlLCBuaWNlTnVtLCBfZGVjaW1hbFBsYWNlcywgX3NldE1pbkFuZE1heEJ5S2V5LCBzaWduLCB0b1JhZGlhbnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCBTY2FsZSBmcm9tICcuLi9jb3JlL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsaW5lYXIgdGlja3MgZm9yIGFuIGF4aXNcbiAqIDEuIElmIGdlbmVyYXRpb25PcHRpb25zLm1pbiwgZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCBhbmQgZ2VuZXJhdGlvbk9wdGlvbnMuc3RlcCBhcmUgZGVmaW5lZDpcbiAqICAgIGlmIChtYXggLSBtaW4pIC8gc3RlcCBpcyBhbiBpbnRlZ2VyLCB0aWNrcyBhcmUgZ2VuZXJhdGVkIGFzIFttaW4sIG1pbiArIHN0ZXAsIC4uLiwgbWF4XVxuICogICAgTm90ZSB0aGF0IHRoZSBnZW5lcmF0aW9uT3B0aW9ucy5tYXhDb3VudCBzZXR0aW5nIGlzIHJlc3BlY3RlZCBpbiB0aGlzIHNjZW5hcmlvXG4gKlxuICogMi4gSWYgZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIGFuZCBnZW5lcmF0aW9uT3B0aW9ucy5jb3VudCBpcyBkZWZpbmVkXG4gKiAgICBzcGFjaW5nID0gKG1heCAtIG1pbikgLyBjb3VudFxuICogICAgVGlja3MgYXJlIGdlbmVyYXRlZCBhcyBbbWluLCBtaW4gKyBzcGFjaW5nLCAuLi4sIG1heF1cbiAqXG4gKiAzLiBJZiBnZW5lcmF0aW9uT3B0aW9ucy5jb3VudCBpcyBkZWZpbmVkXG4gKiAgICBzcGFjaW5nID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIGNvdW50XG4gKlxuICogNC4gQ29tcHV0ZSBvcHRpbWFsIHNwYWNpbmcgb2YgdGlja3MgdXNpbmcgbmljZU51bSBhbGdvcml0aG1cbiAqXG4gKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGlja3NcbiAqIEBwYXJhbSBkYXRhUmFuZ2UgdGhlIHJhbmdlIG9mIHRoZSBkYXRhXG4gKiBAcmV0dXJucyB7b2JqZWN0W119IGFycmF5IG9mIHRpY2sgb2JqZWN0c1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgLy8gVG8gZ2V0IGEgXCJuaWNlXCIgdmFsdWUgZm9yIHRoZSB0aWNrIHNwYWNpbmcsIHdlIHdpbGwgdXNlIHRoZSBhcHByb3ByaWF0ZWx5IG5hbWVkXG4gIC8vIFwibmljZSBudW1iZXJcIiBhbGdvcml0aG0uIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NTA2ODgxL25pY2UtbGFiZWwtYWxnb3JpdGhtLWZvci1jaGFydHMtd2l0aC1taW5pbXVtLXRpY2tzXG4gIC8vIGZvciBkZXRhaWxzLlxuXG4gIGNvbnN0IE1JTl9TUEFDSU5HID0gMWUtMTQ7XG4gIGNvbnN0IHtib3VuZHMsIHN0ZXAsIG1pbiwgbWF4LCBwcmVjaXNpb24sIGNvdW50LCBtYXhUaWNrcywgbWF4RGlnaXRzLCBpbmNsdWRlQm91bmRzfSA9IGdlbmVyYXRpb25PcHRpb25zO1xuICBjb25zdCB1bml0ID0gc3RlcCB8fCAxO1xuICBjb25zdCBtYXhTcGFjZXMgPSBtYXhUaWNrcyAtIDE7XG4gIGNvbnN0IHttaW46IHJtaW4sIG1heDogcm1heH0gPSBkYXRhUmFuZ2U7XG4gIGNvbnN0IG1pbkRlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtaW4pO1xuICBjb25zdCBtYXhEZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWF4KTtcbiAgY29uc3QgY291bnREZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYoY291bnQpO1xuICBjb25zdCBtaW5TcGFjaW5nID0gKHJtYXggLSBybWluKSAvIChtYXhEaWdpdHMgKyAxKTtcbiAgbGV0IHNwYWNpbmcgPSBuaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIGxldCBmYWN0b3IsIG5pY2VNaW4sIG5pY2VNYXgsIG51bVNwYWNlcztcblxuICAvLyBCZXlvbmQgTUlOX1NQQUNJTkcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyBiZWluZyB0byBsb3NlIHByZWNpc2lvblxuICAvLyBzdWNoIHRoYXQgd2UgY2FuJ3QgZG8gdGhlIG1hdGggbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIHRpY2tzXG4gIGlmIChzcGFjaW5nIDwgTUlOX1NQQUNJTkcgJiYgIW1pbkRlZmluZWQgJiYgIW1heERlZmluZWQpIHtcbiAgICByZXR1cm4gW3t2YWx1ZTogcm1pbn0sIHt2YWx1ZTogcm1heH1dO1xuICB9XG5cbiAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAtIE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpO1xuICBpZiAobnVtU3BhY2VzID4gbWF4U3BhY2VzKSB7XG4gICAgLy8gSWYgdGhlIGNhbGN1bGF0ZWQgbnVtIG9mIHNwYWNlcyBleGNlZWRzIG1heE51bVNwYWNlcywgcmVjYWxjdWxhdGUgaXRcbiAgICBzcGFjaW5nID0gbmljZU51bShudW1TcGFjZXMgKiBzcGFjaW5nIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICB9XG5cbiAgaWYgKCFpc051bGxPclVuZGVmKHByZWNpc2lvbikpIHtcbiAgICAvLyBJZiB0aGUgdXNlciBzcGVjaWZpZWQgYSBwcmVjaXNpb24sIHJvdW5kIHRvIHRoYXQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gICAgZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgfVxuXG4gIGlmIChib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICBuaWNlTWluID0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICAgIG5pY2VNYXggPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgfSBlbHNlIHtcbiAgICBuaWNlTWluID0gcm1pbjtcbiAgICBuaWNlTWF4ID0gcm1heDtcbiAgfVxuXG4gIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQgJiYgc3RlcCAmJiBhbG1vc3RXaG9sZSgobWF4IC0gbWluKSAvIHN0ZXAsIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgIC8vIENhc2UgMTogSWYgbWluLCBtYXggYW5kIHN0ZXBTaXplIGFyZSBzZXQgYW5kIHRoZXkgbWFrZSBhbiBldmVubHkgc3BhY2VkIHNjYWxlIHVzZSBpdC5cbiAgICAvLyBzcGFjaW5nID0gc3RlcDtcbiAgICAvLyBudW1TcGFjZXMgPSAobWF4IC0gbWluKSAvIHNwYWNpbmc7XG4gICAgLy8gTm90ZSB0aGF0IHdlIHJvdW5kIGhlcmUgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGFsbW9zdFdob2xlIHRyYW5zbGF0ZWQgYW4gRlAgZXJyb3JcbiAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKE1hdGgubWluKChtYXggLSBtaW4pIC8gc3BhY2luZywgbWF4VGlja3MpKTtcbiAgICBzcGFjaW5nID0gKG1heCAtIG1pbikgLyBudW1TcGFjZXM7XG4gICAgbmljZU1pbiA9IG1pbjtcbiAgICBuaWNlTWF4ID0gbWF4O1xuICB9IGVsc2UgaWYgKGNvdW50RGVmaW5lZCkge1xuICAgIC8vIENhc2VzIDIgJiAzLCB3ZSBoYXZlIGEgY291bnQgc3BlY2lmaWVkLiBIYW5kbGUgb3B0aW9uYWwgdXNlciBkZWZpbmVkIGVkZ2VzIHRvIHRoZSByYW5nZS5cbiAgICAvLyBTb21ldGltZXMgdGhlc2UgYXJlIG5vLW9wcywgYnV0IGl0IG1ha2VzIHRoZSBjb2RlIGEgbG90IGNsZWFyZXJcbiAgICAvLyBhbmQgd2hlbiBhIHVzZXIgZGVmaW5lZCByYW5nZSBpcyBzcGVjaWZpZWQsIHdlIHdhbnQgdGhlIGNvcnJlY3QgdGlja3NcbiAgICBuaWNlTWluID0gbWluRGVmaW5lZCA/IG1pbiA6IG5pY2VNaW47XG4gICAgbmljZU1heCA9IG1heERlZmluZWQgPyBtYXggOiBuaWNlTWF4O1xuICAgIG51bVNwYWNlcyA9IGNvdW50IC0gMTtcbiAgICBzcGFjaW5nID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIG51bVNwYWNlcztcbiAgfSBlbHNlIHtcbiAgICAvLyBDYXNlIDRcbiAgICBudW1TcGFjZXMgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gc3BhY2luZztcblxuICAgIC8vIElmIHZlcnkgY2xvc2UgdG8gb3VyIHJvdW5kZWQgdmFsdWUsIHVzZSBpdC5cbiAgICBpZiAoYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQobnVtU3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKG51bVNwYWNlcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhlIHNwYWNpbmcgd2lsbCBoYXZlIGNoYW5nZWQgaW4gY2FzZXMgMSwgMiwgYW5kIDMgc28gdGhlIGZhY3RvciBjYW5ub3QgYmUgY29tcHV0ZWRcbiAgLy8gdW50aWwgdGhpcyBwb2ludFxuICBjb25zdCBkZWNpbWFsUGxhY2VzID0gTWF0aC5tYXgoXG4gICAgX2RlY2ltYWxQbGFjZXMoc3BhY2luZyksXG4gICAgX2RlY2ltYWxQbGFjZXMobmljZU1pbilcbiAgKTtcbiAgZmFjdG9yID0gTWF0aC5wb3coMTAsIGlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSA/IGRlY2ltYWxQbGFjZXMgOiBwcmVjaXNpb24pO1xuICBuaWNlTWluID0gTWF0aC5yb3VuZChuaWNlTWluICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgbmljZU1heCA9IE1hdGgucm91bmQobmljZU1heCAqIGZhY3RvcikgLyBmYWN0b3I7XG5cbiAgbGV0IGogPSAwO1xuICBpZiAobWluRGVmaW5lZCkge1xuICAgIGlmIChpbmNsdWRlQm91bmRzICYmIG5pY2VNaW4gIT09IG1pbikge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1pbn0pO1xuXG4gICAgICBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgICBqKys7IC8vIFNraXAgbmljZU1pblxuICAgICAgfVxuICAgICAgLy8gSWYgdGhlIG5leHQgbmljZSB0aWNrIGlzIGNsb3NlIHRvIG1pbiwgc2tpcCBpdFxuICAgICAgaWYgKGFsbW9zdEVxdWFscyhNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3RvciwgbWluLCByZWxhdGl2ZUxhYmVsU2l6ZShtaW4sIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgaisrO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbnVtU3BhY2VzOyArK2opIHtcbiAgICBjb25zdCB0aWNrVmFsdWUgPSBNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICBpZiAobWF4RGVmaW5lZCAmJiB0aWNrVmFsdWUgPiBtYXgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogdGlja1ZhbHVlfSk7XG4gIH1cblxuICBpZiAobWF4RGVmaW5lZCAmJiBpbmNsdWRlQm91bmRzICYmIG5pY2VNYXggIT09IG1heCkge1xuICAgIC8vIElmIHRoZSBwcmV2aW91cyB0aWNrIGlzIHRvbyBjbG9zZSB0byBtYXgsIHJlcGxhY2UgaXQgd2l0aCBtYXgsIGVsc2UgYWRkIG1heFxuICAgIGlmICh0aWNrcy5sZW5ndGggJiYgYWxtb3N0RXF1YWxzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlLCBtYXgsIHJlbGF0aXZlTGFiZWxTaXplKG1heCwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUgPSBtYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtYXh9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIW1heERlZmluZWQgfHwgbmljZU1heCA9PT0gbWF4KSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IG5pY2VNYXh9KTtcbiAgfVxuXG4gIHJldHVybiB0aWNrcztcbn1cblxuZnVuY3Rpb24gcmVsYXRpdmVMYWJlbFNpemUodmFsdWUsIG1pblNwYWNpbmcsIHtob3Jpem9udGFsLCBtaW5Sb3RhdGlvbn0pIHtcbiAgY29uc3QgcmFkID0gdG9SYWRpYW5zKG1pblJvdGF0aW9uKTtcbiAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKHJhZCkgOiBNYXRoLmNvcyhyYWQpKSB8fCAwLjAwMTtcbiAgY29uc3QgbGVuZ3RoID0gMC43NSAqIG1pblNwYWNpbmcgKiAoJycgKyB2YWx1ZSkubGVuZ3RoO1xuICByZXR1cm4gTWF0aC5taW4obWluU3BhY2luZyAvIHJhdGlvLCBsZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lYXJTY2FsZUJhc2UgZXh0ZW5kcyBTY2FsZSB7XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9lbmRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuXG4gIHBhcnNlKHJhdywgaW5kZXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoKHR5cGVvZiByYXcgPT09ICdudW1iZXInIHx8IHJhdyBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKCtyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gK3JhdztcbiAgfVxuXG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXM7XG5cbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuXG4gICAgaWYgKGJlZ2luQXRaZXJvKSB7XG4gICAgICBjb25zdCBtaW5TaWduID0gc2lnbihtaW4pO1xuICAgICAgY29uc3QgbWF4U2lnbiA9IHNpZ24obWF4KTtcblxuICAgICAgaWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XG4gICAgICAgIHNldE1heCgwKTtcbiAgICAgIH0gZWxzZSBpZiAobWluU2lnbiA+IDAgJiYgbWF4U2lnbiA+IDApIHtcbiAgICAgICAgc2V0TWluKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgbGV0IG9mZnNldCA9IG1heCA9PT0gMCA/IDEgOiBNYXRoLmFicyhtYXggKiAwLjA1KTtcblxuICAgICAgc2V0TWF4KG1heCArIG9mZnNldCk7XG5cbiAgICAgIGlmICghYmVnaW5BdFplcm8pIHtcbiAgICAgICAgc2V0TWluKG1pbiAtIG9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG5cbiAgZ2V0VGlja0xpbWl0KCkge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQge21heFRpY2tzTGltaXQsIHN0ZXBTaXplfSA9IHRpY2tPcHRzO1xuICAgIGxldCBtYXhUaWNrcztcblxuICAgIGlmIChzdGVwU2l6ZSkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLmNlaWwodGhpcy5tYXggLyBzdGVwU2l6ZSkgLSBNYXRoLmZsb29yKHRoaXMubWluIC8gc3RlcFNpemUpICsgMTtcbiAgICAgIGlmIChtYXhUaWNrcyA+IDEwMDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBzY2FsZXMuJHt0aGlzLmlkfS50aWNrcy5zdGVwU2l6ZTogJHtzdGVwU2l6ZX0gd291bGQgcmVzdWx0IGdlbmVyYXRpbmcgdXAgdG8gJHttYXhUaWNrc30gdGlja3MuIExpbWl0aW5nIHRvIDEwMDAuYCk7XG4gICAgICAgIG1heFRpY2tzID0gMTAwMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4VGlja3MgPSB0aGlzLmNvbXB1dGVUaWNrTGltaXQoKTtcbiAgICAgIG1heFRpY2tzTGltaXQgPSBtYXhUaWNrc0xpbWl0IHx8IDExO1xuICAgIH1cblxuICAgIGlmIChtYXhUaWNrc0xpbWl0KSB7XG4gICAgICBtYXhUaWNrcyA9IE1hdGgubWluKG1heFRpY2tzTGltaXQsIG1heFRpY2tzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF4VGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB9XG5cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCB0aGUgbWF4IG51bWJlciBvZiB0aWNrcyB3ZSBjYW4gc3VwcG9ydCBpdCBpcyBiYXNlZCBvbiB0aGUgc2l6ZSBvZlxuICAgIC8vIHRoZSBheGlzIGFyZWEuIEZvciBub3csIHdlIHNheSB0aGF0IHRoZSBtaW5pbXVtIHRpY2sgc3BhY2luZyBpbiBwaXhlbHMgbXVzdCBiZSA0MFxuICAgIC8vIFdlIGFsc28gbGltaXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIHRvIDExIHdoaWNoIGdpdmVzIGEgbmljZSAxMCBzcXVhcmVzIG9uXG4gICAgLy8gdGhlIGdyYXBoLiBNYWtlIHN1cmUgd2UgYWx3YXlzIGhhdmUgYXQgbGVhc3QgMiB0aWNrc1xuICAgIGxldCBtYXhUaWNrcyA9IHRoaXMuZ2V0VGlja0xpbWl0KCk7XG4gICAgbWF4VGlja3MgPSBNYXRoLm1heCgyLCBtYXhUaWNrcyk7XG5cbiAgICBjb25zdCBudW1lcmljR2VuZXJhdG9yT3B0aW9ucyA9IHtcbiAgICAgIG1heFRpY2tzLFxuICAgICAgYm91bmRzOiBvcHRzLmJvdW5kcyxcbiAgICAgIG1pbjogb3B0cy5taW4sXG4gICAgICBtYXg6IG9wdHMubWF4LFxuICAgICAgcHJlY2lzaW9uOiB0aWNrT3B0cy5wcmVjaXNpb24sXG4gICAgICBzdGVwOiB0aWNrT3B0cy5zdGVwU2l6ZSxcbiAgICAgIGNvdW50OiB0aWNrT3B0cy5jb3VudCxcbiAgICAgIG1heERpZ2l0czogdGhpcy5fbWF4RGlnaXRzKCksXG4gICAgICBob3Jpem9udGFsOiB0aGlzLmlzSG9yaXpvbnRhbCgpLFxuICAgICAgbWluUm90YXRpb246IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDAsXG4gICAgICBpbmNsdWRlQm91bmRzOiB0aWNrT3B0cy5pbmNsdWRlQm91bmRzICE9PSBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgZGF0YVJhbmdlID0gdGhpcy5fcmFuZ2UgfHwgdGhpcztcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MobnVtZXJpY0dlbmVyYXRvck9wdGlvbnMsIGRhdGFSYW5nZSk7XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzLFxuICAgIC8vIHNpbmNlIHdlIHByb2JhYmx5IGhhdmUgZXhwYW5kZWQgdGhlIHJhbmdlIG9mIHRoZSBzY2FsZVxuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG5cbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5taW47XG4gICAgbGV0IGVuZCA9IHRoaXMubWF4O1xuXG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IChlbmQgLSBzdGFydCkgLyBNYXRoLm1heCh0aWNrcy5sZW5ndGggLSAxLCAxKSAvIDI7XG4gICAgICBzdGFydCAtPSBvZmZzZXQ7XG4gICAgICBlbmQgKz0gb2Zmc2V0O1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gc3RhcnQ7XG4gICAgdGhpcy5fZW5kVmFsdWUgPSBlbmQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGVuZCAtIHN0YXJ0O1xuICB9XG5cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG59XG4iLCAiaW1wb3J0IHtpc0Zpbml0ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5pbXBvcnQge3RvUmFkaWFuc30gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcblxuICBzdGF0aWMgaWQgPSAnbGluZWFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICB0aWNrczoge1xuICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICAgIH1cbiAgfTtcblxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuXG4gICAgdGhpcy5taW4gPSBpc0Zpbml0ZShtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzRmluaXRlKG1heCkgPyBtYXggOiAxO1xuXG4gICAgLy8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIG1pbiwgbWF4LCBiZWdpbkF0WmVyb1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cblx0ICogQHByb3RlY3RlZFxuIFx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgbGVuZ3RoID0gaG9yaXpvbnRhbCA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRvUmFkaWFucyh0aGlzLm9wdGlvbnMudGlja3MubWluUm90YXRpb24pO1xuICAgIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihtaW5Sb3RhdGlvbikgOiBNYXRoLmNvcyhtaW5Sb3RhdGlvbikpIHx8IDAuMDAxO1xuICAgIGNvbnN0IHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGxlbmd0aCAvIE1hdGgubWluKDQwLCB0aWNrRm9udC5saW5lSGVpZ2h0IC8gcmF0aW8pKTtcbiAgfVxuXG4gIC8vIFV0aWxzXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZTtcbiAgfVxufVxuIiwgImltcG9ydCB7ZmluaXRlT3JEZWZhdWx0LCBpc0Zpbml0ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcbmltcG9ydCB7X3NldE1pbkFuZE1heEJ5S2V5LCBsb2cxMH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQgTGluZWFyU2NhbGVCYXNlIGZyb20gJy4vc2NhbGUubGluZWFyYmFzZS5qcyc7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vY29yZS9jb3JlLnRpY2tzLmpzJztcblxuY29uc3QgbG9nMTBGbG9vciA9IHYgPT4gTWF0aC5mbG9vcihsb2cxMCh2KSk7XG5jb25zdCBjaGFuZ2VFeHBvbmVudCA9ICh2LCBtKSA9PiBNYXRoLnBvdygxMCwgbG9nMTBGbG9vcih2KSArIG0pO1xuXG5mdW5jdGlvbiBpc01ham9yKHRpY2tWYWwpIHtcbiAgY29uc3QgcmVtYWluID0gdGlja1ZhbCAvIChNYXRoLnBvdygxMCwgbG9nMTBGbG9vcih0aWNrVmFsKSkpO1xuICByZXR1cm4gcmVtYWluID09PSAxO1xufVxuXG5mdW5jdGlvbiBzdGVwcyhtaW4sIG1heCwgcmFuZ2VFeHApIHtcbiAgY29uc3QgcmFuZ2VTdGVwID0gTWF0aC5wb3coMTAsIHJhbmdlRXhwKTtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLmZsb29yKG1pbiAvIHJhbmdlU3RlcCk7XG4gIGNvbnN0IGVuZCA9IE1hdGguY2VpbChtYXggLyByYW5nZVN0ZXApO1xuICByZXR1cm4gZW5kIC0gc3RhcnQ7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0RXhwKG1pbiwgbWF4KSB7XG4gIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuICBsZXQgcmFuZ2VFeHAgPSBsb2cxMEZsb29yKHJhbmdlKTtcbiAgd2hpbGUgKHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkgPiAxMCkge1xuICAgIHJhbmdlRXhwKys7XG4gIH1cbiAgd2hpbGUgKHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkgPCAxMCkge1xuICAgIHJhbmdlRXhwLS07XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKHJhbmdlRXhwLCBsb2cxMEZsb29yKG1pbikpO1xufVxuXG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbG9nYXJpdGhtaWMgdGlja3NcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtvYmplY3RbXX0gYXJyYXkgb2YgdGljayBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIHttaW4sIG1heH0pIHtcbiAgbWluID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgbWluKTtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgbWluRXhwID0gbG9nMTBGbG9vcihtaW4pO1xuICBsZXQgZXhwID0gc3RhcnRFeHAobWluLCBtYXgpO1xuICBsZXQgcHJlY2lzaW9uID0gZXhwIDwgMCA/IE1hdGgucG93KDEwLCBNYXRoLmFicyhleHApKSA6IDE7XG4gIGNvbnN0IHN0ZXBTaXplID0gTWF0aC5wb3coMTAsIGV4cCk7XG4gIGNvbnN0IGJhc2UgPSBtaW5FeHAgPiBleHAgPyBNYXRoLnBvdygxMCwgbWluRXhwKSA6IDA7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5yb3VuZCgobWluIC0gYmFzZSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICBjb25zdCBvZmZzZXQgPSBNYXRoLmZsb29yKChtaW4gLSBiYXNlKSAvIHN0ZXBTaXplIC8gMTApICogc3RlcFNpemUgKiAxMDtcbiAgbGV0IHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcigoc3RhcnQgLSBvZmZzZXQpIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuICBsZXQgdmFsdWUgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBNYXRoLnJvdW5kKChiYXNlICsgb2Zmc2V0ICsgc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uKTtcbiAgd2hpbGUgKHZhbHVlIDwgbWF4KSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWUsIG1ham9yOiBpc01ham9yKHZhbHVlKSwgc2lnbmlmaWNhbmR9KTtcbiAgICBpZiAoc2lnbmlmaWNhbmQgPj0gMTApIHtcbiAgICAgIHNpZ25pZmljYW5kID0gc2lnbmlmaWNhbmQgPCAxNSA/IDE1IDogMjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpZ25pZmljYW5kKys7XG4gICAgfVxuICAgIGlmIChzaWduaWZpY2FuZCA+PSAyMCkge1xuICAgICAgZXhwKys7XG4gICAgICBzaWduaWZpY2FuZCA9IDI7XG4gICAgICBwcmVjaXNpb24gPSBleHAgPj0gMCA/IDEgOiBwcmVjaXNpb247XG4gICAgfVxuICAgIHZhbHVlID0gTWF0aC5yb3VuZCgoYmFzZSArIG9mZnNldCArIHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgfVxuICBjb25zdCBsYXN0VGljayA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIHZhbHVlKTtcbiAgdGlja3MucHVzaCh7dmFsdWU6IGxhc3RUaWNrLCBtYWpvcjogaXNNYWpvcihsYXN0VGljayksIHNpZ25pZmljYW5kfSk7XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2dhcml0aG1pY1NjYWxlIGV4dGVuZHMgU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICdsb2dhcml0aG1pYyc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgdGlja3M6IHtcbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljLFxuICAgICAgbWFqb3I6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cblxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgY29uc3QgdmFsdWUgPSBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLnBhcnNlLmFwcGx5KHRoaXMsIFtyYXcsIGluZGV4XSk7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwID8gdmFsdWUgOiBudWxsO1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG5cbiAgICB0aGlzLm1pbiA9IGlzRmluaXRlKG1pbikgPyBNYXRoLm1heCgwLCBtaW4pIDogbnVsbDtcbiAgICB0aGlzLm1heCA9IGlzRmluaXRlKG1heCkgPyBNYXRoLm1heCgwLCBtYXgpIDogbnVsbDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmVnaW5BdFplcm8pIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGlmIGRhdGEgaGFzIGAwYCBpbiBpdCBvciBgYmVnaW5BdFplcm9gIGlzIHRydWUsIG1pbiAobm9uIHplcm8pIHZhbHVlIGlzIGF0IGJvdHRvbVxuICAgIC8vIG9mIHNjYWxlLCBhbmQgaXQgZG9lcyBub3QgZXF1YWwgc3VnZ2VzdGVkTWluLCBsb3dlciB0aGUgbWluIGJvdW5kIGJ5IG9uZSBleHAuXG4gICAgaWYgKHRoaXMuX3plcm8gJiYgdGhpcy5taW4gIT09IHRoaXMuX3N1Z2dlc3RlZE1pbiAmJiAhaXNGaW5pdGUodGhpcy5fdXNlck1pbikpIHtcbiAgICAgIHRoaXMubWluID0gbWluID09PSBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgMCkgPyBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgLTEpIDogY2hhbmdlRXhwb25lbnQodGhpcy5taW4sIDApO1xuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG5cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgbWluID0gdGhpcy5taW47XG4gICAgbGV0IG1heCA9IHRoaXMubWF4O1xuXG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcblxuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgaWYgKG1pbiA8PSAwKSB7IC8vIGluY2x1ZGVzIG51bGxcbiAgICAgICAgc2V0TWluKDEpO1xuICAgICAgICBzZXRNYXgoMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0TWluKGNoYW5nZUV4cG9uZW50KG1pbiwgLTEpKTtcbiAgICAgICAgc2V0TWF4KGNoYW5nZUV4cG9uZW50KG1heCwgKzEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICBzZXRNaW4oY2hhbmdlRXhwb25lbnQobWF4LCAtMSkpO1xuICAgIH1cbiAgICBpZiAobWF4IDw9IDApIHtcblxuICAgICAgc2V0TWF4KGNoYW5nZUV4cG9uZW50KG1pbiwgKzEpKTtcbiAgICB9XG5cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIGNvbnN0IGdlbmVyYXRpb25PcHRpb25zID0ge1xuICAgICAgbWluOiB0aGlzLl91c2VyTWluLFxuICAgICAgbWF4OiB0aGlzLl91c2VyTWF4XG4gICAgfTtcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIHRoaXMpO1xuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyxcbiAgICAvLyBzaW5jZSB3ZSBwcm9iYWJseSBoYXZlIGV4cGFuZGVkIHRoZSByYW5nZSBvZiB0aGUgc2NhbGVcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuXG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cblxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICcwJ1xuICAgICAgOiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMubWluO1xuXG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG5cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gbG9nMTAoc3RhcnQpO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBsb2cxMCh0aGlzLm1heCkgLSBsb2cxMChzdGFydCk7XG4gIH1cblxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIHZhbHVlID0gdGhpcy5taW47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCh2YWx1ZSA9PT0gdGhpcy5taW5cbiAgICAgID8gMFxuICAgICAgOiAobG9nMTAodmFsdWUpIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpO1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhcnRWYWx1ZSArIGRlY2ltYWwgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxufVxuIiwgImltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9jb3JlL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtfbG9uZ2VzdFRleHQsIGFkZFJvdW5kZWRSZWN0UGF0aCwgcmVuZGVyVGV4dCwgX2lzUG9pbnRJbkFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtIQUxGX1BJLCBUQVUsIHRvRGVncmVlcywgdG9SYWRpYW5zLCBfbm9ybWFsaXplQW5nbGUsIFBJfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgTGluZWFyU2NhbGVCYXNlIGZyb20gJy4vc2NhbGUubGluZWFyYmFzZS5qcyc7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vY29yZS9jb3JlLnRpY2tzLmpzJztcbmltcG9ydCB7dmFsdWVPckRlZmF1bHQsIGlzQXJyYXksIGlzRmluaXRlLCBjYWxsYmFjayBhcyBjYWxsQ2FsbGJhY2ssIGlzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dCwgdG9Gb250LCB0b1BhZGRpbmcsIHRvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuZnVuY3Rpb24gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIHtcbiAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG4gIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIG9wdHMuZGlzcGxheSkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGlja09wdHMuYmFja2Ryb3BQYWRkaW5nKTtcbiAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udCAmJiB0aWNrT3B0cy5mb250LnNpemUsIGRlZmF1bHRzLmZvbnQuc2l6ZSkgKyBwYWRkaW5nLmhlaWdodDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gbWVhc3VyZUxhYmVsU2l6ZShjdHgsIGZvbnQsIGxhYmVsKSB7XG4gIGxhYmVsID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbCA6IFtsYWJlbF07XG4gIHJldHVybiB7XG4gICAgdzogX2xvbmdlc3RUZXh0KGN0eCwgZm9udC5zdHJpbmcsIGxhYmVsKSxcbiAgICBoOiBsYWJlbC5sZW5ndGggKiBmb250LmxpbmVIZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XG4gIGlmIChhbmdsZSA9PT0gbWluIHx8IGFuZ2xlID09PSBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXG4gICAgICBlbmQ6IHBvcyArIChzaXplIC8gMilcbiAgICB9O1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSBzaXplLFxuICAgICAgZW5kOiBwb3NcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcG9zLFxuICAgIGVuZDogcG9zICsgc2l6ZVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBmaXQgYSByYWRpYWwgbGluZWFyIHNjYWxlIHdpdGggcG9pbnQgbGFiZWxzXG4gKi9cbmZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xuXG4gIC8vIFJpZ2h0LCB0aGlzIGlzIHJlYWxseSBjb25mdXNpbmcgYW5kIHRoZXJlIGlzIGEgbG90IG9mIG1hdGhzIGdvaW5nIG9uIGhlcmVcbiAgLy8gVGhlIGdpc3Qgb2YgdGhlIHByb2JsZW0gaXMgaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbm5uaWNrLzY5NmNjOWM1NWY0YjBiZWI4ZmU5XG4gIC8vXG4gIC8vIFJlYWN0aW9uOiBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My90b29tdWNoc2NpZW5jZS5naWZcbiAgLy9cbiAgLy8gU29sdXRpb246XG4gIC8vXG4gIC8vIFdlIGFzc3VtZSB0aGUgcmFkaXVzIG9mIHRoZSBwb2x5Z29uIGlzIGhhbGYgdGhlIHNpemUgb2YgdGhlIGNhbnZhcyBhdCBmaXJzdFxuICAvLyBhdCBlYWNoIGluZGV4IHdlIGNoZWNrIGlmIHRoZSB0ZXh0IG92ZXJsYXBzLlxuICAvL1xuICAvLyBXaGVyZSBpdCBkb2VzLCB3ZSBzdG9yZSB0aGF0IGFuZ2xlIGFuZCB0aGF0IGluZGV4LlxuICAvL1xuICAvLyBBZnRlciBmaW5kaW5nIHRoZSBsYXJnZXN0IGluZGV4IGFuZCBhbmdsZSB3ZSBjYWxjdWxhdGUgaG93IG11Y2ggd2UgbmVlZCB0byByZW1vdmVcbiAgLy8gZnJvbSB0aGUgc2hhcGUgcmFkaXVzIHRvIG1vdmUgdGhlIHBvaW50IGlud2FyZHMgYnkgdGhhdCB4LlxuICAvL1xuICAvLyBXZSBhdmVyYWdlIHRoZSBsZWZ0IGFuZCByaWdodCBkaXN0YW5jZXMgdG8gZ2V0IHRoZSBtYXhpbXVtIHNoYXBlIHJhZGl1cyB0aGF0IGNhbiBmaXQgaW4gdGhlIGJveFxuICAvLyBhbG9uZyB3aXRoIGxhYmVscy5cbiAgLy9cbiAgLy8gT25jZSB3ZSBoYXZlIHRoYXQsIHdlIGNhbiBmaW5kIHRoZSBjZW50cmUgcG9pbnQgZm9yIHRoZSBjaGFydCwgYnkgdGFraW5nIHRoZSB4IHRleHQgcHJvdHJ1c2lvblxuICAvLyBvbiBlYWNoIHNpZGUsIHJlbW92aW5nIHRoYXQgZnJvbSB0aGUgc2l6ZSwgaGFsdmluZyBpdCBhbmQgYWRkaW5nIHRoZSBsZWZ0IHggcHJvdHJ1c2lvbiB3aWR0aC5cbiAgLy9cbiAgLy8gVGhpcyB3aWxsIG1lYW4gd2UgaGF2ZSBhIHNoYXBlIGZpdHRlZCB0byB0aGUgY2FudmFzLCBhcyBsYXJnZSBhcyBpdCBjYW4gYmUgd2l0aCB0aGUgbGFiZWxzXG4gIC8vIGFuZCBwb3NpdGlvbiBpdCBpbiB0aGUgbW9zdCBzcGFjZSBlZmZpY2llbnQgbWFubmVyXG4gIC8vXG4gIC8vIGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3llYWhzY2llbmNlLmdpZlxuXG4gIC8vIEdldCBtYXhpbXVtIHJhZGl1cyBvZiB0aGUgcG9seWdvbi4gRWl0aGVyIGhhbGYgdGhlIGhlaWdodCAobWludXMgdGhlIHRleHQgd2lkdGgpIG9yIGhhbGYgdGhlIHdpZHRoLlxuICAvLyBVc2UgdGhpcyB0byBjYWxjdWxhdGUgdGhlIG9mZnNldCArIGNoYW5nZS4gLSBNYWtlIHN1cmUgTC9SIHByb3RydXNpb24gaXMgYXQgbGVhc3QgMCB0byBzdG9wIGlzc3VlcyB3aXRoIGNlbnRyZSBwb2ludHNcbiAgY29uc3Qgb3JpZyA9IHtcbiAgICBsOiBzY2FsZS5sZWZ0ICsgc2NhbGUuX3BhZGRpbmcubGVmdCxcbiAgICByOiBzY2FsZS5yaWdodCAtIHNjYWxlLl9wYWRkaW5nLnJpZ2h0LFxuICAgIHQ6IHNjYWxlLnRvcCArIHNjYWxlLl9wYWRkaW5nLnRvcCxcbiAgICBiOiBzY2FsZS5ib3R0b20gLSBzY2FsZS5fcGFkZGluZy5ib3R0b21cbiAgfTtcbiAgY29uc3QgbGltaXRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZyk7XG4gIGNvbnN0IGxhYmVsU2l6ZXMgPSBbXTtcbiAgY29uc3QgcGFkZGluZyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgY29uc3QgcG9pbnRMYWJlbE9wdHMgPSBzY2FsZS5vcHRpb25zLnBvaW50TGFiZWxzO1xuICBjb25zdCBhZGRpdGlvbmFsQW5nbGUgPSBwb2ludExhYmVsT3B0cy5jZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBjb25zdCBvcHRzID0gcG9pbnRMYWJlbE9wdHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgcGFkZGluZ1tpXSA9IG9wdHMucGFkZGluZztcbiAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBzY2FsZS5kcmF3aW5nQXJlYSArIHBhZGRpbmdbaV0sIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LCBzY2FsZS5fcG9pbnRMYWJlbHNbaV0pO1xuICAgIGxhYmVsU2l6ZXNbaV0gPSB0ZXh0U2l6ZTtcblxuICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IF9ub3JtYWxpemVBbmdsZShzY2FsZS5nZXRJbmRleEFuZ2xlKGkpICsgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKGFuZ2xlUmFkaWFucykpO1xuICAgIGNvbnN0IGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcbiAgICBjb25zdCB2TGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLnksIHRleHRTaXplLmgsIDkwLCAyNzApO1xuICAgIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlUmFkaWFucywgaExpbWl0cywgdkxpbWl0cyk7XG4gIH1cblxuICBzY2FsZS5zZXRDZW50ZXJQb2ludChcbiAgICBvcmlnLmwgLSBsaW1pdHMubCxcbiAgICBsaW1pdHMuciAtIG9yaWcucixcbiAgICBvcmlnLnQgLSBsaW1pdHMudCxcbiAgICBsaW1pdHMuYiAtIG9yaWcuYlxuICApO1xuXG4gIC8vIE5vdyB0aGF0IHRleHQgc2l6ZSBpcyBkZXRlcm1pbmVkLCBjb21wdXRlIHRoZSBmdWxsIHBvc2l0aW9uc1xuICBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zID0gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZSwgaExpbWl0cywgdkxpbWl0cykge1xuICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihhbmdsZSkpO1xuICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZSkpO1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgaWYgKGhMaW1pdHMuc3RhcnQgPCBvcmlnLmwpIHtcbiAgICB4ID0gKG9yaWcubCAtIGhMaW1pdHMuc3RhcnQpIC8gc2luO1xuICAgIGxpbWl0cy5sID0gTWF0aC5taW4obGltaXRzLmwsIG9yaWcubCAtIHgpO1xuICB9IGVsc2UgaWYgKGhMaW1pdHMuZW5kID4gb3JpZy5yKSB7XG4gICAgeCA9IChoTGltaXRzLmVuZCAtIG9yaWcucikgLyBzaW47XG4gICAgbGltaXRzLnIgPSBNYXRoLm1heChsaW1pdHMuciwgb3JpZy5yICsgeCk7XG4gIH1cbiAgaWYgKHZMaW1pdHMuc3RhcnQgPCBvcmlnLnQpIHtcbiAgICB5ID0gKG9yaWcudCAtIHZMaW1pdHMuc3RhcnQpIC8gY29zO1xuICAgIGxpbWl0cy50ID0gTWF0aC5taW4obGltaXRzLnQsIG9yaWcudCAtIHkpO1xuICB9IGVsc2UgaWYgKHZMaW1pdHMuZW5kID4gb3JpZy5iKSB7XG4gICAgeSA9ICh2TGltaXRzLmVuZCAtIG9yaWcuYikgLyBjb3M7XG4gICAgbGltaXRzLmIgPSBNYXRoLm1heChsaW1pdHMuYiwgb3JpZy5iICsgeSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbEl0ZW0oc2NhbGUsIGluZGV4LCBpdGVtT3B0cykge1xuICBjb25zdCBvdXRlckRpc3RhbmNlID0gc2NhbGUuZHJhd2luZ0FyZWE7XG4gIGNvbnN0IHtleHRyYSwgYWRkaXRpb25hbEFuZ2xlLCBwYWRkaW5nLCBzaXplfSA9IGl0ZW1PcHRzO1xuICBjb25zdCBwb2ludExhYmVsUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCBvdXRlckRpc3RhbmNlICsgZXh0cmEgKyBwYWRkaW5nLCBhZGRpdGlvbmFsQW5nbGUpO1xuICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKF9ub3JtYWxpemVBbmdsZShwb2ludExhYmVsUG9zaXRpb24uYW5nbGUgKyBIQUxGX1BJKSkpO1xuICBjb25zdCB5ID0geUZvckFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi55LCBzaXplLmgsIGFuZ2xlKTtcbiAgY29uc3QgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpO1xuICBjb25zdCBsZWZ0ID0gbGVmdEZvclRleHRBbGlnbihwb2ludExhYmVsUG9zaXRpb24ueCwgc2l6ZS53LCB0ZXh0QWxpZ24pO1xuICByZXR1cm4ge1xuICAgIC8vIGlmIHRvIGRyYXcgb3Igb3ZlcmxhcHBlZFxuICAgIHZpc2libGU6IHRydWUsXG5cbiAgICAvLyBUZXh0IHBvc2l0aW9uXG4gICAgeDogcG9pbnRMYWJlbFBvc2l0aW9uLngsXG4gICAgeSxcblxuICAgIC8vIFRleHQgcmVuZGVyaW5nIGRhdGFcbiAgICB0ZXh0QWxpZ24sXG5cbiAgICAvLyBCb3VuZGluZyBib3hcbiAgICBsZWZ0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogbGVmdCArIHNpemUudyxcbiAgICBib3R0b206IHkgKyBzaXplLmhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNOb3RPdmVybGFwcGVkKGl0ZW0sIGFyZWEpIHtcbiAgaWYgKCFhcmVhKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBpdGVtO1xuICBjb25zdCBhcGV4ZXNJbkFyZWEgPSBfaXNQb2ludEluQXJlYSh7eDogbGVmdCwgeTogdG9wfSwgYXJlYSkgfHwgX2lzUG9pbnRJbkFyZWEoe3g6IGxlZnQsIHk6IGJvdHRvbX0sIGFyZWEpIHx8XG4gICAgX2lzUG9pbnRJbkFyZWEoe3g6IHJpZ2h0LCB5OiB0b3B9LCBhcmVhKSB8fCBfaXNQb2ludEluQXJlYSh7eDogcmlnaHQsIHk6IGJvdHRvbX0sIGFyZWEpO1xuICByZXR1cm4gIWFwZXhlc0luQXJlYTtcbn1cblxuZnVuY3Rpb24gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCB7Y2VudGVyUG9pbnRMYWJlbHMsIGRpc3BsYXl9ID0gb3B0cy5wb2ludExhYmVscztcbiAgY29uc3QgaXRlbU9wdHMgPSB7XG4gICAgZXh0cmE6IGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSAvIDIsXG4gICAgYWRkaXRpb25hbEFuZ2xlOiBjZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDBcbiAgfTtcbiAgbGV0IGFyZWE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBpdGVtT3B0cy5wYWRkaW5nID0gcGFkZGluZ1tpXTtcbiAgICBpdGVtT3B0cy5zaXplID0gbGFiZWxTaXplc1tpXTtcblxuICAgIGNvbnN0IGl0ZW0gPSBjcmVhdGVQb2ludExhYmVsSXRlbShzY2FsZSwgaSwgaXRlbU9wdHMpO1xuICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgaWYgKGRpc3BsYXkgPT09ICdhdXRvJykge1xuICAgICAgaXRlbS52aXNpYmxlID0gaXNOb3RPdmVybGFwcGVkKGl0ZW0sIGFyZWEpO1xuICAgICAgaWYgKGl0ZW0udmlzaWJsZSkge1xuICAgICAgICBhcmVhID0gaXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuICAgIHJldHVybiAnY2VudGVyJztcbiAgfSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH1cblxuICByZXR1cm4gJ3JpZ2h0Jztcbn1cblxuZnVuY3Rpb24gbGVmdEZvclRleHRBbGlnbih4LCB3LCBhbGlnbikge1xuICBpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHc7XG4gIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAodyAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiB5Rm9yQW5nbGUoeSwgaCwgYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSA5MCB8fCBhbmdsZSA9PT0gMjcwKSB7XG4gICAgeSAtPSAoaCAvIDIpO1xuICB9IGVsc2UgaWYgKGFuZ2xlID4gMjcwIHx8IGFuZ2xlIDwgOTApIHtcbiAgICB5IC09IGg7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVsQm94KGN0eCwgb3B0cywgaXRlbSkge1xuICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IGl0ZW07XG4gIGNvbnN0IHtiYWNrZHJvcENvbG9yfSA9IG9wdHM7XG5cbiAgaWYgKCFpc051bGxPclVuZGVmKGJhY2tkcm9wQ29sb3IpKSB7XG4gICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhvcHRzLmJvcmRlclJhZGl1cyk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wQ29sb3I7XG5cbiAgICBjb25zdCBiYWNrZHJvcExlZnQgPSBsZWZ0IC0gcGFkZGluZy5sZWZ0O1xuICAgIGNvbnN0IGJhY2tkcm9wVG9wID0gdG9wIC0gcGFkZGluZy50b3A7XG4gICAgY29uc3QgYmFja2Ryb3BXaWR0aCA9IHJpZ2h0IC0gbGVmdCArIHBhZGRpbmcud2lkdGg7XG4gICAgY29uc3QgYmFja2Ryb3BIZWlnaHQgPSBib3R0b20gLSB0b3AgKyBwYWRkaW5nLmhlaWdodDtcblxuICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgIHg6IGJhY2tkcm9wTGVmdCxcbiAgICAgICAgeTogYmFja2Ryb3BUb3AsXG4gICAgICAgIHc6IGJhY2tkcm9wV2lkdGgsXG4gICAgICAgIGg6IGJhY2tkcm9wSGVpZ2h0LFxuICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgIH0pO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmZpbGxSZWN0KGJhY2tkcm9wTGVmdCwgYmFja2Ryb3BUb3AsIGJhY2tkcm9wV2lkdGgsIGJhY2tkcm9wSGVpZ2h0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1BvaW50TGFiZWxzKHNjYWxlLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtwb2ludExhYmVsc319ID0gc2NhbGU7XG5cbiAgZm9yIChsZXQgaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGl0ZW0gPSBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zW2ldO1xuICAgIGlmICghaXRlbS52aXNpYmxlKSB7XG4gICAgICAvLyBvdmVybGFwcGluZ1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gcG9pbnRMYWJlbHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgZHJhd1BvaW50TGFiZWxCb3goY3R4LCBvcHRzQXRJbmRleCwgaXRlbSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgIGNvbnN0IHt4LCB5LCB0ZXh0QWxpZ259ID0gaXRlbTtcblxuICAgIHJlbmRlclRleHQoXG4gICAgICBjdHgsXG4gICAgICBzY2FsZS5fcG9pbnRMYWJlbHNbaV0sXG4gICAgICB4LFxuICAgICAgeSArIChwbEZvbnQubGluZUhlaWdodCAvIDIpLFxuICAgICAgcGxGb250LFxuICAgICAge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnXG4gICAgICB9XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4fSA9IHNjYWxlO1xuICBpZiAoY2lyY3VsYXIpIHtcbiAgICAvLyBEcmF3IGNpcmN1bGFyIGFyY3MgYmV0d2VlbiB0aGUgcG9pbnRzXG4gICAgY3R4LmFyYyhzY2FsZS54Q2VudGVyLCBzY2FsZS55Q2VudGVyLCByYWRpdXMsIDAsIFRBVSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRHJhdyBzdHJhaWdodCBsaW5lcyBjb25uZWN0aW5nIGVhY2ggaW5kZXhcbiAgICBsZXQgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oMCwgcmFkaXVzKTtcbiAgICBjdHgubW92ZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdSYWRpdXNMaW5lKHNjYWxlLCBncmlkTGluZU9wdHMsIHJhZGl1cywgbGFiZWxDb3VudCwgYm9yZGVyT3B0cykge1xuICBjb25zdCBjdHggPSBzY2FsZS5jdHg7XG4gIGNvbnN0IGNpcmN1bGFyID0gZ3JpZExpbmVPcHRzLmNpcmN1bGFyO1xuXG4gIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IGdyaWRMaW5lT3B0cztcblxuICBpZiAoKCFjaXJjdWxhciAmJiAhbGFiZWxDb3VudCkgfHwgIWNvbG9yIHx8ICFsaW5lV2lkdGggfHwgcmFkaXVzIDwgMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICBjdHguc2V0TGluZURhc2goYm9yZGVyT3B0cy5kYXNoKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gYm9yZGVyT3B0cy5kYXNoT2Zmc2V0O1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5zdHJva2UoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQocGFyZW50LCBpbmRleCwgbGFiZWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgbGFiZWwsXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3BvaW50TGFiZWwnXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRpYWxMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG5cbiAgc3RhdGljIGlkID0gJ3JhZGlhbExpbmVhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGlzcGxheTogdHJ1ZSxcblxuICAgIC8vIEJvb2xlYW4gLSBXaGV0aGVyIHRvIGFuaW1hdGUgc2NhbGluZyB0aGUgY2hhcnQgZnJvbSB0aGUgY2VudHJlXG4gICAgYW5pbWF0ZTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ2NoYXJ0QXJlYScsXG5cbiAgICBhbmdsZUxpbmVzOiB7XG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgYm9yZGVyRGFzaDogW10sXG4gICAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLjBcbiAgICB9LFxuXG4gICAgZ3JpZDoge1xuICAgICAgY2lyY3VsYXI6IGZhbHNlXG4gICAgfSxcblxuICAgIHN0YXJ0QW5nbGU6IDAsXG5cbiAgICAvLyBsYWJlbCBzZXR0aW5nc1xuICAgIHRpY2tzOiB7XG4gICAgICAvLyBCb29sZWFuIC0gU2hvdyBhIGJhY2tkcm9wIHRvIHRoZSBzY2FsZSBsYWJlbFxuICAgICAgc2hvd0xhYmVsQmFja2Ryb3A6IHRydWUsXG5cbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgICB9LFxuXG4gICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgIGJhY2tkcm9wQ29sb3I6IHVuZGVmaW5lZCxcblxuICAgICAgLy8gTnVtYmVyIC0gVGhlIGJhY2tkcm9wIHBhZGRpbmcgYWJvdmUgJiBiZWxvdyB0aGUgbGFiZWwgaW4gcGl4ZWxzXG4gICAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG5cbiAgICAgIC8vIEJvb2xlYW4gLSBpZiB0cnVlLCBzaG93IHBvaW50IGxhYmVsc1xuICAgICAgZGlzcGxheTogdHJ1ZSxcblxuICAgICAgLy8gTnVtYmVyIC0gUG9pbnQgbGFiZWwgZm9udCBzaXplIGluIHBpeGVsc1xuICAgICAgZm9udDoge1xuICAgICAgICBzaXplOiAxMFxuICAgICAgfSxcblxuICAgICAgLy8gRnVuY3Rpb24gLSBVc2VkIHRvIGNvbnZlcnQgcG9pbnQgbGFiZWxzXG4gICAgICBjYWxsYmFjayhsYWJlbCkge1xuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICB9LFxuXG4gICAgICAvLyBOdW1iZXIgLSBBZGRpdGlvbmwgcGFkZGluZyBiZXR3ZWVuIHNjYWxlIGFuZCBwb2ludExhYmVsXG4gICAgICBwYWRkaW5nOiA1LFxuXG4gICAgICAvLyBCb29sZWFuIC0gaWYgdHJ1ZSwgY2VudGVyIHBvaW50IGxhYmVscyB0byBzbGljZXMgaW4gcG9sYXIgY2hhcnRcbiAgICAgIGNlbnRlclBvaW50TGFiZWxzOiBmYWxzZVxuICAgIH1cbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICAnYW5nbGVMaW5lcy5jb2xvcic6ICdib3JkZXJDb2xvcicsXG4gICAgJ3BvaW50TGFiZWxzLmNvbG9yJzogJ2NvbG9yJyxcbiAgICAndGlja3MuY29sb3InOiAnY29sb3InXG4gIH07XG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgIF9mYWxsYmFjazogJ2dyaWQnXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnhDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy55Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cbiAgICB0aGlzLl9wb2ludExhYmVscyA9IFtdO1xuICAgIHRoaXMuX3BvaW50TGFiZWxJdGVtcyA9IFtdO1xuICB9XG5cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICAvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpIC8gMik7XG4gICAgY29uc3QgdyA9IHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoIC0gcGFkZGluZy53aWR0aDtcbiAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0O1xuICAgIHRoaXMueENlbnRlciA9IE1hdGguZmxvb3IodGhpcy5sZWZ0ICsgdyAvIDIgKyBwYWRkaW5nLmxlZnQpO1xuICAgIHRoaXMueUNlbnRlciA9IE1hdGguZmxvb3IodGhpcy50b3AgKyBoIC8gMiArIHBhZGRpbmcudG9wKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gTWF0aC5mbG9vcihNYXRoLm1pbih3LCBoKSAvIDIpO1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgoZmFsc2UpO1xuXG4gICAgdGhpcy5taW4gPSBpc0Zpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiAwO1xuXG4gICAgLy8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIG1pbiwgbWF4LCBiZWdpbkF0WmVyb1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZHJhd2luZ0FyZWEgLyBnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSk7XG4gIH1cblxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLmdlbmVyYXRlVGlja0xhYmVscy5jYWxsKHRoaXMsIHRpY2tzKTtcblxuICAgIC8vIFBvaW50IGxhYmVsc1xuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKVxuICAgICAgLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gY2FsbENhbGxiYWNrKHRoaXMub3B0aW9ucy5wb2ludExhYmVscy5jYWxsYmFjaywgW3ZhbHVlLCBpbmRleF0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gbGFiZWwgfHwgbGFiZWwgPT09IDAgPyBsYWJlbCA6ICcnO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKHYsIGkpID0+IHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkpO1xuICB9XG5cbiAgZml0KCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAob3B0cy5kaXNwbGF5ICYmIG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgZml0V2l0aFBvaW50TGFiZWxzKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuICAgIH1cbiAgfVxuXG4gIHNldENlbnRlclBvaW50KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSB7XG4gICAgdGhpcy54Q2VudGVyICs9IE1hdGguZmxvb3IoKGxlZnRNb3ZlbWVudCAtIHJpZ2h0TW92ZW1lbnQpIC8gMik7XG4gICAgdGhpcy55Q2VudGVyICs9IE1hdGguZmxvb3IoKHRvcE1vdmVtZW50IC0gYm90dG9tTW92ZW1lbnQpIC8gMik7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSAtPSBNYXRoLm1pbih0aGlzLmRyYXdpbmdBcmVhIC8gMiwgTWF0aC5tYXgobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpKTtcbiAgfVxuXG4gIGdldEluZGV4QW5nbGUoaW5kZXgpIHtcbiAgICBjb25zdCBhbmdsZU11bHRpcGxpZXIgPSBUQVUgLyAodGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoIHx8IDEpO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLm9wdGlvbnMuc3RhcnRBbmdsZSB8fCAwO1xuXG4gICAgcmV0dXJuIF9ub3JtYWxpemVBbmdsZShpbmRleCAqIGFuZ2xlTXVsdGlwbGllciArIHRvUmFkaWFucyhzdGFydEFuZ2xlKSk7XG4gIH1cblxuICBnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICAvLyBUYWtlIGludG8gYWNjb3VudCBoYWxmIGZvbnQgc2l6ZSArIHRoZSB5UGFkZGluZyBvZiB0aGUgdG9wIHZhbHVlXG4gICAgY29uc3Qgc2NhbGluZ0ZhY3RvciA9IHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICByZXR1cm4gKHRoaXMubWF4IC0gdmFsdWUpICogc2NhbGluZ0ZhY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWluKSAqIHNjYWxpbmdGYWN0b3I7XG4gIH1cblxuICBnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlcihkaXN0YW5jZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKGRpc3RhbmNlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICBjb25zdCBzY2FsZWREaXN0YW5jZSA9IGRpc3RhbmNlIC8gKHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbikpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmV2ZXJzZSA/IHRoaXMubWF4IC0gc2NhbGVkRGlzdGFuY2UgOiB0aGlzLm1pbiArIHNjYWxlZERpc3RhbmNlO1xuICB9XG5cbiAgZ2V0UG9pbnRMYWJlbENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCBwb2ludExhYmVscyA9IHRoaXMuX3BvaW50TGFiZWxzIHx8IFtdO1xuXG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBwb2ludExhYmVscy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBvaW50TGFiZWwgPSBwb2ludExhYmVsc1tpbmRleF07XG4gICAgICByZXR1cm4gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBwb2ludExhYmVsKTtcbiAgICB9XG4gIH1cblxuICBnZXRQb2ludFBvc2l0aW9uKGluZGV4LCBkaXN0YW5jZUZyb21DZW50ZXIsIGFkZGl0aW9uYWxBbmdsZSA9IDApIHtcbiAgICBjb25zdCBhbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSBIQUxGX1BJICsgYWRkaXRpb25hbEFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmNvcyhhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnhDZW50ZXIsXG4gICAgICB5OiBNYXRoLnNpbihhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnlDZW50ZXIsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cblxuICBnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0QmFzZVBvc2l0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4IHx8IDAsIHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG5cbiAgZ2V0UG9pbnRMYWJlbFBvc2l0aW9uKGluZGV4KSB7XG4gICAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSB0aGlzLl9wb2ludExhYmVsSXRlbXNbaW5kZXhdO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0LFxuICAgICAgdG9wLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7YmFja2dyb3VuZENvbG9yLCBncmlkOiB7Y2lyY3VsYXJ9fSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBwYXRoUmFkaXVzTGluZSh0aGlzLCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuX2VuZFZhbHVlKSwgY2lyY3VsYXIsIHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdHcmlkKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2FuZ2xlTGluZXMsIGdyaWQsIGJvcmRlcn0gPSBvcHRzO1xuICAgIGNvbnN0IGxhYmVsQ291bnQgPSB0aGlzLl9wb2ludExhYmVscy5sZW5ndGg7XG5cbiAgICBsZXQgaSwgb2Zmc2V0LCBwb3NpdGlvbjtcblxuICAgIGlmIChvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGRyYXdQb2ludExhYmVscyh0aGlzLCBsYWJlbENvdW50KTtcbiAgICB9XG5cbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XG4gICAgICB0aGlzLnRpY2tzLmZvckVhY2goKHRpY2ssIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpbmRleCAhPT0gMCB8fCAoaW5kZXggPT09IDAgJiYgdGhpcy5taW4gPCAwKSkge1xuICAgICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGljay52YWx1ZSk7XG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChpbmRleCk7XG4gICAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXhCb3JkZXIgPSBib3JkZXIuc2V0Q29udGV4dChjb250ZXh0KTtcblxuICAgICAgICAgIGRyYXdSYWRpdXNMaW5lKHRoaXMsIG9wdHNBdEluZGV4LCBvZmZzZXQsIGxhYmVsQ291bnQsIG9wdHNBdEluZGV4Qm9yZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFuZ2xlTGluZXMuZGlzcGxheSkge1xuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgZm9yIChpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gYW5nbGVMaW5lcy5zZXRDb250ZXh0KHRoaXMuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgICAgICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBvcHRzQXRJbmRleDtcblxuICAgICAgICBpZiAoIWxpbmVXaWR0aCB8fCAhY29sb3IpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuXG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChvcHRzQXRJbmRleC5ib3JkZXJEYXNoKTtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcblxuICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG9wdHMudGlja3MucmV2ZXJzZSA/IHRoaXMubWluIDogdGhpcy5tYXgpO1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpLCBvZmZzZXQpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8odGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgICAgICBjdHgubGluZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdCb3JkZXIoKSB7fVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3TGFiZWxzKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG4gICAgaWYgKCF0aWNrT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZSgwKTtcbiAgICBsZXQgb2Zmc2V0LCB3aWR0aDtcblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XG4gICAgY3R4LnJvdGF0ZShzdGFydEFuZ2xlKTtcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKChpbmRleCA9PT0gMCAmJiB0aGlzLm1pbiA+PSAwKSAmJiAhb3B0cy5yZXZlcnNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSB0aWNrT3B0cy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLnZhbHVlKTtcblxuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgICB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aWNrLmxhYmVsKS53aWR0aDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3I7XG5cbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgLXdpZHRoIC8gMiAtIHBhZGRpbmcubGVmdCxcbiAgICAgICAgICAtb2Zmc2V0IC0gdGlja0ZvbnQuc2l6ZSAvIDIgLSBwYWRkaW5nLnRvcCxcbiAgICAgICAgICB3aWR0aCArIHBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgdGlja0ZvbnQuc2l6ZSArIHBhZGRpbmcuaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlclRleHQoY3R4LCB0aWNrLmxhYmVsLCAwLCAtb2Zmc2V0LCB0aWNrRm9udCwge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICAgIHN0cm9rZUNvbG9yOiBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlQ29sb3IsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlV2lkdGgsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd1RpdGxlKCkge31cbn1cbiIsICJpbXBvcnQgYWRhcHRlcnMgZnJvbSAnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJztcbmltcG9ydCB7Y2FsbGJhY2sgYXMgY2FsbCwgaXNGaW5pdGUsIGlzTnVsbE9yVW5kZWYsIG1lcmdlSWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvUmFkaWFucywgaXNOdW1iZXIsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7X2FycmF5VW5pcXVlLCBfZmlsdGVyQmV0d2VlbiwgX2xvb2t1cH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuYWRhcHRlcnMuanMnKS5UaW1lVW5pdCB9IFVuaXRcbiAqIEB0eXBlZGVmIHt7Y29tbW9uOiBib29sZWFuLCBzaXplOiBudW1iZXIsIHN0ZXBzPzogbnVtYmVyfX0gSW50ZXJ2YWxcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuYWRhcHRlcnMuanMnKS5EYXRlQWRhcHRlciB9IERhdGVBZGFwdGVyXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PFVuaXQsIEludGVydmFsPn1cbiAqL1xuY29uc3QgSU5URVJWQUxTID0ge1xuICBtaWxsaXNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMSwgc3RlcHM6IDEwMDB9LFxuICBzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEwMDAsIHN0ZXBzOiA2MH0sXG4gIG1pbnV0ZToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogNjAwMDAsIHN0ZXBzOiA2MH0sXG4gIGhvdXI6IHtjb21tb246IHRydWUsIHNpemU6IDM2MDAwMDAsIHN0ZXBzOiAyNH0sXG4gIGRheToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogODY0MDAwMDAsIHN0ZXBzOiAzMH0sXG4gIHdlZWs6IHtjb21tb246IGZhbHNlLCBzaXplOiA2MDQ4MDAwMDAsIHN0ZXBzOiA0fSxcbiAgbW9udGg6IHtjb21tb246IHRydWUsIHNpemU6IDIuNjI4ZTksIHN0ZXBzOiAxMn0sXG4gIHF1YXJ0ZXI6IHtjb21tb246IGZhbHNlLCBzaXplOiA3Ljg4NGU5LCBzdGVwczogNH0sXG4gIHllYXI6IHtjb21tb246IHRydWUsIHNpemU6IDMuMTU0ZTEwfVxufTtcblxuLyoqXG4gKiBAdHlwZSB7VW5pdFtdfVxuICovXG5jb25zdCBVTklUUyA9IC8qKiBAdHlwZSBVbml0W10gKi8gLyogI19fUFVSRV9fICovIChPYmplY3Qua2V5cyhJTlRFUlZBTFMpKTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqL1xuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHsqfSBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBwYXJzZShzY2FsZSwgaW5wdXQpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWYoaW5wdXQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IHtwYXJzZXIsIHJvdW5kLCBpc29XZWVrZGF5fSA9IHNjYWxlLl9wYXJzZU9wdHM7XG4gIGxldCB2YWx1ZSA9IGlucHV0O1xuXG4gIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuICB9XG5cbiAgLy8gT25seSBwYXJzZSBpZiBpdCdzIG5vdCBhIHRpbWVzdGFtcCBhbHJlYWR5XG4gIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgcGFyc2VyID09PSAnc3RyaW5nJ1xuICAgICAgPyBhZGFwdGVyLnBhcnNlKHZhbHVlLCAvKiogQHR5cGUge1VuaXR9ICovIChwYXJzZXIpKVxuICAgICAgOiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHJvdW5kKSB7XG4gICAgdmFsdWUgPSByb3VuZCA9PT0gJ3dlZWsnICYmIChpc051bWJlcihpc29XZWVrZGF5KSB8fCBpc29XZWVrZGF5ID09PSB0cnVlKVxuICAgICAgPyBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsICdpc29XZWVrJywgaXNvV2Vla2RheSlcbiAgICAgIDogYWRhcHRlci5zdGFydE9mKHZhbHVlLCByb3VuZCk7XG4gIH1cblxuICByZXR1cm4gK3ZhbHVlO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCByZXN1bHRzIGluIGFuIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhdXRvLWdlbmVyYXRlZCB0aWNrc1xuICogQHBhcmFtIHtVbml0fSBtaW5Vbml0XG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcGFyYW0ge251bWJlcn0gY2FwYWNpdHlcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcbiAgY29uc3QgaWxlbiA9IFVOSVRTLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG4gICAgY29uc3QgZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwcyA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gICAgaWYgKGludGVydmFsLmNvbW1vbiAmJiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoZmFjdG9yICogaW50ZXJ2YWwuc2l6ZSkpIDw9IGNhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcbn1cblxuLyoqXG4gKiBGaWd1cmVzIG91dCB3aGF0IHVuaXQgdG8gZm9ybWF0IGEgc2V0IG9mIHRpY2tzIHdpdGhcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IG51bVRpY2tzXG4gKiBAcGFyYW0ge1VuaXR9IG1pblVuaXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge1VuaXR9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHNjYWxlLCBudW1UaWNrcywgbWluVW5pdCwgbWluLCBtYXgpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmxlbmd0aCAtIDE7IGkgPj0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaS0tKSB7XG4gICAgY29uc3QgdW5pdCA9IFVOSVRTW2ldO1xuICAgIGlmIChJTlRFUlZBTFNbdW5pdF0uY29tbW9uICYmIHNjYWxlLl9hZGFwdGVyLmRpZmYobWF4LCBtaW4sIHVuaXQpID49IG51bVRpY2tzIC0gMSkge1xuICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XG59XG5cbi8qKlxuICogQHBhcmFtIHtVbml0fSB1bml0XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZU1ham9yVW5pdCh1bml0KSB7XG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKHVuaXQpICsgMSwgaWxlbiA9IFVOSVRTLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGlmIChJTlRFUlZBTFNbVU5JVFNbaV1dLmNvbW1vbikge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSB0aWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcbiAqIEBwYXJhbSB7bnVtYmVyW119IFt0aW1lc3RhbXBzXSAtIGlmIGRlZmluZWQsIHNuYXAgdG8gdGhlc2UgdGltZXN0YW1wc1xuICovXG5mdW5jdGlvbiBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKSB7XG4gIGlmICghdGltZXN0YW1wcykge1xuICAgIHRpY2tzW3RpbWVdID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgIGNvbnN0IHtsbywgaGl9ID0gX2xvb2t1cCh0aW1lc3RhbXBzLCB0aW1lKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2xvXSA+PSB0aW1lID8gdGltZXN0YW1wc1tsb10gOiB0aW1lc3RhbXBzW2hpXTtcbiAgICB0aWNrc1t0aW1lc3RhbXBdID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtvYmplY3RbXX0gdGlja3NcbiAqIEBwYXJhbSB7b2JqZWN0fSBtYXBcbiAqIEBwYXJhbSB7VW5pdH0gbWFqb3JVbml0XG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KSB7XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3QgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKHRpY2tzWzBdLnZhbHVlLCBtYWpvclVuaXQpO1xuICBjb25zdCBsYXN0ID0gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWU7XG4gIGxldCBtYWpvciwgaW5kZXg7XG5cbiAgZm9yIChtYWpvciA9IGZpcnN0OyBtYWpvciA8PSBsYXN0OyBtYWpvciA9ICthZGFwdGVyLmFkZChtYWpvciwgMSwgbWFqb3JVbml0KSkge1xuICAgIGluZGV4ID0gbWFwW21ham9yXTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGlja3NbaW5kZXhdLm1ham9yID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJbXX0gdmFsdWVzXG4gKiBAcGFyYW0ge1VuaXR8dW5kZWZpbmVkfSBbbWFqb3JVbml0XVxuICogQHJldHVybiB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIC8qKiBAdHlwZSB7T2JqZWN0PG51bWJlcixvYmplY3Q+fSAqL1xuICBjb25zdCBtYXAgPSB7fTtcbiAgY29uc3QgaWxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGxldCBpLCB2YWx1ZTtcblxuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgbWFwW3ZhbHVlXSA9IGk7XG5cbiAgICB0aWNrcy5wdXNoKHtcbiAgICAgIHZhbHVlLFxuICAgICAgbWFqb3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvLyBXZSBzZXQgdGhlIG1ham9yIHRpY2tzIHNlcGFyYXRlbHkgZnJvbSB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIGNhbGxpbmcgc3RhcnRPZiBmb3IgZXZlcnkgdGlja1xuICAvLyBpcyBleHBlbnNpdmUgd2hlbiB0aGVyZSBpcyBhIGxhcmdlIG51bWJlciBvZiB0aWNrc1xuICByZXR1cm4gKGlsZW4gPT09IDAgfHwgIW1ham9yVW5pdCkgPyB0aWNrcyA6IHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVTY2FsZSBleHRlbmRzIFNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAndGltZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogU2NhbGUgYm91bmRhcnkgc3RyYXRlZ3kgKGJ5cGFzc2VkIGJ5IG1pbi9tYXggdGltZSBvcHRpb25zKVxuICAgICAqIC0gYGRhdGFgOiBtYWtlIHN1cmUgZGF0YSBhcmUgZnVsbHkgdmlzaWJsZSwgdGlja3Mgb3V0c2lkZSBhcmUgcmVtb3ZlZFxuICAgICAqIC0gYHRpY2tzYDogbWFrZSBzdXJlIHRpY2tzIGFyZSBmdWxseSB2aXNpYmxlLCBkYXRhIG91dHNpZGUgYXJlIHRydW5jYXRlZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTU2XG4gICAgICogQHNpbmNlIDIuNy4wXG4gICAgICovXG4gICAgYm91bmRzOiAnZGF0YScsXG5cbiAgICBhZGFwdGVyczoge30sXG4gICAgdGltZToge1xuICAgICAgcGFyc2VyOiBmYWxzZSwgLy8gZmFsc2UgPT0gYSBwYXR0ZXJuIHN0cmluZyBmcm9tIG9yIGEgY3VzdG9tIGNhbGxiYWNrIHRoYXQgY29udmVydHMgaXRzIGFyZ3VtZW50IHRvIGEgdGltZXN0YW1wXG4gICAgICB1bml0OiBmYWxzZSwgLy8gZmFsc2UgPT0gYXV0b21hdGljIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cbiAgICAgIHJvdW5kOiBmYWxzZSwgLy8gbm9uZSwgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuICAgICAgaXNvV2Vla2RheTogZmFsc2UsIC8vIG92ZXJyaWRlIHdlZWsgc3RhcnQgZGF5XG4gICAgICBtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxuICAgICAgZGlzcGxheUZvcm1hdHM6IHt9XG4gICAgfSxcbiAgICB0aWNrczoge1xuICAgICAgLyoqXG4gICAgICAgKiBUaWNrcyBnZW5lcmF0aW9uIGlucHV0IHZhbHVlczpcbiAgICAgICAqIC0gJ2F1dG8nOiBnZW5lcmF0ZXMgXCJvcHRpbWFsXCIgdGlja3MgYmFzZWQgb24gc2NhbGUgc2l6ZSBhbmQgdGltZSBvcHRpb25zLlxuICAgICAgICogLSAnZGF0YSc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIGRhdGEgKGluY2x1ZGluZyBsYWJlbHMgZnJvbSBkYXRhIHt0fHh8eX0gb2JqZWN0cykuXG4gICAgICAgKiAtICdsYWJlbHMnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSB1c2VyIGdpdmVuIGBkYXRhLmxhYmVsc2AgdmFsdWVzIE9OTFkuXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xuICAgICAgICogQHNpbmNlIDIuNy4wXG4gICAgICAgKi9cbiAgICAgIHNvdXJjZTogJ2F1dG8nLFxuXG4gICAgICBjYWxsYmFjazogZmFsc2UsXG5cbiAgICAgIG1ham9yOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcblx0ICovXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgLyoqIEB0eXBlIHt7ZGF0YTogbnVtYmVyW10sIGxhYmVsczogbnVtYmVyW10sIGFsbDogbnVtYmVyW119fSAqL1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG5cbiAgICAvKiogQHR5cGUge1VuaXR9ICovXG4gICAgdGhpcy5fdW5pdCA9ICdkYXknO1xuICAgIC8qKiBAdHlwZSB7VW5pdD19ICovXG4gICAgdGhpcy5fbWFqb3JVbml0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29mZnNldHMgPSB7fTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaW5pdChzY2FsZU9wdHMsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHRpbWUgPSBzY2FsZU9wdHMudGltZSB8fCAoc2NhbGVPcHRzLnRpbWUgPSB7fSk7XG4gICAgLyoqIEB0eXBlIHtEYXRlQWRhcHRlcn0gKi9cbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlciA9IG5ldyBhZGFwdGVycy5fZGF0ZShzY2FsZU9wdHMuYWRhcHRlcnMuZGF0ZSk7XG5cbiAgICBhZGFwdGVyLmluaXQob3B0cyk7XG5cbiAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBiZWZvcmUgaW50cm9kdWNpbmcgYWRhcHRlciwgYGRpc3BsYXlGb3JtYXRzYCB3YXNcbiAgICAvLyBzdXBwb3NlZCB0byBjb250YWluICphbGwqIHVuaXQvc3RyaW5nIHBhaXJzIGJ1dCB0aGlzIGNhbid0IGJlIHJlc29sdmVkXG4gICAgLy8gd2hlbiBsb2FkaW5nIHRoZSBzY2FsZSAoYWRhcHRlcnMgYXJlIGxvYWRlZCBhZnRlcndhcmQpLCBzbyBsZXQncyBwb3B1bGF0ZVxuICAgIC8vIG1pc3NpbmcgZm9ybWF0cyBvbiB1cGRhdGVcbiAgICBtZXJnZUlmKHRpbWUuZGlzcGxheUZvcm1hdHMsIGFkYXB0ZXIuZm9ybWF0cygpKTtcblxuICAgIHRoaXMuX3BhcnNlT3B0cyA9IHtcbiAgICAgIHBhcnNlcjogdGltZS5wYXJzZXIsXG4gICAgICByb3VuZDogdGltZS5yb3VuZCxcbiAgICAgIGlzb1dlZWtkYXk6IHRpbWUuaXNvV2Vla2RheVxuICAgIH07XG5cbiAgICBzdXBlci5pbml0KHNjYWxlT3B0cyk7XG5cbiAgICB0aGlzLl9ub3JtYWxpemVkID0gb3B0cy5ub3JtYWxpemVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Kn0gcmF3XG5cdCAqIEBwYXJhbSB7bnVtYmVyP30gW2luZGV4XVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAocmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2UodGhpcywgcmF3KTtcbiAgfVxuXG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICBzdXBlci5iZWZvcmVMYXlvdXQoKTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHVuaXQgPSBvcHRpb25zLnRpbWUudW5pdCB8fCAnZGF5JztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcblxuICAgIC8qKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBib3VuZHNcblx0XHQgKi9cbiAgICBmdW5jdGlvbiBfYXBwbHlCb3VuZHMoYm91bmRzKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5taW4pKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgYm91bmRzLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5tYXgpKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgYm91bmRzLm1heCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSB1c2VyIHByb3ZpZGVkIGBtaW5gIGFuZCBgbWF4YCBsYWJlbHMgLyBkYXRhIGJvdW5kcyBjYW4gYmUgaWdub3JlZFxuICAgIGlmICghbWluRGVmaW5lZCB8fCAhbWF4RGVmaW5lZCkge1xuICAgICAgLy8gTGFiZWxzIGFyZSBhbHdheXMgY29uc2lkZXJlZCwgd2hlbiB1c2VyIGRpZCBub3QgZm9yY2UgYm91bmRzXG4gICAgICBfYXBwbHlCb3VuZHModGhpcy5fZ2V0TGFiZWxCb3VuZHMoKSk7XG5cbiAgICAgIC8vIElmIGBib3VuZHNgIGlzIGAndGlja3MnYCBhbmQgYHRpY2tzLnNvdXJjZWAgaXMgYCdsYWJlbHMnYCxcbiAgICAgIC8vIGRhdGEgYm91bmRzIGFyZSBpZ25vcmVkIChhbmQgZG9uJ3QgbmVlZCB0byBiZSBkZXRlcm1pbmVkKVxuICAgICAgaWYgKG9wdGlvbnMuYm91bmRzICE9PSAndGlja3MnIHx8IG9wdGlvbnMudGlja3Muc291cmNlICE9PSAnbGFiZWxzJykge1xuICAgICAgICBfYXBwbHlCb3VuZHModGhpcy5nZXRNaW5NYXgoZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtaW4gPSBpc0Zpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KTtcbiAgICBtYXggPSBpc0Zpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogK2FkYXB0ZXIuZW5kT2YoRGF0ZS5ub3coKSwgdW5pdCkgKyAxO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgbWF4IGlzIHN0cmljdGx5IGhpZ2hlciB0aGFuIG1pbiAocmVxdWlyZWQgYnkgdGhlIHRpbWVzZXJpZXMgbG9va3VwIHRhYmxlKVxuICAgIHRoaXMubWluID0gTWF0aC5taW4obWluLCBtYXggLSAxKTtcbiAgICB0aGlzLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbEJvdW5kcygpIHtcbiAgICBjb25zdCBhcnIgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGxldCBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICAgIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgICBtaW4gPSBhcnJbMF07XG4gICAgICBtYXggPSBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2xhYmVscycgPyB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpIDogdGhpcy5fZ2VuZXJhdGUoKTtcblxuICAgIGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgdGhpcy5taW4gPSB0aGlzLl91c2VyTWluIHx8IHRpbWVzdGFtcHNbMF07XG4gICAgICB0aGlzLm1heCA9IHRoaXMuX3VzZXJNYXggfHwgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuXG4gICAgY29uc3QgdGlja3MgPSBfZmlsdGVyQmV0d2Vlbih0aW1lc3RhbXBzLCBtaW4sIG1heCk7XG5cbiAgICAvLyBQUklWQVRFXG4gICAgLy8gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcgcmVsaWVzIG9uIHRoZSBudW1iZXIgb2YgdGlja3Mgc28gd2UgZG9uJ3QgdXNlIGl0IHdoZW5cbiAgICAvLyBhdXRvU2tpcCBpcyBlbmFibGVkIGJlY2F1c2Ugd2UgZG9uJ3QgeWV0IGtub3cgd2hhdCB0aGUgZmluYWwgbnVtYmVyIG9mIHRpY2tzIHdpbGwgYmVcbiAgICB0aGlzLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCAodGlja09wdHMuYXV0b1NraXBcbiAgICAgID8gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSlcbiAgICAgIDogZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcodGhpcywgdGlja3MubGVuZ3RoLCB0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgpKTtcbiAgICB0aGlzLl9tYWpvclVuaXQgPSAhdGlja09wdHMubWFqb3IuZW5hYmxlZCB8fCB0aGlzLl91bml0ID09PSAneWVhcicgPyB1bmRlZmluZWRcbiAgICAgIDogZGV0ZXJtaW5lTWFqb3JVbml0KHRoaXMuX3VuaXQpO1xuICAgIHRoaXMuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG5cbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgdGlja3MsIHRoaXMuX21ham9yVW5pdCk7XG4gIH1cblxuICBhZnRlckF1dG9Ta2lwKCkge1xuICAgIC8vIE9mZnNldHMgZm9yIGJhciBjaGFydHMgbmVlZCB0byBiZSBoYW5kbGVkIHdpdGggdGhlIGF1dG8gc2tpcHBlZFxuICAgIC8vIHRpY2tzLiBPbmNlIHRpY2tzIGhhdmUgYmVlbiBza2lwcGVkLCB3ZSByZS1jb21wdXRlIHRoZSBvZmZzZXRzLlxuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0QWZ0ZXJBdXRvc2tpcCkge1xuICAgICAgdGhpcy5pbml0T2Zmc2V0cyh0aGlzLnRpY2tzLm1hcCh0aWNrID0+ICt0aWNrLnZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cyBmcm9tIGVkZ2VzIGluIHRoZSBmb3JtIG9mIHtzdGFydCwgZW5kfVxuXHQgKiB3aGVyZSBlYWNoIHZhbHVlIGlzIGEgcmVsYXRpdmUgd2lkdGggdG8gdGhlIHNjYWxlIGFuZCByYW5nZXMgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBUaGV5IGFkZCBleHRyYSBtYXJnaW5zIG9uIHRoZSBib3RoIHNpZGVzIGJ5IHNjYWxpbmcgZG93biB0aGUgb3JpZ2luYWwgc2NhbGUuXG5cdCAqIE9mZnNldHMgYXJlIGFkZGVkIHdoZW4gdGhlIGBvZmZzZXRgIG9wdGlvbiBpcyB0cnVlLlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB0aW1lc3RhbXBzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluaXRPZmZzZXRzKHRpbWVzdGFtcHMgPSBbXSkge1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IDA7XG4gICAgbGV0IGZpcnN0LCBsYXN0O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIGZpcnN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1swXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSAxIC0gZmlyc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9ICh0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzFdKSAtIGZpcnN0KSAvIDI7XG4gICAgICB9XG4gICAgICBsYXN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbmQgPSBsYXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gKGxhc3QgLSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0pKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdGltZXN0YW1wcy5sZW5ndGggPCAzID8gMC41IDogMC4yNTtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKHN0YXJ0LCAwLCBsaW1pdCk7XG4gICAgZW5kID0gX2xpbWl0VmFsdWUoZW5kLCAwLCBsaW1pdCk7XG5cbiAgICB0aGlzLl9vZmZzZXRzID0ge3N0YXJ0LCBlbmQsIGZhY3RvcjogMSAvIChzdGFydCArIDEgKyBlbmQpfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBtYXhpbXVtIG9mIGBjYXBhY2l0eWAgdGltZXN0YW1wcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCByb3VuZGVkIHRvIHRoZVxuXHQgKiBgbWlub3JgIHVuaXQgdXNpbmcgdGhlIGdpdmVuIHNjYWxlIHRpbWUgYG9wdGlvbnNgLlxuXHQgKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG5cdCAqIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsaW5nIGNvZGUgdG8gY2xhbXAgdmFsdWVzIGlmIG5lZWRlZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgX2dlbmVyYXRlKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG1pbm9yID0gdGltZU9wdHMudW5pdCB8fCBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIG1pbiwgbWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpO1xuICAgIGNvbnN0IHN0ZXBTaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5zdGVwU2l6ZSwgMSk7XG4gICAgY29uc3Qgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XG4gICAgY29uc3QgaGFzV2Vla2RheSA9IGlzTnVtYmVyKHdlZWtkYXkpIHx8IHdlZWtkYXkgPT09IHRydWU7XG4gICAgY29uc3QgdGlja3MgPSB7fTtcbiAgICBsZXQgZmlyc3QgPSBtaW47XG4gICAgbGV0IHRpbWUsIGNvdW50O1xuXG4gICAgLy8gRm9yICd3ZWVrJyB1bml0LCBoYW5kbGUgdGhlIGZpcnN0IGRheSBvZiB3ZWVrIG9wdGlvblxuICAgIGlmIChoYXNXZWVrZGF5KSB7XG4gICAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsICdpc29XZWVrJywgd2Vla2RheSk7XG4gICAgfVxuXG4gICAgLy8gQWxpZ24gZmlyc3QgdGlja3Mgb24gdW5pdFxuICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgaGFzV2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuXG4gICAgLy8gUHJldmVudCBicm93c2VyIGZyb20gZnJlZXppbmcgaW4gY2FzZSB1c2VyIG9wdGlvbnMgcmVxdWVzdCBtaWxsaW9ucyBvZiBtaWxsaXNlY29uZHNcbiAgICBpZiAoYWRhcHRlci5kaWZmKG1heCwgbWluLCBtaW5vcikgPiAxMDAwMDAgKiBzdGVwU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1pbiArICcgYW5kICcgKyBtYXggKyAnIGFyZSB0b28gZmFyIGFwYXJ0IHdpdGggc3RlcFNpemUgb2YgJyArIHN0ZXBTaXplICsgJyAnICsgbWlub3IpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBvcHRpb25zLnRpY2tzLnNvdXJjZSA9PT0gJ2RhdGEnICYmIHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBmb3IgKHRpbWUgPSBmaXJzdCwgY291bnQgPSAwOyB0aW1lIDwgbWF4OyB0aW1lID0gK2FkYXB0ZXIuYWRkKHRpbWUsIHN0ZXBTaXplLCBtaW5vciksIGNvdW50KyspIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cblxuICAgIGlmICh0aW1lID09PSBtYXggfHwgb3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgfHwgY291bnQgPT09IDEpIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGlja3MpLnNvcnQoc29ydGVyKS5tYXAoeCA9PiAreCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuXG4gICAgaWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcbiAgICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMuZGlzcGxheUZvcm1hdHMuZGF0ZXRpbWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGZvcm1hdFxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBmb3JtYXQodmFsdWUsIGZvcm1hdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcbiAgICBjb25zdCBmbXQgPSBmb3JtYXQgfHwgZm9ybWF0c1t1bml0XTtcbiAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodmFsdWUsIGZtdCk7XG4gIH1cblxuICAvKipcblx0ICogRnVuY3Rpb24gdG8gZm9ybWF0IGFuIGluZGl2aWR1YWwgdGljayBtYXJrXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuXHQgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IFtmb3JtYXRdXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF90aWNrRm9ybWF0RnVuY3Rpb24odGltZSwgaW5kZXgsIHRpY2tzLCBmb3JtYXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IG9wdGlvbnMudGlja3MuY2FsbGJhY2s7XG5cbiAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gY2FsbChmb3JtYXR0ZXIsIFt0aW1lLCBpbmRleCwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IHVuaXQgPSB0aGlzLl91bml0O1xuICAgIGNvbnN0IG1ham9yVW5pdCA9IHRoaXMuX21ham9yVW5pdDtcbiAgICBjb25zdCBtaW5vckZvcm1hdCA9IHVuaXQgJiYgZm9ybWF0c1t1bml0XTtcbiAgICBjb25zdCBtYWpvckZvcm1hdCA9IG1ham9yVW5pdCAmJiBmb3JtYXRzW21ham9yVW5pdF07XG4gICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICBjb25zdCBtYWpvciA9IG1ham9yVW5pdCAmJiBtYWpvckZvcm1hdCAmJiB0aWNrICYmIHRpY2subWFqb3I7XG5cbiAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0IHx8IChtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuXHQgKi9cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKHRpY2sudmFsdWUsIGksIHRpY2tzKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBNaWxsaXNlY29uZHMgc2luY2UgZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQylcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKG9mZnNldHMuc3RhcnQgKyBwb3MpICogb2Zmc2V0cy5mYWN0b3IpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gdGhpcy5taW4gKyBwb3MgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG5cdCAqIEByZXR1cm4ge3t3Om51bWJlciwgaDpudW1iZXJ9fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsU2l6ZShsYWJlbCkge1xuICAgIGNvbnN0IHRpY2tzT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aWNrTGFiZWxXaWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICBjb25zdCBhbmdsZSA9IHRvUmFkaWFucyh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGlja3NPcHRzLm1heFJvdGF0aW9uIDogdGlja3NPcHRzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB0aWNrRm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLnNpemU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdzogKHRpY2tMYWJlbFdpZHRoICogY29zUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIHNpblJvdGF0aW9uKSxcbiAgICAgIGg6ICh0aWNrTGFiZWxXaWR0aCAqIHNpblJvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBjb3NSb3RhdGlvbilcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBleGFtcGxlVGltZVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxDYXBhY2l0eShleGFtcGxlVGltZSkge1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgY29uc3QgZGlzcGxheUZvcm1hdHMgPSB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cztcblxuICAgIC8vIHBpY2sgdGhlIGxvbmdlc3QgZm9ybWF0IChtaWxsaXNlY29uZHMpIGZvciBndWVzc3RpbWF0aW9uXG4gICAgY29uc3QgZm9ybWF0ID0gZGlzcGxheUZvcm1hdHNbdGltZU9wdHMudW5pdF0gfHwgZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG4gICAgY29uc3QgZXhhbXBsZUxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIFtleGFtcGxlVGltZV0sIHRoaXMuX21ham9yVW5pdCksIGZvcm1hdCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xuICAgIC8vIHN1YnRyYWN0IDEgLSBpZiBvZmZzZXQgdGhlbiB0aGVyZSdzIG9uZSBsZXNzIGxhYmVsIHRoYW4gdGlja1xuICAgIC8vIGlmIG5vdCBvZmZzZXQgdGhlbiBvbmUgaGFsZiBsYWJlbCBwYWRkaW5nIGlzIGFkZGVkIHRvIGVhY2ggZW5kIGxlYXZpbmcgcm9vbSBmb3Igb25lIGxlc3MgbGFiZWxcbiAgICBjb25zdCBjYXBhY2l0eSA9IE1hdGguZmxvb3IodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggLyBzaXplLncgOiB0aGlzLmhlaWdodCAvIHNpemUuaCkgLSAxO1xuICAgIHJldHVybiBjYXBhY2l0eSA+IDAgPyBjYXBhY2l0eSA6IDE7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0RGF0YVRpbWVzdGFtcHMoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5kYXRhIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcblxuICAgIGlmICh0aGlzLl9ub3JtYWxpemVkICYmIG1ldGFzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gbWV0YXNbMF0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmNvbmNhdChtZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsVGltZXN0YW1wcygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUubGFiZWxzIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gocGFyc2UodGhpcywgbGFiZWxzW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5sYWJlbHMgPSB0aGlzLl9ub3JtYWxpemVkID8gdGltZXN0YW1wcyA6IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB2YWx1ZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgbm9ybWFsaXplKHZhbHVlcykge1xuICAgIC8vIEl0IHNlZW1zIHRvIGJlIHNvbWV3aGF0IGZhc3RlciB0byBkbyBzb3J0aW5nIGZpcnN0XG4gICAgcmV0dXJuIF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydChzb3J0ZXIpKTtcbiAgfVxufVxuIiwgImltcG9ydCBUaW1lU2NhbGUgZnJvbSAnLi9zY2FsZS50aW1lLmpzJztcbmltcG9ydCB7X2xvb2t1cEJ5S2V5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5cbi8qKlxuICogTGluZWFybHkgaW50ZXJwb2xhdGVzIHRoZSBnaXZlbiBzb3VyY2UgYHZhbGAgdXNpbmcgdGhlIHRhYmxlLiBJZiB2YWx1ZSBpcyBvdXQgb2YgYm91bmRzLCB2YWx1ZXNcbiAqIGF0IGVkZ2VzIGFyZSB1c2VkIGZvciB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0YWJsZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZV0gbG9va3VwIHRpbWUgYmFzZWQgb24gcG9zaXRpb24gaW5zdGVhZCBvZiB2aWNlIHZlcnNhXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlKHRhYmxlLCB2YWwsIHJldmVyc2UpIHtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIHByZXZUYXJnZXQsIG5leHRUYXJnZXQ7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10ucG9zICYmIHZhbCA8PSB0YWJsZVtoaV0ucG9zKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICdwb3MnLCB2YWwpKTtcbiAgICB9XG4gICAgKHtwb3M6IHByZXZTb3VyY2UsIHRpbWU6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3BvczogbmV4dFNvdXJjZSwgdGltZTogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnRpbWUgJiYgdmFsIDw9IHRhYmxlW2hpXS50aW1lKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICd0aW1lJywgdmFsKSk7XG4gICAgfVxuICAgICh7dGltZTogcHJldlNvdXJjZSwgcG9zOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHt0aW1lOiBuZXh0U291cmNlLCBwb3M6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfVxuXG4gIGNvbnN0IHNwYW4gPSBuZXh0U291cmNlIC0gcHJldlNvdXJjZTtcbiAgcmV0dXJuIHNwYW4gPyBwcmV2VGFyZ2V0ICsgKG5leHRUYXJnZXQgLSBwcmV2VGFyZ2V0KSAqICh2YWwgLSBwcmV2U291cmNlKSAvIHNwYW4gOiBwcmV2VGFyZ2V0O1xufVxuXG5jbGFzcyBUaW1lU2VyaWVzU2NhbGUgZXh0ZW5kcyBUaW1lU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICd0aW1lc2VyaWVzJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IFRpbWVTY2FsZS5kZWZhdWx0cztcblxuICAvKipcblx0ICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIC8qKiBAdHlwZSB7b2JqZWN0W119ICovXG4gICAgdGhpcy5fdGFibGUgPSBbXTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9taW5Qb3MgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBpbml0T2Zmc2V0cygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCk7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLl90YWJsZSA9IHRoaXMuYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKTtcbiAgICB0aGlzLl9taW5Qb3MgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5taW4pO1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5tYXgpIC0gdGhpcy5fbWluUG9zO1xuICAgIHN1cGVyLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2Yge3RpbWUsIHBvc30gb2JqZWN0cyB1c2VkIHRvIGludGVycG9sYXRlIGEgc3BlY2lmaWMgYHRpbWVgIG9yIHBvc2l0aW9uXG5cdCAqIChgcG9zYCkgb24gdGhlIHNjYWxlLCBieSBzZWFyY2hpbmcgZW50cmllcyBiZWZvcmUgYW5kIGFmdGVyIHRoZSByZXF1ZXN0ZWQgdmFsdWUuIGBwb3NgIGlzXG5cdCAqIGEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDE6IDAgYmVpbmcgdGhlIHN0YXJ0IG9mIHRoZSBzY2FsZSAobGVmdCBvciB0b3ApIGFuZCAxIHRoZSBvdGhlclxuXHQgKiBleHRyZW1pdHkgKGxlZnQgKyB3aWR0aCBvciB0b3AgKyBoZWlnaHQpLiBOb3RlIHRoYXQgaXQgd291bGQgYmUgbW9yZSBvcHRpbWl6ZWQgdG8gZGlyZWN0bHlcblx0ICogc3RvcmUgcHJlLWNvbXB1dGVkIHBpeGVscywgYnV0IHRoZSBzY2FsZSBkaW1lbnNpb25zIGFyZSBub3QgZ3VhcmFudGVlZCBhdCB0aGUgdGltZSB3ZSBuZWVkXG5cdCAqIHRvIGNyZWF0ZSB0aGUgbG9va3VwIHRhYmxlLiBUaGUgdGFibGUgQUxXQVlTIGNvbnRhaW5zIGF0IGxlYXN0IHR3byBpdGVtczogbWluIGFuZCBtYXguXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IHRpbWVzdGFtcHNcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcykge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgdGFibGUgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgcHJldiwgY3VyciwgbmV4dDtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY3VyciA9IHRpbWVzdGFtcHNbaV07XG4gICAgICBpZiAoY3VyciA+PSBtaW4gJiYgY3VyciA8PSBtYXgpIHtcbiAgICAgICAgaXRlbXMucHVzaChjdXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMikge1xuICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBsZXNzIHRoYXQgMiB0aW1lc3RhbXBzIGJldHdlZW4gbWluIGFuZCBtYXgsIHRoZSBzY2FsZSBpcyBkZWZpbmVkIGJ5IG1pbiBhbmQgbWF4XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7dGltZTogbWluLCBwb3M6IDB9LFxuICAgICAgICB7dGltZTogbWF4LCBwb3M6IDF9XG4gICAgICBdO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG5leHQgPSBpdGVtc1tpICsgMV07XG4gICAgICBwcmV2ID0gaXRlbXNbaSAtIDFdO1xuICAgICAgY3VyciA9IGl0ZW1zW2ldO1xuXG4gICAgICAvLyBvbmx5IGFkZCBwb2ludHMgdGhhdCBicmVha3MgdGhlIHNjYWxlIGxpbmVhcml0eVxuICAgICAgaWYgKE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG4gICAgICAgIHRhYmxlLnB1c2goe3RpbWU6IGN1cnIsIHBvczogaSAvIChpbGVuIC0gMSl9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG5cbiAgLyoqXG4gICAgKiBHZW5lcmF0ZXMgYWxsIHRpbWVzdGFtcHMgZGVmaW5lZCBpbiB0aGUgZGF0YS5cbiAgICAqIEltcG9ydGFudDogdGhpcyBtZXRob2QgY2FuIHJldHVybiB0aWNrcyBvdXRzaWRlIHRoZSBtaW4gYW5kIG1heCByYW5nZSwgaXQncyB0aGVcbiAgICAqIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsaW5nIGNvZGUgdG8gY2xhbXAgdmFsdWVzIGlmIG5lZWRlZC5cbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqL1xuICBfZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSBzdXBlci5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGlmICghdGltZXN0YW1wcy5pbmNsdWRlcyhtaW4pIHx8ICF0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgdGltZXN0YW1wcy5zcGxpY2UoMCwgMCwgbWluKTtcbiAgICB9XG4gICAgaWYgKCF0aW1lc3RhbXBzLmluY2x1ZGVzKG1heCkgfHwgdGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRpbWVzdGFtcHMucHVzaChtYXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGltZXN0YW1wcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhbGwgdGltZXN0YW1wc1xuXHQgKiBAcmV0dXJuIHtudW1iZXJbXX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgfHwgW107XG5cbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGlmIChkYXRhLmxlbmd0aCAmJiBsYWJlbC5sZW5ndGgpIHtcbiAgICAgIC8vIElmIGNvbWJpbmluZyBsYWJlbHMgYW5kIGRhdGEgKGRhdGEgbWlnaHQgbm90IGNvbnRhaW4gYWxsIGxhYmVscyksXG4gICAgICAvLyB3ZSBuZWVkIHRvIHJlY2hlY2sgdW5pcXVlbmVzcyBhbmQgc29ydFxuICAgICAgdGltZXN0YW1wcyA9IHRoaXMubm9ybWFsaXplKGRhdGEuY29uY2F0KGxhYmVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVzdGFtcHMgPSBkYXRhLmxlbmd0aCA/IGRhdGEgOiBsYWJlbDtcbiAgICB9XG4gICAgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCA9IHRpbWVzdGFtcHM7XG5cbiAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBNaWxsaXNlY29uZHMgc2luY2UgZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQylcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgdmFsdWUpIC0gdGhpcy5fbWluUG9zKSAvIHRoaXMuX3RhYmxlUmFuZ2U7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIGRlY2ltYWwgKiB0aGlzLl90YWJsZVJhbmdlICsgdGhpcy5fbWluUG9zLCB0cnVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lU2VyaWVzU2NhbGU7XG4iLCAiZXhwb3J0ICogZnJvbSAnLi9jb250cm9sbGVycy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbGVtZW50cy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3BsYXRmb3JtL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vcGx1Z2lucy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3NjYWxlcy9pbmRleC5qcyc7XG5cbmltcG9ydCAqIGFzIGNvbnRyb2xsZXJzIGZyb20gJy4vY29udHJvbGxlcnMvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgZWxlbWVudHMgZnJvbSAnLi9lbGVtZW50cy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBwbHVnaW5zIGZyb20gJy4vcGx1Z2lucy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBzY2FsZXMgZnJvbSAnLi9zY2FsZXMvaW5kZXguanMnO1xuXG5leHBvcnQge1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbn07XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlcmFibGVzID0gW1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbl07XG4iLCAiaW1wb3J0IHtDaGFydCwgcmVnaXN0ZXJhYmxlc30gZnJvbSAnLi4vZGlzdC9jaGFydC5qcyc7XG5cbkNoYXJ0LnJlZ2lzdGVyKC4uLnJlZ2lzdGVyYWJsZXMpO1xuXG5leHBvcnQgKiBmcm9tICcuLi9kaXN0L2NoYXJ0LmpzJztcbmV4cG9ydCBkZWZhdWx0IENoYXJ0O1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBQW1EOzs7QUNNbkQsU0FBUyxNQUFNLEdBQUc7QUFDaEIsU0FBTyxJQUFJLE1BQU07QUFDbkI7QUFDQSxJQUFNLE1BQU0sQ0FBQyxHQUFHLEdBQUcsTUFBTSxLQUFLLElBQUksS0FBSyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUM7QUFDbkQsU0FBUyxJQUFJLEdBQUc7QUFDZCxTQUFPLElBQUksTUFBTSxJQUFJLElBQUksR0FBRyxHQUFHLEdBQUc7QUFDcEM7QUFJQSxTQUFTLElBQUksR0FBRztBQUNkLFNBQU8sSUFBSSxNQUFNLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRztBQUNuQztBQUNBLFNBQVMsSUFBSSxHQUFHO0FBQ2QsU0FBTyxJQUFJLE1BQU0sSUFBSSxJQUFJLElBQUksS0FBSyxHQUFHLENBQUM7QUFDeEM7QUFDQSxTQUFTLElBQUksR0FBRztBQUNkLFNBQU8sSUFBSSxNQUFNLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRztBQUNuQztBQUVBLElBQU0sUUFBUSxFQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsR0FBRTtBQUM3SixJQUFNLE1BQU0sQ0FBQyxHQUFHLGtCQUFrQjtBQUNsQyxJQUFNLEtBQUssT0FBSyxJQUFJLElBQUksRUFBRztBQUMzQixJQUFNLEtBQUssT0FBSyxLQUFLLElBQUksUUFBUyxDQUFDLElBQUksSUFBSSxJQUFJLEVBQUc7QUFDbEQsSUFBTSxLQUFLLFFBQU8sSUFBSSxRQUFTLE9BQVEsSUFBSTtBQUMzQyxJQUFNLFVBQVUsT0FBSyxHQUFHLEVBQUUsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUM1RCxTQUFTLFNBQVMsS0FBSztBQUNyQixNQUFJLE1BQU0sSUFBSTtBQUNkLE1BQUk7QUFDSixNQUFJLElBQUksQ0FBQyxNQUFNLEtBQUs7QUFDbEIsUUFBSSxRQUFRLEtBQUssUUFBUSxHQUFHO0FBQzFCLFlBQU07QUFBQSxRQUNKLEdBQUcsTUFBTSxNQUFNLElBQUksQ0FBQyxDQUFDLElBQUk7QUFBQSxRQUN6QixHQUFHLE1BQU0sTUFBTSxJQUFJLENBQUMsQ0FBQyxJQUFJO0FBQUEsUUFDekIsR0FBRyxNQUFNLE1BQU0sSUFBSSxDQUFDLENBQUMsSUFBSTtBQUFBLFFBQ3pCLEdBQUcsUUFBUSxJQUFJLE1BQU0sSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLO0FBQUEsTUFDdEM7QUFBQSxJQUNGLFdBQVcsUUFBUSxLQUFLLFFBQVEsR0FBRztBQUNqQyxZQUFNO0FBQUEsUUFDSixHQUFHLE1BQU0sSUFBSSxDQUFDLENBQUMsS0FBSyxJQUFJLE1BQU0sSUFBSSxDQUFDLENBQUM7QUFBQSxRQUNwQyxHQUFHLE1BQU0sSUFBSSxDQUFDLENBQUMsS0FBSyxJQUFJLE1BQU0sSUFBSSxDQUFDLENBQUM7QUFBQSxRQUNwQyxHQUFHLE1BQU0sSUFBSSxDQUFDLENBQUMsS0FBSyxJQUFJLE1BQU0sSUFBSSxDQUFDLENBQUM7QUFBQSxRQUNwQyxHQUFHLFFBQVEsSUFBSyxNQUFNLElBQUksQ0FBQyxDQUFDLEtBQUssSUFBSSxNQUFNLElBQUksQ0FBQyxDQUFDLElBQUs7QUFBQSxNQUN4RDtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsU0FBTztBQUNUO0FBQ0EsSUFBTSxRQUFRLENBQUMsR0FBRyxNQUFNLElBQUksTUFBTSxFQUFFLENBQUMsSUFBSTtBQUN6QyxTQUFTLFVBQVUsR0FBRztBQUNwQixNQUFJLElBQUksUUFBUSxDQUFDLElBQUksS0FBSztBQUMxQixTQUFPLElBQ0gsTUFBTSxFQUFFLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxNQUFNLEVBQUUsR0FBRyxDQUFDLElBQzdDO0FBQ047QUFFQSxJQUFNLFNBQVM7QUFDZixTQUFTLFNBQVMsR0FBRyxHQUFHLEdBQUc7QUFDekIsUUFBTSxJQUFJLElBQUksS0FBSyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQy9CLFFBQU0sSUFBSSxDQUFDLEdBQUcsS0FBSyxJQUFJLElBQUksTUFBTSxPQUFPLElBQUksSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLEVBQUU7QUFDdEYsU0FBTyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQzFCO0FBQ0EsU0FBUyxTQUFTLEdBQUcsR0FBRyxHQUFHO0FBQ3pCLFFBQU0sSUFBSSxDQUFDLEdBQUcsS0FBSyxJQUFJLElBQUksTUFBTSxNQUFNLElBQUksSUFBSSxJQUFJLEtBQUssSUFBSSxLQUFLLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUM7QUFDcEYsU0FBTyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQzFCO0FBQ0EsU0FBUyxTQUFTLEdBQUcsR0FBRyxHQUFHO0FBQ3pCLFFBQU0sTUFBTSxTQUFTLEdBQUcsR0FBRyxHQUFHO0FBQzlCLE1BQUk7QUFDSixNQUFJLElBQUksSUFBSSxHQUFHO0FBQ2IsUUFBSSxLQUFLLElBQUk7QUFDYixTQUFLO0FBQ0wsU0FBSztBQUFBLEVBQ1A7QUFDQSxPQUFLLElBQUksR0FBRyxJQUFJLEdBQUcsS0FBSztBQUN0QixRQUFJLENBQUMsS0FBSyxJQUFJLElBQUk7QUFDbEIsUUFBSSxDQUFDLEtBQUs7QUFBQSxFQUNaO0FBQ0EsU0FBTztBQUNUO0FBQ0EsU0FBUyxTQUFTLEdBQUcsR0FBRyxHQUFHLEdBQUcsS0FBSztBQUNqQyxNQUFJLE1BQU0sS0FBSztBQUNiLFlBQVMsSUFBSSxLQUFLLEtBQU0sSUFBSSxJQUFJLElBQUk7QUFBQSxFQUN0QztBQUNBLE1BQUksTUFBTSxLQUFLO0FBQ2IsWUFBUSxJQUFJLEtBQUssSUFBSTtBQUFBLEVBQ3ZCO0FBQ0EsVUFBUSxJQUFJLEtBQUssSUFBSTtBQUN2QjtBQUNBLFNBQVMsUUFBUSxHQUFHO0FBQ2xCLFFBQU0sUUFBUTtBQUNkLFFBQU0sSUFBSSxFQUFFLElBQUk7QUFDaEIsUUFBTSxJQUFJLEVBQUUsSUFBSTtBQUNoQixRQUFNLElBQUksRUFBRSxJQUFJO0FBQ2hCLFFBQU0sTUFBTSxLQUFLLElBQUksR0FBRyxHQUFHLENBQUM7QUFDNUIsUUFBTSxNQUFNLEtBQUssSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUM1QixRQUFNLEtBQUssTUFBTSxPQUFPO0FBQ3hCLE1BQUksR0FBRyxHQUFHO0FBQ1YsTUFBSSxRQUFRLEtBQUs7QUFDZixRQUFJLE1BQU07QUFDVixRQUFJLElBQUksTUFBTSxLQUFLLElBQUksTUFBTSxPQUFPLEtBQUssTUFBTTtBQUMvQyxRQUFJLFNBQVMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQzVCLFFBQUksSUFBSSxLQUFLO0FBQUEsRUFDZjtBQUNBLFNBQU8sQ0FBQyxJQUFJLEdBQUcsS0FBSyxHQUFHLENBQUM7QUFDMUI7QUFDQSxTQUFTLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRztBQUN6QixVQUNFLE1BQU0sUUFBUSxDQUFDLElBQ1gsRUFBRSxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxJQUNsQixFQUFFLEdBQUcsR0FBRyxDQUFDLEdBQ2IsSUFBSSxHQUFHO0FBQ1g7QUFDQSxTQUFTLFFBQVEsR0FBRyxHQUFHLEdBQUc7QUFDeEIsU0FBTyxNQUFNLFVBQVUsR0FBRyxHQUFHLENBQUM7QUFDaEM7QUFDQSxTQUFTLFFBQVEsR0FBRyxHQUFHLEdBQUc7QUFDeEIsU0FBTyxNQUFNLFVBQVUsR0FBRyxHQUFHLENBQUM7QUFDaEM7QUFDQSxTQUFTLFFBQVEsR0FBRyxHQUFHLEdBQUc7QUFDeEIsU0FBTyxNQUFNLFVBQVUsR0FBRyxHQUFHLENBQUM7QUFDaEM7QUFDQSxTQUFTLElBQUksR0FBRztBQUNkLFVBQVEsSUFBSSxNQUFNLE9BQU87QUFDM0I7QUFDQSxTQUFTLFNBQVMsS0FBSztBQUNyQixRQUFNLElBQUksT0FBTyxLQUFLLEdBQUc7QUFDekIsTUFBSSxJQUFJO0FBQ1IsTUFBSTtBQUNKLE1BQUksQ0FBQyxHQUFHO0FBQ047QUFBQSxFQUNGO0FBQ0EsTUFBSSxFQUFFLENBQUMsTUFBTSxHQUFHO0FBQ2QsUUFBSSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFBQSxFQUNuQztBQUNBLFFBQU0sSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDbkIsUUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDLElBQUk7QUFDbkIsUUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDLElBQUk7QUFDbkIsTUFBSSxFQUFFLENBQUMsTUFBTSxPQUFPO0FBQ2xCLFFBQUksUUFBUSxHQUFHLElBQUksRUFBRTtBQUFBLEVBQ3ZCLFdBQVcsRUFBRSxDQUFDLE1BQU0sT0FBTztBQUN6QixRQUFJLFFBQVEsR0FBRyxJQUFJLEVBQUU7QUFBQSxFQUN2QixPQUFPO0FBQ0wsUUFBSSxRQUFRLEdBQUcsSUFBSSxFQUFFO0FBQUEsRUFDdkI7QUFDQSxTQUFPO0FBQUEsSUFDTCxHQUFHLEVBQUUsQ0FBQztBQUFBLElBQ04sR0FBRyxFQUFFLENBQUM7QUFBQSxJQUNOLEdBQUcsRUFBRSxDQUFDO0FBQUEsSUFDTjtBQUFBLEVBQ0Y7QUFDRjtBQUNBLFNBQVMsT0FBTyxHQUFHLEtBQUs7QUFDdEIsTUFBSSxJQUFJLFFBQVEsQ0FBQztBQUNqQixJQUFFLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxJQUFJLEdBQUc7QUFDckIsTUFBSSxRQUFRLENBQUM7QUFDYixJQUFFLElBQUksRUFBRSxDQUFDO0FBQ1QsSUFBRSxJQUFJLEVBQUUsQ0FBQztBQUNULElBQUUsSUFBSSxFQUFFLENBQUM7QUFDWDtBQUNBLFNBQVMsVUFBVSxHQUFHO0FBQ3BCLE1BQUksQ0FBQyxHQUFHO0FBQ047QUFBQSxFQUNGO0FBQ0EsUUFBTSxJQUFJLFFBQVEsQ0FBQztBQUNuQixRQUFNLElBQUksRUFBRSxDQUFDO0FBQ2IsUUFBTSxJQUFJLElBQUksRUFBRSxDQUFDLENBQUM7QUFDbEIsUUFBTSxJQUFJLElBQUksRUFBRSxDQUFDLENBQUM7QUFDbEIsU0FBTyxFQUFFLElBQUksTUFDVCxRQUFRLE1BQU0sT0FBTyxPQUFPLElBQUksRUFBRSxDQUFDLE9BQ25DLE9BQU8sTUFBTSxPQUFPO0FBQzFCO0FBRUEsSUFBTSxNQUFNO0FBQUEsRUFDVixHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQUEsRUFDSCxHQUFHO0FBQ0w7QUFDQSxJQUFNLFVBQVU7QUFBQSxFQUNkLFFBQVE7QUFBQSxFQUNSLGFBQWE7QUFBQSxFQUNiLE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLGNBQWM7QUFBQSxFQUNkLElBQUk7QUFBQSxFQUNKLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLFFBQVE7QUFBQSxFQUNSLFVBQVU7QUFBQSxFQUNWLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLGFBQWE7QUFBQSxFQUNiLFNBQVM7QUFBQSxFQUNULFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLEtBQUs7QUFBQSxFQUNMLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFdBQVc7QUFBQSxFQUNYLEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLFNBQVM7QUFBQSxFQUNULFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFdBQVc7QUFBQSxFQUNYLFNBQVM7QUFBQSxFQUNULFlBQVk7QUFBQSxFQUNaLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFlBQVk7QUFBQSxFQUNaLEtBQUs7QUFBQSxFQUNMLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLEtBQUs7QUFBQSxFQUNMLFVBQVU7QUFBQSxFQUNWLFlBQVk7QUFBQSxFQUNaLFNBQVM7QUFBQSxFQUNULFVBQVU7QUFBQSxFQUNWLFNBQVM7QUFBQSxFQUNULFlBQVk7QUFBQSxFQUNaLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFlBQVk7QUFBQSxFQUNaLFdBQVc7QUFBQSxFQUNYLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLGFBQWE7QUFBQSxFQUNiLElBQUk7QUFBQSxFQUNKLFVBQVU7QUFBQSxFQUNWLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLElBQUk7QUFBQSxFQUNKLE9BQU87QUFBQSxFQUNQ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LCAiaWQiLCAiaXNOdWxsT3JVbmRlZiIsICJ2YWx1ZSIsICJpc0FycmF5IiwgIkFycmF5IiwgInR5cGUiLCAiT2JqZWN0IiwgInByb3RvdHlwZSIsICJ0b1N0cmluZyIsICJjYWxsIiwgInNsaWNlIiwgImlzT2JqZWN0IiwgImlzTnVtYmVyRmluaXRlIiwgIk51bWJlciIsICJpc0Zpbml0ZSIsICJmaW5pdGVPckRlZmF1bHQiLCAiZGVmYXVsdFZhbHVlIiwgInZhbHVlT3JEZWZhdWx0IiwgInRvUGVyY2VudGFnZSIsICJkaW1lbnNpb24iLCAiZW5kc1dpdGgiLCAicGFyc2VGbG9hdCIsICJ0b0RpbWVuc2lvbiIsICJjYWxsYmFjayIsICJmbiIsICJhcmdzIiwgInRoaXNBcmciLCAiYXBwbHkiLCAiZWFjaCIsICJsb29wYWJsZSIsICJyZXZlcnNlIiwgImkiLCAibGVuIiwgImtleXMiLCAibGVuZ3RoIiwgIl9lbGVtZW50c0VxdWFsIiwgImEwIiwgImExIiwgImlsZW4iLCAidjAiLCAidjEiLCAiZGF0YXNldEluZGV4IiwgImluZGV4IiwgImNsb25lIiwgInNvdXJjZSIsICJtYXAiLCAidGFyZ2V0IiwgImNyZWF0ZSIsICJrbGVuIiwgImsiLCAiaXNWYWxpZEtleSIsICJrZXkiLCAiaW5kZXhPZiIsICJfbWVyZ2VyIiwgIm9wdGlvbnMiLCAidHZhbCIsICJzdmFsIiwgIm1lcmdlIiwgInNvdXJjZXMiLCAibWVyZ2VyIiwgImN1cnJlbnQiLCAibWVyZ2VJZiIsICJfbWVyZ2VySWYiLCAiaGFzT3duUHJvcGVydHkiLCAia2V5UmVzb2x2ZXJzIiwgInYiLCAieCIsICJvIiwgInkiLCAiX3NwbGl0S2V5IiwgImtleSIsICJwYXJ0cyIsICJzcGxpdCIsICJrZXlzIiwgInRtcCIsICJwYXJ0IiwgImVuZHNXaXRoIiwgInNsaWNlIiwgInB1c2giLCAiX2dldEtleVJlc29sdmVyIiwgIm9iaiIsICJrIiwgInJlc29sdmVPYmplY3RLZXkiLCAicmVzb2x2ZXIiLCAiX2NhcGl0YWxpemUiLCAic3RyIiwgImNoYXJBdCIsICJ0b1VwcGVyQ2FzZSIsICJkZWZpbmVkIiwgInZhbHVlIiwgImlzRnVuY3Rpb24iLCAic2V0c0VxdWFsIiwgImEiLCAiYiIsICJzaXplIiwgIml0ZW0iLCAiaGFzIiwgIl9pc0NsaWNrRXZlbnQiLCAiZSIsICJ0eXBlIiwgIlBJIiwgIk1hdGgiLCAiVEFVIiwgIlBJVEFVIiwgIklORklOSVRZIiwgIk51bWJlciIsICJQT1NJVElWRV9JTkZJTklUWSIsICJSQURfUEVSX0RFRyIsICJIQUxGX1BJIiwgIlFVQVJURVJfUEkiLCAiVFdPX1RISVJEU19QSSIsICJsb2cxMCIsICJzaWduIiwgImFsbW9zdEVxdWFscyIsICJlcHNpbG9uIiwgImFicyIsICJuaWNlTnVtIiwgInJhbmdlIiwgInJvdW5kZWRSYW5nZSIsICJyb3VuZCIsICJuaWNlUmFuZ2UiLCAicG93IiwgImZsb29yIiwgImZyYWN0aW9uIiwgIm5pY2VGcmFjdGlvbiIsICJfZmFjdG9yaXplIiwgInJlc3VsdCIsICJzcXJ0IiwgImkiLCAic29ydCIsICJwb3AiLCAiaXNOdW1iZXIiLCAibiIsICJpc05hTiIsICJwYXJzZUZsb2F0IiwgImlzRmluaXRlIiwgImFsbW9zdFdob2xlIiwgInJvdW5kZWQiLCAiX3NldE1pbkFuZE1heEJ5S2V5IiwgImFycmF5IiwgInRhcmdldCIsICJwcm9wZXJ0eSIsICJpbGVuIiwgImxlbmd0aCIsICJtaW4iLCAibWF4IiwgInRvUmFkaWFucyIsICJkZWdyZWVzIiwgInRvRGVncmVlcyIsICJyYWRpYW5zIiwgIl9kZWNpbWFsUGxhY2VzIiwgImlzRmluaXRlTnVtYmVyIiwgInAiLCAiZ2V0QW5nbGVGcm9tUG9pbnQiLCAiY2VudHJlUG9pbnQiLCAiYW5nbGVQb2ludCIsICJkaXN0YW5jZUZyb21YQ2VudGVyIiwgImRpc3RhbmNlRnJvbVlDZW50ZXIiLCAicmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyIiwgImFuZ2xlIiwgImF0YW4yIiwgImRpc3RhbmNlIiwgImRpc3RhbmNlQmV0d2VlblBvaW50cyIsICJwdDEiLCAicHQyIiwgIl9hbmdsZURpZmYiLCAiX25vcm1hbGl6ZUFuZ2xlIiwgIl9hbmdsZUJldHdlZW4iLCAic3RhcnQiLCAiZW5kIiwgInNhbWVBbmdsZUlzRnVsbENpcmNsZSIsICJzIiwgImFuZ2xlVG9TdGFydCIsICJhbmdsZVRvRW5kIiwgInN0YXJ0VG9BbmdsZSIsICJlbmRUb0FuZ2xlIiwgIl9saW1pdFZhbHVlIiwgIl9pbnQxNlJhbmdlIiwgIl9pc0JldHdlZW4iLCAiX2xvb2t1cCIsICJ0YWJsZSIsICJjbXAiLCAiaW5kZXgiLCAiaGkiLCAibG8iLCAibWlkIiwgIl9sb29rdXBCeUtleSIsICJsYXN0IiwgInRpIiwgIl9ybG9va3VwQnlLZXkiLCAiX2ZpbHRlckJldHdlZW4iLCAidmFsdWVzIiwgImFycmF5RXZlbnRzIiwgImxpc3RlbkFycmF5RXZlbnRzIiwgImxpc3RlbmVyIiwgIl9jaGFydGpzIiwgImxpc3RlbmVycyIsICJPYmplY3QiLCAiZGVmaW5lUHJvcGVydHkiLCAiY29uZmlndXJhYmxlIiwgImVudW1lcmFibGUiLCAiZm9yRWFjaCIsICJtZXRob2QiLCAiYmFzZSIsICJhcmdzIiwgInJlcyIsICJhcHBseSIsICJvYmplY3QiLCAidW5saXN0ZW5BcnJheUV2ZW50cyIsICJzdHViIiwgImluZGV4T2YiLCAic3BsaWNlIiwgIl9hcnJheVVuaXF1ZSIsICJpdGVtcyIsICJzZXQiLCAiU2V0IiwgIkFycmF5IiwgImZyb20iLCAicmVxdWVzdEFuaW1GcmFtZSIsICJ3aW5kb3ciLCAiY2FsbGJhY2siLCAicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwgInRocm90dGxlZCIsICJmbiIsICJ0aGlzQXJnIiwgImFyZ3NUb1VzZSIsICJ0aWNraW5nIiwgImFyZ3MiLCAiY2FsbCIsICJhcHBseSIsICJkZWJvdW5jZSIsICJkZWxheSIsICJ0aW1lb3V0IiwgImNsZWFyVGltZW91dCIsICJzZXRUaW1lb3V0IiwgIl90b0xlZnRSaWdodENlbnRlciIsICJhbGlnbiIsICJfYWxpZ25TdGFydEVuZCIsICJzdGFydCIsICJlbmQiLCAiX3RleHRYIiwgImxlZnQiLCAicmlnaHQiLCAicnRsIiwgImNoZWNrIiwgIl9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzIiwgIm1ldGEiLCAicG9pbnRzIiwgImFuaW1hdGlvbnNEaXNhYmxlZCIsICJwb2ludENvdW50IiwgImxlbmd0aCIsICJjb3VudCIsICJfc29ydGVkIiwgImlTY2FsZSIsICJfcGFyc2VkIiwgImF4aXMiLCAibWluIiwgIm1heCIsICJtaW5EZWZpbmVkIiwgIm1heERlZmluZWQiLCAiZ2V0VXNlckJvdW5kcyIsICJfbGltaXRWYWx1ZSIsICJNYXRoIiwgIl9sb29rdXBCeUtleSIsICJsbyIsICJnZXRQaXhlbEZvclZhbHVlIiwgImhpIiwgIl9zY2FsZVJhbmdlc0NoYW5nZWQiLCAieFNjYWxlIiwgInlTY2FsZSIsICJfc2NhbGVSYW5nZXMiLCAibmV3UmFuZ2VzIiwgInhtaW4iLCAieG1heCIsICJ5bWluIiwgInltYXgiLCAiY2hhbmdlZCIsICJPYmplY3QiLCAiYXNzaWduIiwgImF0RWRnZSIsICJ0IiwgImVsYXN0aWNJbiIsICJzIiwgInAiLCAicG93IiwgInNpbiIsICJUQVUiLCAiZWxhc3RpY091dCIsICJlZmZlY3RzIiwgImxpbmVhciIsICJlYXNlSW5RdWFkIiwgImVhc2VPdXRRdWFkIiwgImVhc2VJbk91dFF1YWQiLCAiZWFzZUluQ3ViaWMiLCAiZWFzZU91dEN1YmljIiwgImVhc2VJbk91dEN1YmljIiwgImVhc2VJblF1YXJ0IiwgImVhc2VPdXRRdWFydCIsICJlYXNlSW5PdXRRdWFydCIsICJlYXNlSW5RdWludCIsICJlYXNlT3V0UXVpbnQiLCAiZWFzZUluT3V0UXVpbnQiLCAiZWFzZUluU2luZSIsICJjb3MiLCAiSEFMRl9QSSIsICJlYXNlT3V0U2luZSIsICJlYXNlSW5PdXRTaW5lIiwgIlBJIiwgImVhc2VJbkV4cG8iLCAiZWFzZU91dEV4cG8iLCAiZWFzZUluT3V0RXhwbyIsICJlYXNlSW5DaXJjIiwgInNxcnQiLCAiZWFzZU91dENpcmMiLCAiZWFzZUluT3V0Q2lyYyIsICJlYXNlSW5FbGFzdGljIiwgImVhc2VPdXRFbGFzdGljIiwgImVhc2VJbk91dEVsYXN0aWMiLCAiZWFzZUluQmFjayIsICJlYXNlT3V0QmFjayIsICJlYXNlSW5PdXRCYWNrIiwgImVhc2VJbkJvdW5jZSIsICJlYXNlT3V0Qm91bmNlIiwgIm0iLCAiZCIsICJlYXNlSW5PdXRCb3VuY2UiLCAiaXNQYXR0ZXJuT3JHcmFkaWVudCIsICJ2YWx1ZSIsICJ0eXBlIiwgInRvU3RyaW5nIiwgImNvbG9yIiwgIkNvbG9yIiwgImdldEhvdmVyQ29sb3IiLCAic2F0dXJhdGUiLCAiZGFya2VuIiwgImhleFN0cmluZyIsICJudW1iZXJzIiwgImNvbG9ycyIsICJhcHBseUFuaW1hdGlvbnNEZWZhdWx0cyIsICJkZWZhdWx0cyIsICJzZXQiLCAidW5kZWZpbmVkIiwgImR1cmF0aW9uIiwgImVhc2luZyIsICJmcm9tIiwgImxvb3AiLCAidG8iLCAiZGVzY3JpYmUiLCAiX2ZhbGxiYWNrIiwgIl9pbmRleGFibGUiLCAiX3NjcmlwdGFibGUiLCAibmFtZSIsICJwcm9wZXJ0aWVzIiwgImFjdGl2ZSIsICJhbmltYXRpb24iLCAicmVzaXplIiwgInNob3ciLCAiYW5pbWF0aW9ucyIsICJ2aXNpYmxlIiwgImhpZGUiLCAidiIsICJhcHBseUxheW91dHNEZWZhdWx0cyIsICJhdXRvUGFkZGluZyIsICJwYWRkaW5nIiwgInRvcCIsICJib3R0b20iLCAiaW50bENhY2hlIiwgIk1hcCIsICJnZXROdW1iZXJGb3JtYXQiLCAibG9jYWxlIiwgIm9wdGlvbnMiLCAiY2FjaGVLZXkiLCAiSlNPTiIsICJzdHJpbmdpZnkiLCAiZm9ybWF0dGVyIiwgImdldCIsICJJbnRsIiwgIk51bWJlckZvcm1hdCIsICJmb3JtYXROdW1iZXIiLCAibnVtIiwgImZvcm1hdCIsICJmb3JtYXR0ZXJzIiwgInZhbHVlcyIsICJpc0FycmF5IiwgIm51bWVyaWMiLCAidGlja1ZhbHVlIiwgImluZGV4IiwgInRpY2tzIiwgImNoYXJ0IiwgIm5vdGF0aW9uIiwgImRlbHRhIiwgIm1heFRpY2siLCAiYWJzIiwgImNhbGN1bGF0ZURlbHRhIiwgImxvZ0RlbHRhIiwgImxvZzEwIiwgIm51bURlY2ltYWwiLCAiaXNOYU4iLCAiZmxvb3IiLCAibWluaW11bUZyYWN0aW9uRGlnaXRzIiwgIm1heGltdW1GcmFjdGlvbkRpZ2l0cyIsICJsb2dhcml0aG1pYyIsICJyZW1haW4iLCAic2lnbmlmaWNhbmQiLCAiaW5jbHVkZXMiLCAiYXBwbHlTY2FsZURlZmF1bHRzIiwgImRpc3BsYXkiLCAib2Zmc2V0IiwgInJldmVyc2UiLCAiYmVnaW5BdFplcm8iLCAiYm91bmRzIiwgImNsaXAiLCAiZ3JhY2UiLCAiZ3JpZCIsICJsaW5lV2lkdGgiLCAiZHJhd09uQ2hhcnRBcmVhIiwgImRyYXdUaWNrcyIsICJ0aWNrTGVuZ3RoIiwgInRpY2tXaWR0aCIsICJfY3R4IiwgInRpY2tDb2xvciIsICJib3JkZXIiLCAiZGFzaCIsICJkYXNoT2Zmc2V0IiwgIndpZHRoIiwgInRpdGxlIiwgInRleHQiLCAibWluUm90YXRpb24iLCAibWF4Um90YXRpb24iLCAibWlycm9yIiwgInRleHRTdHJva2VXaWR0aCIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAiYXV0b1NraXAiLCAiYXV0b1NraXBQYWRkaW5nIiwgImxhYmVsT2Zmc2V0IiwgIlRpY2tzIiwgIm1pbm9yIiwgIm1ham9yIiwgImNyb3NzQWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3BDb2xvciIsICJiYWNrZHJvcFBhZGRpbmciLCAicm91dGUiLCAic3RhcnRzV2l0aCIsICJvdmVycmlkZXMiLCAiY3JlYXRlIiwgImRlc2NyaXB0b3JzIiwgImdldFNjb3BlIiwgIm5vZGUiLCAia2V5IiwgImtleXMiLCAic3BsaXQiLCAiaSIsICJuIiwgImsiLCAicm9vdCIsICJzY29wZSIsICJtZXJnZSIsICJEZWZhdWx0cyIsICJjb25zdHJ1Y3RvciIsICJfZGVzY3JpcHRvcnMiLCAiX2FwcGxpZXJzIiwgImJhY2tncm91bmRDb2xvciIsICJib3JkZXJDb2xvciIsICJkYXRhc2V0cyIsICJkZXZpY2VQaXhlbFJhdGlvIiwgImNvbnRleHQiLCAicGxhdGZvcm0iLCAiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsICJlbGVtZW50cyIsICJldmVudHMiLCAiZm9udCIsICJmYW1pbHkiLCAic2l6ZSIsICJzdHlsZSIsICJsaW5lSGVpZ2h0IiwgIndlaWdodCIsICJob3ZlciIsICJob3ZlckJhY2tncm91bmRDb2xvciIsICJjdHgiLCAiaG92ZXJCb3JkZXJDb2xvciIsICJob3ZlckNvbG9yIiwgImluZGV4QXhpcyIsICJpbnRlcmFjdGlvbiIsICJtb2RlIiwgImludGVyc2VjdCIsICJpbmNsdWRlSW52aXNpYmxlIiwgIm1haW50YWluQXNwZWN0UmF0aW8iLCAib25Ib3ZlciIsICJvbkNsaWNrIiwgInBhcnNpbmciLCAicGx1Z2lucyIsICJyZXNwb25zaXZlIiwgInNjYWxlIiwgInNjYWxlcyIsICJzaG93TGluZSIsICJkcmF3QWN0aXZlRWxlbWVudHNPblRvcCIsICJvdmVycmlkZSIsICJ0YXJnZXRTY29wZSIsICJ0YXJnZXROYW1lIiwgInNjb3BlT2JqZWN0IiwgInRhcmdldFNjb3BlT2JqZWN0IiwgInByaXZhdGVOYW1lIiwgImRlZmluZVByb3BlcnRpZXMiLCAid3JpdGFibGUiLCAiZW51bWVyYWJsZSIsICJsb2NhbCIsICJ0YXJnZXQiLCAiaXNPYmplY3QiLCAidmFsdWVPckRlZmF1bHQiLCAiYXBwbGllcnMiLCAiZm9yRWFjaCIsICJ0b0ZvbnRTdHJpbmciLCAiaXNOdWxsT3JVbmRlZiIsICJfbWVhc3VyZVRleHQiLCAiZGF0YSIsICJnYyIsICJsb25nZXN0IiwgInN0cmluZyIsICJ0ZXh0V2lkdGgiLCAibWVhc3VyZVRleHQiLCAicHVzaCIsICJfbG9uZ2VzdFRleHQiLCAiYXJyYXlPZlRoaW5ncyIsICJjYWNoZSIsICJnYXJiYWdlQ29sbGVjdCIsICJzYXZlIiwgImlsZW4iLCAiaiIsICJqbGVuIiwgInRoaW5nIiwgIm5lc3RlZFRoaW5nIiwgInJlc3RvcmUiLCAiZ2NMZW4iLCAic3BsaWNlIiwgIl9hbGlnblBpeGVsIiwgInBpeGVsIiwgImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwgImhhbGZXaWR0aCIsICJyb3VuZCIsICJjbGVhckNhbnZhcyIsICJjYW52YXMiLCAiZ2V0Q29udGV4dCIsICJyZXNldFRyYW5zZm9ybSIsICJjbGVhclJlY3QiLCAiaGVpZ2h0IiwgImRyYXdQb2ludCIsICJ4IiwgInkiLCAiZHJhd1BvaW50TGVnZW5kIiwgInciLCAieE9mZnNldCIsICJ5T2Zmc2V0IiwgImNvcm5lclJhZGl1cyIsICJ4T2Zmc2V0VyIsICJ5T2Zmc2V0VyIsICJwb2ludFN0eWxlIiwgInJvdGF0aW9uIiwgInJhZGl1cyIsICJyYWQiLCAiUkFEX1BFUl9ERUciLCAidHJhbnNsYXRlIiwgInJvdGF0ZSIsICJkcmF3SW1hZ2UiLCAiYmVnaW5QYXRoIiwgImVsbGlwc2UiLCAiYXJjIiwgImNsb3NlUGF0aCIsICJtb3ZlVG8iLCAiVFdPX1RISVJEU19QSSIsICJsaW5lVG8iLCAiUVVBUlRFUl9QSSIsICJTUVJUMV8yIiwgInJlY3QiLCAiZmlsbCIsICJib3JkZXJXaWR0aCIsICJzdHJva2UiLCAiX2lzUG9pbnRJbkFyZWEiLCAicG9pbnQiLCAiYXJlYSIsICJtYXJnaW4iLCAiY2xpcEFyZWEiLCAidW5jbGlwQXJlYSIsICJfc3RlcHBlZExpbmVUbyIsICJwcmV2aW91cyIsICJmbGlwIiwgIm1pZHBvaW50IiwgIl9iZXppZXJDdXJ2ZVRvIiwgImJlemllckN1cnZlVG8iLCAiY3AxeCIsICJjcDJ4IiwgImNwMXkiLCAiY3AyeSIsICJzZXRSZW5kZXJPcHRzIiwgIm9wdHMiLCAidHJhbnNsYXRpb24iLCAiZmlsbFN0eWxlIiwgInRleHRBbGlnbiIsICJ0ZXh0QmFzZWxpbmUiLCAiZGVjb3JhdGVUZXh0IiwgImxpbmUiLCAic3RyaWtldGhyb3VnaCIsICJ1bmRlcmxpbmUiLCAibWV0cmljcyIsICJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCAiYWN0dWFsQm91bmRpbmdCb3hSaWdodCIsICJhY3R1YWxCb3VuZGluZ0JveEFzY2VudCIsICJhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQiLCAieURlY29yYXRpb24iLCAic3Ryb2tlU3R5bGUiLCAiZGVjb3JhdGlvbldpZHRoIiwgImRyYXdCYWNrZHJvcCIsICJvbGRDb2xvciIsICJmaWxsUmVjdCIsICJyZW5kZXJUZXh0IiwgImxpbmVzIiwgInN0cm9rZVdpZHRoIiwgInN0cm9rZUNvbG9yIiwgImJhY2tkcm9wIiwgInN0cm9rZVRleHQiLCAibWF4V2lkdGgiLCAiZmlsbFRleHQiLCAiTnVtYmVyIiwgImFkZFJvdW5kZWRSZWN0UGF0aCIsICJoIiwgInRvcExlZnQiLCAiYm90dG9tTGVmdCIsICJib3R0b21SaWdodCIsICJ0b3BSaWdodCIsICJMSU5FX0hFSUdIVCIsICJGT05UX1NUWUxFIiwgInRvTGluZUhlaWdodCIsICJtYXRjaGVzIiwgIm1hdGNoIiwgIm51bWJlck9yWmVybyIsICJfcmVhZFZhbHVlVG9Qcm9wcyIsICJwcm9wcyIsICJyZXQiLCAib2JqUHJvcHMiLCAicmVhZCIsICJwcm9wIiwgInRvVFJCTCIsICJ0b1RSQkxDb3JuZXJzIiwgInRvUGFkZGluZyIsICJvYmoiLCAidG9Gb250IiwgImZhbGxiYWNrIiwgInBhcnNlSW50IiwgImNvbnNvbGUiLCAid2FybiIsICJyZXNvbHZlIiwgImlucHV0cyIsICJpbmZvIiwgImNhY2hlYWJsZSIsICJfYWRkR3JhY2UiLCAibWlubWF4IiwgImNoYW5nZSIsICJ0b0RpbWVuc2lvbiIsICJrZWVwWmVybyIsICJhZGQiLCAiY3JlYXRlQ29udGV4dCIsICJwYXJlbnRDb250ZXh0IiwgIl9jcmVhdGVSZXNvbHZlciIsICJzY29wZXMiLCAicHJlZml4ZXMiLCAicm9vdFNjb3BlcyIsICJnZXRUYXJnZXQiLCAiZmluYWxSb290U2NvcGVzIiwgIl9yZXNvbHZlIiwgIlN5bWJvbCIsICJ0b1N0cmluZ1RhZyIsICJfY2FjaGVhYmxlIiwgIl9zY29wZXMiLCAiX3Jvb3RTY29wZXMiLCAiX2dldFRhcmdldCIsICJQcm94eSIsICJkZWxldGVQcm9wZXJ0eSIsICJfa2V5cyIsICJfY2FjaGVkIiwgIl9yZXNvbHZlV2l0aFByZWZpeGVzIiwgImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsICJSZWZsZWN0IiwgImdldFByb3RvdHlwZU9mIiwgImhhcyIsICJnZXRLZXlzRnJvbUFsbFNjb3BlcyIsICJvd25LZXlzIiwgInN0b3JhZ2UiLCAiX3N0b3JhZ2UiLCAiX2F0dGFjaENvbnRleHQiLCAicHJveHkiLCAic3ViUHJveHkiLCAiZGVzY3JpcHRvckRlZmF1bHRzIiwgIl9wcm94eSIsICJfY29udGV4dCIsICJfc3ViUHJveHkiLCAiX3N0YWNrIiwgIlNldCIsICJzZXRDb250ZXh0IiwgInJlY2VpdmVyIiwgIl9yZXNvbHZlV2l0aENvbnRleHQiLCAiYWxsS2V5cyIsICJjb25maWd1cmFibGUiLCAic2NyaXB0YWJsZSIsICJpbmRleGFibGUiLCAiX2FsbEtleXMiLCAiaXNTY3JpcHRhYmxlIiwgImlzRnVuY3Rpb24iLCAiaXNJbmRleGFibGUiLCAicmVhZEtleSIsICJwcmVmaXgiLCAiX2NhcGl0YWxpemUiLCAibmVlZHNTdWJSZXNvbHZlciIsICJwcm90b3R5cGUiLCAiaGFzT3duUHJvcGVydHkiLCAiX3Jlc29sdmVTY3JpcHRhYmxlIiwgIl9yZXNvbHZlQXJyYXkiLCAiZ2V0VmFsdWUiLCAiRXJyb3IiLCAiQXJyYXkiLCAiam9pbiIsICJkZWxldGUiLCAiY3JlYXRlU3ViUmVzb2x2ZXIiLCAiYXJyIiwgImZpbHRlciIsICJpdGVtIiwgInJlc29sdmVyIiwgInJlc29sdmVGYWxsYmFjayIsICJwYXJlbnQiLCAicmVzb2x2ZU9iamVjdEtleSIsICJhZGRTY29wZXMiLCAicGFyZW50U2NvcGVzIiwgInBhcmVudEZhbGxiYWNrIiwgImFsbFNjb3BlcyIsICJhZGRTY29wZXNGcm9tS2V5IiwgInN1YkdldFRhcmdldCIsICJyZXNvbHZlS2V5c0Zyb21BbGxTY29wZXMiLCAiX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlIiwgIl9wYXJzaW5nIiwgInBhcnNlZCIsICJyIiwgInBhcnNlIiwgIkVQU0lMT04iLCAiZ2V0UG9pbnQiLCAic2tpcCIsICJnZXRWYWx1ZUF4aXMiLCAic3BsaW5lQ3VydmUiLCAiZmlyc3RQb2ludCIsICJtaWRkbGVQb2ludCIsICJhZnRlclBvaW50IiwgImN1cnJlbnQiLCAibmV4dCIsICJkMDEiLCAiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwgImQxMiIsICJzMDEiLCAiczEyIiwgImZhIiwgImZiIiwgIm1vbm90b25lQWRqdXN0IiwgImRlbHRhSyIsICJtSyIsICJwb2ludHNMZW4iLCAiYWxwaGFLIiwgImJldGFLIiwgInRhdUsiLCAic3F1YXJlZE1hZ25pdHVkZSIsICJwb2ludEN1cnJlbnQiLCAicG9pbnRBZnRlciIsICJhbG1vc3RFcXVhbHMiLCAibW9ub3RvbmVDb21wdXRlIiwgInZhbHVlQXhpcyIsICJwb2ludEJlZm9yZSIsICJpUGl4ZWwiLCAidlBpeGVsIiwgInNwbGluZUN1cnZlTW9ub3RvbmUiLCAic2xvcGVEZWx0YSIsICJzaWduIiwgImNhcENvbnRyb2xQb2ludCIsICJwdCIsICJjYXBCZXppZXJQb2ludHMiLCAiaW5BcmVhIiwgImluQXJlYVByZXYiLCAiaW5BcmVhTmV4dCIsICJfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsICJjb250cm9sUG9pbnRzIiwgInNwYW5HYXBzIiwgImN1YmljSW50ZXJwb2xhdGlvbk1vZGUiLCAicHJldiIsICJ0ZW5zaW9uIiwgIl9pc0RvbVN1cHBvcnRlZCIsICJkb2N1bWVudCIsICJfZ2V0UGFyZW50Tm9kZSIsICJkb21Ob2RlIiwgInBhcmVudE5vZGUiLCAiaG9zdCIsICJwYXJzZU1heFN0eWxlIiwgInN0eWxlVmFsdWUiLCAicGFyZW50UHJvcGVydHkiLCAidmFsdWVJblBpeGVscyIsICJpbmRleE9mIiwgImdldENvbXB1dGVkU3R5bGUiLCAiZWxlbWVudCIsICJvd25lckRvY3VtZW50IiwgImRlZmF1bHRWaWV3IiwgImdldFN0eWxlIiwgImVsIiwgInByb3BlcnR5IiwgImdldFByb3BlcnR5VmFsdWUiLCAicG9zaXRpb25zIiwgImdldFBvc2l0aW9uZWRTdHlsZSIsICJzdHlsZXMiLCAic3VmZml4IiwgInJlc3VsdCIsICJwb3MiLCAicGFyc2VGbG9hdCIsICJ1c2VPZmZzZXRQb3MiLCAic2hhZG93Um9vdCIsICJnZXRDYW52YXNQb3NpdGlvbiIsICJlIiwgInRvdWNoZXMiLCAic291cmNlIiwgIm9mZnNldFgiLCAib2Zmc2V0WSIsICJib3giLCAiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwgImNsaWVudFgiLCAiY2xpZW50WSIsICJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwgImV2ZW50IiwgImJvcmRlckJveCIsICJib3hTaXppbmciLCAicGFkZGluZ3MiLCAiYm9yZGVycyIsICJnZXRDb250YWluZXJTaXplIiwgIm1heEhlaWdodCIsICJjb250YWluZXIiLCAiY2xpZW50V2lkdGgiLCAiY2xpZW50SGVpZ2h0IiwgImNvbnRhaW5lclN0eWxlIiwgImNvbnRhaW5lckJvcmRlciIsICJjb250YWluZXJQYWRkaW5nIiwgIklORklOSVRZIiwgInJvdW5kMSIsICJnZXRNYXhpbXVtU2l6ZSIsICJiYldpZHRoIiwgImJiSGVpZ2h0IiwgImFzcGVjdFJhdGlvIiwgIm1hcmdpbnMiLCAiY29udGFpbmVyU2l6ZSIsICJtYWludGFpbkhlaWdodCIsICJyZXRpbmFTY2FsZSIsICJmb3JjZVJhdGlvIiwgImZvcmNlU3R5bGUiLCAicGl4ZWxSYXRpbyIsICJkZXZpY2VIZWlnaHQiLCAiZGV2aWNlV2lkdGgiLCAic2V0VHJhbnNmb3JtIiwgInN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCAicGFzc2l2ZVN1cHBvcnRlZCIsICJwYXNzaXZlIiwgImFkZEV2ZW50TGlzdGVuZXIiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJyZWFkVXNlZFNpemUiLCAiX3BvaW50SW5MaW5lIiwgInAxIiwgInAyIiwgIl9zdGVwcGVkSW50ZXJwb2xhdGlvbiIsICJfYmV6aWVySW50ZXJwb2xhdGlvbiIsICJjcDEiLCAiY3AyIiwgImEiLCAiYiIsICJjIiwgImdldFJpZ2h0VG9MZWZ0QWRhcHRlciIsICJyZWN0WCIsICJzZXRXaWR0aCIsICJ4UGx1cyIsICJsZWZ0Rm9yTHRyIiwgIml0ZW1XaWR0aCIsICJnZXRMZWZ0VG9SaWdodEFkYXB0ZXIiLCAiX2l0ZW1XaWR0aCIsICJnZXRSdGxBZGFwdGVyIiwgIm92ZXJyaWRlVGV4dERpcmVjdGlvbiIsICJkaXJlY3Rpb24iLCAib3JpZ2luYWwiLCAiZ2V0UHJvcGVydHlQcmlvcml0eSIsICJzZXRQcm9wZXJ0eSIsICJwcmV2VGV4dERpcmVjdGlvbiIsICJyZXN0b3JlVGV4dERpcmVjdGlvbiIsICJwcm9wZXJ0eUZuIiwgImJldHdlZW4iLCAiX2FuZ2xlQmV0d2VlbiIsICJjb21wYXJlIiwgIl9hbmdsZURpZmYiLCAibm9ybWFsaXplIiwgIl9ub3JtYWxpemVBbmdsZSIsICJfaXNCZXR3ZWVuIiwgIm5vcm1hbGl6ZVNlZ21lbnQiLCAiZ2V0U2VnbWVudCIsICJzZWdtZW50IiwgInN0YXJ0Qm91bmQiLCAiZW5kQm91bmQiLCAiX2JvdW5kU2VnbWVudCIsICJpbnNpZGUiLCAic3ViU3RhcnQiLCAicHJldlZhbHVlIiwgInN0YXJ0SXNCZWZvcmUiLCAiZW5kSXNCZWZvcmUiLCAic2hvdWxkU3RhcnQiLCAic2hvdWxkU3RvcCIsICJfYm91bmRTZWdtZW50cyIsICJzZWdtZW50cyIsICJzdWIiLCAiZmluZFN0YXJ0QW5kRW5kIiwgInNvbGlkU2VnbWVudHMiLCAibGFzdCIsICJjdXIiLCAic3RvcCIsICJfY29tcHV0ZVNlZ21lbnRzIiwgInNlZ21lbnRPcHRpb25zIiwgIl9sb29wIiwgInNwbGl0QnlTdHlsZXMiLCAiY29tcGxldGVMb29wIiwgIl9mdWxsTG9vcCIsICJkb1NwbGl0QnlTdHlsZXMiLCAiY2hhcnRDb250ZXh0IiwgIl9jaGFydCIsICJiYXNlU3R5bGUiLCAicmVhZFN0eWxlIiwgIl9kYXRhc2V0SW5kZXgiLCAiZGF0YXNldEluZGV4IiwgInByZXZTdHlsZSIsICJhZGRTdHlsZSIsICJsIiwgInN0IiwgImRpciIsICJwMCIsICJwMERhdGFJbmRleCIsICJwMURhdGFJbmRleCIsICJzdHlsZUNoYW5nZWQiLCAiYm9yZGVyQ2FwU3R5bGUiLCAiYm9yZGVyRGFzaCIsICJib3JkZXJEYXNoT2Zmc2V0IiwgImJvcmRlckpvaW5TdHlsZSIsICJyZXBsYWNlciIsICJBbmltYXRvciIsICJjb25zdHJ1Y3RvciIsICJfcmVxdWVzdCIsICJfY2hhcnRzIiwgIk1hcCIsICJfcnVubmluZyIsICJfbGFzdERhdGUiLCAidW5kZWZpbmVkIiwgIl9ub3RpZnkiLCAiY2hhcnQiLCAiYW5pbXMiLCAiZGF0ZSIsICJ0eXBlIiwgImNhbGxiYWNrcyIsICJsaXN0ZW5lcnMiLCAibnVtU3RlcHMiLCAiZHVyYXRpb24iLCAiZm9yRWFjaCIsICJmbiIsICJpbml0aWFsIiwgImN1cnJlbnRTdGVwIiwgIk1hdGgiLCAibWluIiwgInN0YXJ0IiwgIl9yZWZyZXNoIiwgInJlcXVlc3RBbmltRnJhbWUiLCAiY2FsbCIsICJ3aW5kb3ciLCAiX3VwZGF0ZSIsICJEYXRlIiwgIm5vdyIsICJyZW1haW5pbmciLCAicnVubmluZyIsICJpdGVtcyIsICJsZW5ndGgiLCAiaSIsICJkcmF3IiwgIml0ZW0iLCAiX2FjdGl2ZSIsICJfdG90YWwiLCAidGljayIsICJwb3AiLCAiX2dldEFuaW1zIiwgImNoYXJ0cyIsICJnZXQiLCAiY29tcGxldGUiLCAicHJvZ3Jlc3MiLCAic2V0IiwgImxpc3RlbiIsICJldmVudCIsICJjYiIsICJwdXNoIiwgImFkZCIsICJoYXMiLCAicmVkdWNlIiwgImFjYyIsICJjdXIiLCAibWF4IiwgIl9kdXJhdGlvbiIsICJzdG9wIiwgImNhbmNlbCIsICJyZW1vdmUiLCAiZGVsZXRlIiwgInRyYW5zcGFyZW50IiwgImludGVycG9sYXRvcnMiLCAiYm9vbGVhbiIsICJmcm9tIiwgInRvIiwgImZhY3RvciIsICJjb2xvciIsICJjMCIsICJoZWxwZXJzQ29sb3IiLCAiYzEiLCAidmFsaWQiLCAibWl4IiwgImhleFN0cmluZyIsICJudW1iZXIiLCAiQW5pbWF0aW9uIiwgImNmZyIsICJ0YXJnZXQiLCAicHJvcCIsICJjdXJyZW50VmFsdWUiLCAicmVzb2x2ZSIsICJfZm4iLCAiX2Vhc2luZyIsICJlZmZlY3RzIiwgImVhc2luZyIsICJsaW5lYXIiLCAiX3N0YXJ0IiwgImZsb29yIiwgImRlbGF5IiwgIl9sb29wIiwgImxvb3AiLCAiX3RhcmdldCIsICJfcHJvcCIsICJfZnJvbSIsICJfdG8iLCAiX3Byb21pc2VzIiwgImFjdGl2ZSIsICJ1cGRhdGUiLCAiZWxhcHNlZCIsICJyZW1haW4iLCAid2FpdCIsICJwcm9taXNlcyIsICJQcm9taXNlIiwgInJlcyIsICJyZWoiLCAicmVzb2x2ZWQiLCAibWV0aG9kIiwgIkFuaW1hdGlvbnMiLCAiY29uZmlnIiwgIl9jaGFydCIsICJfcHJvcGVydGllcyIsICJjb25maWd1cmUiLCAiaXNPYmplY3QiLCAiYW5pbWF0aW9uT3B0aW9ucyIsICJPYmplY3QiLCAia2V5cyIsICJkZWZhdWx0cyIsICJhbmltYXRpb24iLCAiYW5pbWF0ZWRQcm9wcyIsICJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwgImtleSIsICJvcHRpb24iLCAiaXNBcnJheSIsICJwcm9wZXJ0aWVzIiwgIl9hbmltYXRlT3B0aW9ucyIsICJ2YWx1ZXMiLCAibmV3T3B0aW9ucyIsICJvcHRpb25zIiwgInJlc29sdmVUYXJnZXRPcHRpb25zIiwgImFuaW1hdGlvbnMiLCAiX2NyZWF0ZUFuaW1hdGlvbnMiLCAiJHNoYXJlZCIsICJhd2FpdEFsbCIsICIkYW5pbWF0aW9ucyIsICJ0aGVuIiwgInByb3BzIiwgImNoYXJBdCIsICJ2YWx1ZSIsICJzaXplIiwgImFzc2lnbiIsICJhbmltYXRvciIsICJhbmltIiwgImFsbCIsICJzY2FsZUNsaXAiLCAic2NhbGUiLCAiYWxsb3dlZE92ZXJmbG93IiwgIm9wdHMiLCAicmV2ZXJzZSIsICJlbmQiLCAiZGVmYXVsdENsaXAiLCAieFNjYWxlIiwgInlTY2FsZSIsICJ4IiwgInkiLCAidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0IiwgInRvQ2xpcCIsICJ0IiwgInIiLCAiYiIsICJsIiwgImRpc2FibGVkIiwgImdldFNvcnRlZERhdGFzZXRJbmRpY2VzIiwgImZpbHRlclZpc2libGUiLCAibWV0YXNldHMiLCAiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsICJpbGVuIiwgImluZGV4IiwgImFwcGx5U3RhY2siLCAic3RhY2siLCAiZHNJbmRleCIsICJzaW5nbGVNb2RlIiwgIm1vZGUiLCAiZGF0YXNldEluZGV4IiwgIm90aGVyVmFsdWUiLCAiaXNGaW5pdGUiLCAic2lnbiIsICJjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkiLCAiZGF0YSIsICJhZGF0YSIsICJBcnJheSIsICJpc1N0YWNrZWQiLCAibWV0YSIsICJzdGFja2VkIiwgImdldFN0YWNrS2V5IiwgImluZGV4U2NhbGUiLCAidmFsdWVTY2FsZSIsICJpZCIsICJnZXRVc2VyQm91bmRzIiwgIm1pbkRlZmluZWQiLCAibWF4RGVmaW5lZCIsICJOdW1iZXIiLCAiTkVHQVRJVkVfSU5GSU5JVFkiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAiZ2V0T3JDcmVhdGVTdGFjayIsICJzdGFja3MiLCAic3RhY2tLZXkiLCAiaW5kZXhWYWx1ZSIsICJzdWJTdGFjayIsICJnZXRMYXN0SW5kZXhJblN0YWNrIiwgInZTY2FsZSIsICJwb3NpdGl2ZSIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJ1cGRhdGVTdGFja3MiLCAiY29udHJvbGxlciIsICJwYXJzZWQiLCAiX2NhY2hlZE1ldGEiLCAiX3N0YWNrcyIsICJpU2NhbGUiLCAiaUF4aXMiLCAiYXhpcyIsICJ2QXhpcyIsICJpdGVtU3RhY2tzIiwgIl90b3AiLCAiX2JvdHRvbSIsICJ2aXN1YWxWYWx1ZXMiLCAiX3Zpc3VhbFZhbHVlcyIsICJnZXRGaXJzdFNjYWxlSWQiLCAic2NhbGVzIiwgImZpbHRlciIsICJzaGlmdCIsICJjcmVhdGVEYXRhc2V0Q29udGV4dCIsICJwYXJlbnQiLCAiY3JlYXRlQ29udGV4dCIsICJkYXRhc2V0IiwgImNyZWF0ZURhdGFDb250ZXh0IiwgImVsZW1lbnQiLCAiZGF0YUluZGV4IiwgInJhdyIsICJjbGVhclN0YWNrcyIsICJfcGFyc2VkIiwgImlzRGlyZWN0VXBkYXRlTW9kZSIsICJjbG9uZUlmTm90U2hhcmVkIiwgImNhY2hlZCIsICJzaGFyZWQiLCAiY3JlYXRlU3RhY2siLCAiY2FuU3RhY2siLCAiaGlkZGVuIiwgIl9zdGFja2VkIiwgIkRhdGFzZXRDb250cm9sbGVyIiwgIl9jdHgiLCAiY3R4IiwgIl9jYWNoZWREYXRhT3B0cyIsICJnZXRNZXRhIiwgIl90eXBlIiwgIl9wYXJzaW5nIiwgIl9kYXRhIiwgIl9vYmplY3REYXRhIiwgIl9zaGFyZWRPcHRpb25zIiwgIl9kcmF3U3RhcnQiLCAiX2RyYXdDb3VudCIsICJlbmFibGVPcHRpb25TaGFyaW5nIiwgInN1cHBvcnRzRGVjaW1hdGlvbiIsICIkY29udGV4dCIsICJfc3luY0xpc3QiLCAiZGF0YXNldEVsZW1lbnRUeXBlIiwgImRhdGFFbGVtZW50VHlwZSIsICJpbml0aWFsaXplIiwgImxpbmtTY2FsZXMiLCAiYWRkRWxlbWVudHMiLCAiZmlsbCIsICJpc1BsdWdpbkVuYWJsZWQiLCAiY29uc29sZSIsICJ3YXJuIiwgInVwZGF0ZUluZGV4IiwgImdldERhdGFzZXQiLCAiY2hvb3NlSWQiLCAieGlkIiwgInhBeGlzSUQiLCAidmFsdWVPckRlZmF1bHQiLCAieWlkIiwgInlBeGlzSUQiLCAicmlkIiwgInJBeGlzSUQiLCAiaW5kZXhBeGlzIiwgImlpZCIsICJpQXhpc0lEIiwgInZpZCIsICJ2QXhpc0lEIiwgImdldFNjYWxlRm9ySWQiLCAiclNjYWxlIiwgImRhdGFzZXRzIiwgImdldERhdGFzZXRNZXRhIiwgInNjYWxlSUQiLCAiX2dldE90aGVyU2NhbGUiLCAicmVzZXQiLCAiX2Rlc3Ryb3kiLCAidW5saXN0ZW5BcnJheUV2ZW50cyIsICJfZGF0YUNoZWNrIiwgImlzRXh0ZW5zaWJsZSIsICJsaXN0ZW5BcnJheUV2ZW50cyIsICJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCAicmVzZXROZXdFbGVtZW50cyIsICJzdGFja0NoYW5nZWQiLCAib2xkU3RhY2tlZCIsICJfcmVzeW5jRWxlbWVudHMiLCAic2NvcGVLZXlzIiwgImRhdGFzZXRTY29wZUtleXMiLCAic2NvcGVzIiwgImdldE9wdGlvblNjb3BlcyIsICJjcmVhdGVSZXNvbHZlciIsICJnZXRDb250ZXh0IiwgInBhcnNpbmciLCAicGFyc2UiLCAiY291bnQiLCAic29ydGVkIiwgIl9zb3J0ZWQiLCAicHJldiIsICJwYXJzZUFycmF5RGF0YSIsICJwYXJzZU9iamVjdERhdGEiLCAicGFyc2VQcmltaXRpdmVEYXRhIiwgImlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2IiwgImxhYmVscyIsICJnZXRMYWJlbHMiLCAic2luZ2xlU2NhbGUiLCAieEF4aXNLZXkiLCAieUF4aXNLZXkiLCAicmVzb2x2ZU9iamVjdEtleSIsICJnZXRQYXJzZWQiLCAiZ2V0RGF0YUVsZW1lbnQiLCAidXBkYXRlUmFuZ2VGcm9tUGFyc2VkIiwgInJhbmdlIiwgInBhcnNlZFZhbHVlIiwgIk5hTiIsICJnZXRNaW5NYXgiLCAib3RoZXJTY2FsZSIsICJvdGhlck1pbiIsICJvdGhlck1heCIsICJfc2tpcCIsICJnZXRBbGxQYXJzZWRWYWx1ZXMiLCAiZ2V0TWF4T3ZlcmZsb3ciLCAiZ2V0TGFiZWxBbmRWYWx1ZSIsICJsYWJlbCIsICJnZXRMYWJlbEZvclZhbHVlIiwgIl9jbGlwIiwgImNsaXAiLCAiZWxlbWVudHMiLCAiYXJlYSIsICJjaGFydEFyZWEiLCAiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCAiZ2V0U3R5bGUiLCAicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsICJyZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zIiwgImNvbnRleHQiLCAiX3Jlc29sdmVFbGVtZW50T3B0aW9ucyIsICJlbGVtZW50VHlwZSIsICJjYWNoZSIsICJjYWNoZUtleSIsICJzaGFyaW5nIiwgImRlZmluZWQiLCAiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCAicHJlZml4ZXMiLCAibmFtZXMiLCAicmVzb2x2ZU5hbWVkT3B0aW9ucyIsICJmcmVlemUiLCAiX3Jlc29sdmVBbmltYXRpb25zIiwgInRyYW5zaXRpb24iLCAiZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyIsICJfY2FjaGVhYmxlIiwgImdldFNoYXJlZE9wdGlvbnMiLCAiaW5jbHVkZU9wdGlvbnMiLCAic2hhcmVkT3B0aW9ucyIsICJfYW5pbWF0aW9uc0Rpc2FibGVkIiwgIl9nZXRTaGFyZWRPcHRpb25zIiwgImZpcnN0T3B0cyIsICJwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyIsICJ1cGRhdGVTaGFyZWRPcHRpb25zIiwgInVwZGF0ZUVsZW1lbnQiLCAiX3NldFN0eWxlIiwgInJlbW92ZUhvdmVyU3R5bGUiLCAic2V0SG92ZXJTdHlsZSIsICJfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUiLCAiX3NldERhdGFzZXRIb3ZlclN0eWxlIiwgImFyZzEiLCAiYXJnMiIsICJudW1NZXRhIiwgIm51bURhdGEiLCAiX2luc2VydEVsZW1lbnRzIiwgIl9yZW1vdmVFbGVtZW50cyIsICJtb3ZlIiwgImFyciIsICJ1cGRhdGVFbGVtZW50cyIsICJyZW1vdmVkIiwgInNwbGljZSIsICJfc3luYyIsICJhcmdzIiwgIl9kYXRhQ2hhbmdlcyIsICJfb25EYXRhUHVzaCIsICJhcmd1bWVudHMiLCAiX29uRGF0YVBvcCIsICJfb25EYXRhU2hpZnQiLCAiX29uRGF0YVNwbGljZSIsICJuZXdDb3VudCIsICJfb25EYXRhVW5zaGlmdCIsICJnZXRBbGxTY2FsZVZhbHVlcyIsICJfY2FjaGUiLCAiJGJhciIsICJ2aXNpYmxlTWV0YXMiLCAiY29uY2F0IiwgIl9hcnJheVVuaXF1ZSIsICJzb3J0IiwgImEiLCAiY29tcHV0ZU1pblNhbXBsZVNpemUiLCAiX2xlbmd0aCIsICJjdXJyIiwgInVwZGF0ZU1pbkFuZFByZXYiLCAiYWJzIiwgImdldFBpeGVsRm9yVmFsdWUiLCAidGlja3MiLCAiZ2V0UGl4ZWxGb3JUaWNrIiwgImNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyIsICJydWxlciIsICJzdGFja0NvdW50IiwgInRoaWNrbmVzcyIsICJiYXJUaGlja25lc3MiLCAicmF0aW8iLCAiaXNOdWxsT3JVbmRlZiIsICJjYXRlZ29yeVBlcmNlbnRhZ2UiLCAiYmFyUGVyY2VudGFnZSIsICJjaHVuayIsICJwaXhlbHMiLCAiY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyIsICJuZXh0IiwgInBlcmNlbnQiLCAicGFyc2VGbG9hdEJhciIsICJlbnRyeSIsICJzdGFydFZhbHVlIiwgImVuZFZhbHVlIiwgImJhclN0YXJ0IiwgImJhckVuZCIsICJfY3VzdG9tIiwgInBhcnNlVmFsdWUiLCAicGFyc2VBcnJheU9yUHJpbWl0aXZlIiwgImlzRmxvYXRCYXIiLCAiY3VzdG9tIiwgImJhclNpZ24iLCAiYWN0dWFsQmFzZSIsICJpc0hvcml6b250YWwiLCAiYm9yZGVyUHJvcHMiLCAiaG9yaXpvbnRhbCIsICJiYXNlIiwgInNldEJvcmRlclNraXBwZWQiLCAiZWRnZSIsICJib3JkZXJTa2lwcGVkIiwgImVuYWJsZUJvcmRlclJhZGl1cyIsICJwYXJzZUVkZ2UiLCAic3dhcCIsICJzdGFydEVuZCIsICJvcmlnIiwgInYxIiwgInYyIiwgInYiLCAic2V0SW5mbGF0ZUFtb3VudCIsICJpbmZsYXRlQW1vdW50IiwgIkJhckNvbnRyb2xsZXIiLCAiaUF4aXNLZXkiLCAidkF4aXNLZXkiLCAib2JqIiwgImJhcnMiLCAiZ2V0QmFzZVBpeGVsIiwgIl9nZXRSdWxlciIsICJ2cGl4ZWxzIiwgImhlYWQiLCAiX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwgImlwaXhlbHMiLCAiX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwgImNlbnRlciIsICJoZWlnaHQiLCAid2lkdGgiLCAiX2dldFN0YWNrcyIsICJsYXN0IiwgImdyb3VwZWQiLCAic2tpcE51bGwiLCAidmFsIiwgImlzTmFOIiwgImluZGV4T2YiLCAiX2dldFN0YWNrQ291bnQiLCAiX2dldFN0YWNrSW5kZXgiLCAibmFtZSIsICJfc3RhcnRQaXhlbCIsICJfZW5kUGl4ZWwiLCAiYmFzZVZhbHVlIiwgIm1pbkJhckxlbmd0aCIsICJmbG9hdGluZyIsICJnZXREYXRhVmlzaWJpbGl0eSIsICJzdGFydFBpeGVsIiwgImdldFBpeGVsRm9yRGVjaW1hbCIsICJlbmRQaXhlbCIsICJnZXRWYWx1ZUZvclBpeGVsIiwgImhhbGZHcmlkIiwgImdldExpbmVXaWR0aEZvclZhbHVlIiwgIm1heEJhclRoaWNrbmVzcyIsICJJbmZpbml0eSIsICJzdGFja0luZGV4IiwgInJlY3RzIiwgIm51bWJlcnMiLCAib3ZlcnJpZGVzIiwgIl9pbmRleF8iLCAib2Zmc2V0IiwgImdyaWQiLCAiX3ZhbHVlXyIsICJiZWdpbkF0WmVybyIsICJCdWJibGVDb250cm9sbGVyIiwgInJhZGl1cyIsICJwb2ludHMiLCAicG9pbnQiLCAiaVBpeGVsIiwgInZQaXhlbCIsICJza2lwIiwgImdldFJhdGlvQW5kT2Zmc2V0IiwgInJvdGF0aW9uIiwgImNpcmN1bWZlcmVuY2UiLCAiY3V0b3V0IiwgInJhdGlvWCIsICJyYXRpb1kiLCAib2Zmc2V0WCIsICJvZmZzZXRZIiwgIlRBVSIsICJzdGFydEFuZ2xlIiwgImVuZEFuZ2xlIiwgInN0YXJ0WCIsICJjb3MiLCAic3RhcnRZIiwgInNpbiIsICJlbmRYIiwgImVuZFkiLCAiY2FsY01heCIsICJhbmdsZSIsICJfYW5nbGVCZXR3ZWVuIiwgImNhbGNNaW4iLCAibWF4WCIsICJtYXhZIiwgIkhBTEZfUEkiLCAibWluWCIsICJQSSIsICJtaW5ZIiwgIkRvdWdobnV0Q29udHJvbGxlciIsICJpbm5lclJhZGl1cyIsICJvdXRlclJhZGl1cyIsICJnZXR0ZXIiLCAiX2dldFJvdGF0aW9uIiwgInRvUmFkaWFucyIsICJfZ2V0Q2lyY3VtZmVyZW5jZSIsICJfZ2V0Um90YXRpb25FeHRlbnRzIiwgImlzRGF0YXNldFZpc2libGUiLCAiYXJjcyIsICJzcGFjaW5nIiwgImdldE1heEJvcmRlcldpZHRoIiwgImdldE1heE9mZnNldCIsICJtYXhTaXplIiwgInRvUGVyY2VudGFnZSIsICJjaGFydFdlaWdodCIsICJfZ2V0UmluZ1dlaWdodCIsICJtYXhXaWR0aCIsICJtYXhIZWlnaHQiLCAibWF4UmFkaXVzIiwgInRvRGltZW5zaW9uIiwgInJhZGl1c0xlbmd0aCIsICJfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCIsICJ0b3RhbCIsICJjYWxjdWxhdGVUb3RhbCIsICJfZ2V0UmluZ1dlaWdodE9mZnNldCIsICJfY2lyY3VtZmVyZW5jZSIsICJhbmltYXRlUm90YXRlIiwgImNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UiLCAiYW5pbWF0aW9uT3B0cyIsICJjZW50ZXJYIiwgImNlbnRlclkiLCAiYW5pbWF0ZVNjYWxlIiwgImFyYyIsICJtZXRhRGF0YSIsICJmb3JtYXROdW1iZXIiLCAibG9jYWxlIiwgImJvcmRlckFsaWduIiwgImJvcmRlcldpZHRoIiwgImhvdmVyQm9yZGVyV2lkdGgiLCAiaG92ZXJPZmZzZXQiLCAicmluZ1dlaWdodE9mZnNldCIsICJ3ZWlnaHQiLCAiZGVzY3JpcHRvcnMiLCAiX3NjcmlwdGFibGUiLCAiX2luZGV4YWJsZSIsICJzdGFydHNXaXRoIiwgImFzcGVjdFJhdGlvIiwgInBsdWdpbnMiLCAibGVnZW5kIiwgImdlbmVyYXRlTGFiZWxzIiwgInBvaW50U3R5bGUiLCAibWFwIiwgInN0eWxlIiwgInRleHQiLCAiZmlsbFN0eWxlIiwgImJhY2tncm91bmRDb2xvciIsICJzdHJva2VTdHlsZSIsICJib3JkZXJDb2xvciIsICJmb250Q29sb3IiLCAibGluZVdpZHRoIiwgIm9uQ2xpY2siLCAiZSIsICJsZWdlbmRJdGVtIiwgInRvZ2dsZURhdGFWaXNpYmlsaXR5IiwgIkxpbmVDb250cm9sbGVyIiwgImxpbmUiLCAiX2RhdGFzZXQiLCAiYW5pbWF0aW9uc0Rpc2FibGVkIiwgIl9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzIiwgIl9zY2FsZVJhbmdlc0NoYW5nZWQiLCAiX2RhdGFzZXRJbmRleCIsICJfZGVjaW1hdGVkIiwgInNob3dMaW5lIiwgInNlZ21lbnQiLCAiYW5pbWF0ZWQiLCAic3BhbkdhcHMiLCAibWF4R2FwTGVuZ3RoIiwgImlzTnVtYmVyIiwgImRpcmVjdFVwZGF0ZSIsICJwb2ludHNDb3VudCIsICJwcmV2UGFyc2VkIiwgIm51bGxEYXRhIiwgImJvcmRlciIsICJmaXJzdFBvaW50IiwgImxhc3RQb2ludCIsICJ1cGRhdGVDb250cm9sUG9pbnRzIiwgIlBvbGFyQXJlYUNvbnRyb2xsZXIiLCAiX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlIiwgImJpbmQiLCAiX3VwZGF0ZVJhZGl1cyIsICJtaW5TaXplIiwgImN1dG91dFBlcmNlbnRhZ2UiLCAiZ2V0VmlzaWJsZURhdGFzZXRDb3VudCIsICJ4Q2VudGVyIiwgInlDZW50ZXIiLCAiZGF0YXNldFN0YXJ0QW5nbGUiLCAiZ2V0SW5kZXhBbmdsZSIsICJkZWZhdWx0QW5nbGUiLCAiY291bnRWaXNpYmxlRWxlbWVudHMiLCAiX2NvbXB1dGVBbmdsZSIsICJnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSIsICJhbmdsZUxpbmVzIiwgImRpc3BsYXkiLCAiY2lyY3VsYXIiLCAicG9pbnRMYWJlbHMiLCAiUGllQ29udHJvbGxlciIsICJSYWRhckNvbnRyb2xsZXIiLCAiX2Z1bGxMb29wIiwgInBvaW50UG9zaXRpb24iLCAiZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlIiwgIlNjYXR0ZXJDb250cm9sbGVyIiwgInJlZ2lzdHJ5IiwgImdldEVsZW1lbnQiLCAiaW50ZXJhY3Rpb24iLCAiYWJzdHJhY3QiLCAiRXJyb3IiLCAiRGF0ZUFkYXB0ZXJCYXNlIiwgIm92ZXJyaWRlIiwgIm1lbWJlcnMiLCAicHJvdG90eXBlIiwgImluaXQiLCAiZm9ybWF0cyIsICJmb3JtYXQiLCAiZGlmZiIsICJzdGFydE9mIiwgImVuZE9mIiwgIl9kYXRlIiwgImJpbmFyeVNlYXJjaCIsICJtZXRhc2V0IiwgImludGVyc2VjdCIsICJsb29rdXBNZXRob2QiLCAiX3JldmVyc2VQaXhlbHMiLCAiX3Jsb29rdXBCeUtleSIsICJfbG9va3VwQnlLZXkiLCAiZWwiLCAiZ2V0UmFuZ2UiLCAibG8iLCAiaGkiLCAiZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zIiwgInBvc2l0aW9uIiwgImhhbmRsZXIiLCAiZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcyIsICJqIiwgImdldERpc3RhbmNlTWV0cmljRm9yQXhpcyIsICJ1c2VYIiwgInVzZVkiLCAicHQxIiwgInB0MiIsICJkZWx0YVgiLCAiZGVsdGFZIiwgInNxcnQiLCAicG93IiwgImdldEludGVyc2VjdEl0ZW1zIiwgInVzZUZpbmFsUG9zaXRpb24iLCAiaW5jbHVkZUludmlzaWJsZSIsICJpc1BvaW50SW5BcmVhIiwgImV2YWx1YXRpb25GdW5jIiwgIl9pc1BvaW50SW5BcmVhIiwgImluUmFuZ2UiLCAiZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zIiwgImdldFByb3BzIiwgImdldEFuZ2xlRnJvbVBvaW50IiwgImdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyIsICJkaXN0YW5jZU1ldHJpYyIsICJtaW5EaXN0YW5jZSIsICJnZXRDZW50ZXJQb2ludCIsICJwb2ludEluQXJlYSIsICJkaXN0YW5jZSIsICJnZXROZWFyZXN0SXRlbXMiLCAiZ2V0QXhpc0l0ZW1zIiwgInJhbmdlTWV0aG9kIiwgImludGVyc2VjdHNJdGVtIiwgIm1vZGVzIiwgImdldFJlbGF0aXZlUG9zaXRpb24iLCAibmVhcmVzdCIsICJTVEFUSUNfUE9TSVRJT05TIiwgImZpbHRlckJ5UG9zaXRpb24iLCAiYXJyYXkiLCAicG9zIiwgImZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyIsICJib3giLCAic29ydEJ5V2VpZ2h0IiwgInYwIiwgIndyYXBCb3hlcyIsICJib3hlcyIsICJsYXlvdXRCb3hlcyIsICJzdGFja1dlaWdodCIsICJidWlsZFN0YWNrcyIsICJsYXlvdXRzIiwgIndyYXAiLCAiaW5jbHVkZXMiLCAiX3N0YWNrIiwgInBsYWNlZCIsICJzZXRMYXlvdXREaW1zIiwgInBhcmFtcyIsICJ2Qm94TWF4V2lkdGgiLCAiaEJveE1heEhlaWdodCIsICJsYXlvdXQiLCAiZnVsbFNpemUiLCAiYXZhaWxhYmxlV2lkdGgiLCAiYXZhaWxhYmxlSGVpZ2h0IiwgImJ1aWxkTGF5b3V0Qm94ZXMiLCAiY2VudGVySG9yaXpvbnRhbCIsICJjZW50ZXJWZXJ0aWNhbCIsICJsZWZ0QW5kVG9wIiwgInJpZ2h0QW5kQm90dG9tIiwgInZlcnRpY2FsIiwgImdldENvbWJpbmVkTWF4IiwgIm1heFBhZGRpbmciLCAidXBkYXRlTWF4UGFkZGluZyIsICJib3hQYWRkaW5nIiwgInVwZGF0ZURpbXMiLCAiZ2V0UGFkZGluZyIsICJuZXdXaWR0aCIsICJvdXRlcldpZHRoIiwgIm5ld0hlaWdodCIsICJvdXRlckhlaWdodCIsICJ3aWR0aENoYW5nZWQiLCAidyIsICJoZWlnaHRDaGFuZ2VkIiwgImgiLCAic2FtZSIsICJvdGhlciIsICJoYW5kbGVNYXhQYWRkaW5nIiwgInVwZGF0ZVBvcyIsICJjaGFuZ2UiLCAiZ2V0TWFyZ2lucyIsICJtYXJnaW5Gb3JQb3NpdGlvbnMiLCAicG9zaXRpb25zIiwgIm1hcmdpbiIsICJmaXRCb3hlcyIsICJyZWZpdEJveGVzIiwgInJlZml0IiwgImNoYW5nZWQiLCAic2V0Qm94RGltcyIsICJwbGFjZUJveGVzIiwgInVzZXJQYWRkaW5nIiwgInBhZGRpbmciLCAiYWRkQm94IiwgIl9sYXllcnMiLCAieiIsICJyZW1vdmVCb3giLCAibGF5b3V0SXRlbSIsICJtaW5QYWRkaW5nIiwgInRvUGFkZGluZyIsICJ2ZXJ0aWNhbEJveGVzIiwgImhvcml6b250YWxCb3hlcyIsICJlYWNoIiwgImJlZm9yZUxheW91dCIsICJ2aXNpYmxlVmVydGljYWxCb3hDb3VudCIsICJCYXNlUGxhdGZvcm0iLCAiYWNxdWlyZUNvbnRleHQiLCAiY2FudmFzIiwgInJlbGVhc2VDb250ZXh0IiwgImFkZEV2ZW50TGlzdGVuZXIiLCAibGlzdGVuZXIiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJnZXREZXZpY2VQaXhlbFJhdGlvIiwgImdldE1heGltdW1TaXplIiwgImlzQXR0YWNoZWQiLCAidXBkYXRlQ29uZmlnIiwgIkJhc2ljUGxhdGZvcm0iLCAiRVhQQU5ET19LRVkiLCAiRVZFTlRfVFlQRVMiLCAidG91Y2hzdGFydCIsICJ0b3VjaG1vdmUiLCAidG91Y2hlbmQiLCAicG9pbnRlcmVudGVyIiwgInBvaW50ZXJkb3duIiwgInBvaW50ZXJtb3ZlIiwgInBvaW50ZXJ1cCIsICJwb2ludGVybGVhdmUiLCAicG9pbnRlcm91dCIsICJpc051bGxPckVtcHR5IiwgImluaXRDYW52YXMiLCAicmVuZGVySGVpZ2h0IiwgImdldEF0dHJpYnV0ZSIsICJyZW5kZXJXaWR0aCIsICJib3hTaXppbmciLCAiZGlzcGxheVdpZHRoIiwgInJlYWRVc2VkU2l6ZSIsICJkaXNwbGF5SGVpZ2h0IiwgImV2ZW50TGlzdGVuZXJPcHRpb25zIiwgInN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCAicGFzc2l2ZSIsICJhZGRMaXN0ZW5lciIsICJub2RlIiwgInJlbW92ZUxpc3RlbmVyIiwgImZyb21OYXRpdmVFdmVudCIsICJuYXRpdmUiLCAibm9kZUxpc3RDb250YWlucyIsICJub2RlTGlzdCIsICJjb250YWlucyIsICJjcmVhdGVBdHRhY2hPYnNlcnZlciIsICJvYnNlcnZlciIsICJNdXRhdGlvbk9ic2VydmVyIiwgImVudHJpZXMiLCAidHJpZ2dlciIsICJhZGRlZE5vZGVzIiwgInJlbW92ZWROb2RlcyIsICJvYnNlcnZlIiwgImRvY3VtZW50IiwgImNoaWxkTGlzdCIsICJzdWJ0cmVlIiwgImNyZWF0ZURldGFjaE9ic2VydmVyIiwgImRycExpc3RlbmluZ0NoYXJ0cyIsICJvbGREZXZpY2VQaXhlbFJhdGlvIiwgIm9uV2luZG93UmVzaXplIiwgImRwciIsICJkZXZpY2VQaXhlbFJhdGlvIiwgInJlc2l6ZSIsICJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsICJsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsICJ1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzIiwgImNyZWF0ZVJlc2l6ZU9ic2VydmVyIiwgImNvbnRhaW5lciIsICJfZ2V0UGFyZW50Tm9kZSIsICJ0aHJvdHRsZWQiLCAiY2xpZW50V2lkdGgiLCAiUmVzaXplT2JzZXJ2ZXIiLCAiY29udGVudFJlY3QiLCAicmVsZWFzZU9ic2VydmVyIiwgImRpc2Nvbm5lY3QiLCAiY3JlYXRlUHJveHlBbmRMaXN0ZW4iLCAicHJveHkiLCAiRG9tUGxhdGZvcm0iLCAicmVtb3ZlQXR0cmlidXRlIiwgInNldEF0dHJpYnV0ZSIsICJwcm94aWVzIiwgIiRwcm94aWVzIiwgImhhbmRsZXJzIiwgImF0dGFjaCIsICJkZXRhY2giLCAiaXNDb25uZWN0ZWQiLCAiX2RldGVjdFBsYXRmb3JtIiwgIl9pc0RvbVN1cHBvcnRlZCIsICJPZmZzY3JlZW5DYW52YXMiLCAiRWxlbWVudCIsICJ0b29sdGlwUG9zaXRpb24iLCAiaGFzVmFsdWUiLCAiZmluYWwiLCAicmV0IiwgImRlZmF1bHRSb3V0ZXMiLCAiYXV0b1NraXAiLCAidGlja09wdHMiLCAiZGV0ZXJtaW5lZE1heFRpY2tzIiwgImRldGVybWluZU1heFRpY2tzIiwgInRpY2tzTGltaXQiLCAibWF4VGlja3NMaW1pdCIsICJtYWpvckluZGljZXMiLCAibWFqb3IiLCAiZW5hYmxlZCIsICJnZXRNYWpvckluZGljZXMiLCAibnVtTWFqb3JJbmRpY2VzIiwgImZpcnN0IiwgIm5ld1RpY2tzIiwgInNraXBNYWpvcnMiLCAiY2FsY3VsYXRlU3BhY2luZyIsICJhdmdNYWpvclNwYWNpbmciLCAicm91bmQiLCAidGlja0xlbmd0aCIsICJfdGlja1NpemUiLCAibWF4U2NhbGUiLCAibWF4Q2hhcnQiLCAiX21heExlbmd0aCIsICJldmVuTWFqb3JTcGFjaW5nIiwgImdldEV2ZW5TcGFjaW5nIiwgImZhY3RvcnMiLCAiX2ZhY3Rvcml6ZSIsICJyZXN1bHQiLCAiY2VpbCIsICJtYWpvclN0YXJ0IiwgIm1ham9yRW5kIiwgImxlbiIsICJyZXZlcnNlQWxpZ24iLCAiYWxpZ24iLCAib2Zmc2V0RnJvbUVkZ2UiLCAiZ2V0VGlja3NMaW1pdCIsICJ0aWNrc0xlbmd0aCIsICJzYW1wbGUiLCAibnVtSXRlbXMiLCAiaW5jcmVtZW50IiwgImdldFBpeGVsRm9yR3JpZExpbmUiLCAib2Zmc2V0R3JpZExpbmVzIiwgInZhbGlkSW5kZXgiLCAiZXBzaWxvbiIsICJsaW5lVmFsdWUiLCAiZ2FyYmFnZUNvbGxlY3QiLCAiY2FjaGVzIiwgImdjIiwgImdjTGVuIiwgImdldFRpY2tNYXJrTGVuZ3RoIiwgImRyYXdUaWNrcyIsICJnZXRUaXRsZUhlaWdodCIsICJmYWxsYmFjayIsICJmb250IiwgInRvRm9udCIsICJsaW5lcyIsICJsaW5lSGVpZ2h0IiwgImNyZWF0ZVNjYWxlQ29udGV4dCIsICJjcmVhdGVUaWNrQ29udGV4dCIsICJ0aXRsZUFsaWduIiwgIl90b0xlZnRSaWdodENlbnRlciIsICJ0aXRsZUFyZ3MiLCAidGl0bGVYIiwgInRpdGxlWSIsICJfYWxpZ25TdGFydEVuZCIsICJwb3NpdGlvbkF4aXNJRCIsICJTY2FsZSIsICJfbWFyZ2lucyIsICJwYWRkaW5nVG9wIiwgInBhZGRpbmdCb3R0b20iLCAicGFkZGluZ0xlZnQiLCAicGFkZGluZ1JpZ2h0IiwgImxhYmVsUm90YXRpb24iLCAiX3JhbmdlIiwgIl9ncmlkTGluZUl0ZW1zIiwgIl9sYWJlbEl0ZW1zIiwgIl9sYWJlbFNpemVzIiwgIl9sb25nZXN0VGV4dENhY2hlIiwgIl91c2VyTWF4IiwgIl91c2VyTWluIiwgIl9zdWdnZXN0ZWRNYXgiLCAiX3N1Z2dlc3RlZE1pbiIsICJfdGlja3NMZW5ndGgiLCAiX2JvcmRlclZhbHVlIiwgIl9kYXRhTGltaXRzQ2FjaGVkIiwgInNldENvbnRleHQiLCAic3VnZ2VzdGVkTWluIiwgInN1Z2dlc3RlZE1heCIsICJmaW5pdGVPckRlZmF1bHQiLCAibWV0YXMiLCAiZ2V0VGlja3MiLCAieExhYmVscyIsICJ5TGFiZWxzIiwgImdldExhYmVsSXRlbXMiLCAiX2NvbXB1dGVMYWJlbEl0ZW1zIiwgImJlZm9yZVVwZGF0ZSIsICJtYXJnaW5zIiwgImdyYWNlIiwgInNhbXBsZVNpemUiLCAiYmVmb3JlU2V0RGltZW5zaW9ucyIsICJzZXREaW1lbnNpb25zIiwgImFmdGVyU2V0RGltZW5zaW9ucyIsICJiZWZvcmVEYXRhTGltaXRzIiwgImRldGVybWluZURhdGFMaW1pdHMiLCAiYWZ0ZXJEYXRhTGltaXRzIiwgIl9hZGRHcmFjZSIsICJiZWZvcmVCdWlsZFRpY2tzIiwgImJ1aWxkVGlja3MiLCAiYWZ0ZXJCdWlsZFRpY2tzIiwgInNhbXBsaW5nRW5hYmxlZCIsICJfY29udmVydFRpY2tzVG9MYWJlbHMiLCAiYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJjYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwgImFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJzb3VyY2UiLCAiYWZ0ZXJBdXRvU2tpcCIsICJiZWZvcmVGaXQiLCAiZml0IiwgImFmdGVyRml0IiwgImFmdGVyVXBkYXRlIiwgInJldmVyc2VQaXhlbHMiLCAiX2FsaWduVG9QaXhlbHMiLCAiYWxpZ25Ub1BpeGVscyIsICJfY2FsbEhvb2tzIiwgIm5vdGlmeVBsdWdpbnMiLCAiYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uIiwgImdlbmVyYXRlVGlja0xhYmVscyIsICJjYWxsYmFjayIsICJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsICJudW1UaWNrcyIsICJtaW5Sb3RhdGlvbiIsICJtYXhSb3RhdGlvbiIsICJ0aWNrV2lkdGgiLCAibWF4TGFiZWxEaWFnb25hbCIsICJfaXNWaXNpYmxlIiwgImxhYmVsU2l6ZXMiLCAiX2dldExhYmVsU2l6ZXMiLCAibWF4TGFiZWxXaWR0aCIsICJ3aWRlc3QiLCAibWF4TGFiZWxIZWlnaHQiLCAiaGlnaGVzdCIsICJfbGltaXRWYWx1ZSIsICJ0aXRsZSIsICJ0b0RlZ3JlZXMiLCAiYXNpbiIsICJ0aXRsZU9wdHMiLCAiZ3JpZE9wdHMiLCAidGl0bGVIZWlnaHQiLCAidGlja1BhZGRpbmciLCAiYW5nbGVSYWRpYW5zIiwgImxhYmVsSGVpZ2h0IiwgIm1pcnJvciIsICJsYWJlbFdpZHRoIiwgIl9jYWxjdWxhdGVQYWRkaW5nIiwgIl9oYW5kbGVNYXJnaW5zIiwgImlzUm90YXRlZCIsICJsYWJlbHNCZWxvd1RpY2tzIiwgIm9mZnNldExlZnQiLCAib2Zmc2V0UmlnaHQiLCAiaXNGdWxsU2l6ZSIsICJfY29tcHV0ZUxhYmVsU2l6ZXMiLCAid2lkdGhzIiwgImhlaWdodHMiLCAid2lkZXN0TGFiZWxTaXplIiwgImhpZ2hlc3RMYWJlbFNpemUiLCAiamxlbiIsICJ0aWNrRm9udCIsICJmb250U3RyaW5nIiwgIm5lc3RlZExhYmVsIiwgIl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zIiwgInN0cmluZyIsICJfbWVhc3VyZVRleHQiLCAidmFsdWVBdCIsICJpZHgiLCAicGl4ZWwiLCAiZGVjaW1hbCIsICJfaW50MTZSYW5nZSIsICJfYWxpZ25QaXhlbCIsICJnZXREZWNpbWFsRm9yUGl4ZWwiLCAiZ2V0QmFzZVZhbHVlIiwgIm9wdGlvblRpY2tzIiwgInJvdCIsICJhdXRvU2tpcFBhZGRpbmciLCAiX2NvbXB1dGVHcmlkTGluZUl0ZW1zIiwgInRsIiwgImJvcmRlck9wdHMiLCAiYXhpc1dpZHRoIiwgImF4aXNIYWxmV2lkdGgiLCAiYWxpZ25Cb3JkZXJWYWx1ZSIsICJib3JkZXJWYWx1ZSIsICJhbGlnbmVkTGluZVZhbHVlIiwgInR4MSIsICJ0eTEiLCAidHgyIiwgInR5MiIsICJ4MSIsICJ5MSIsICJ4MiIsICJ5MiIsICJsaW1pdCIsICJzdGVwIiwgIm9wdHNBdEluZGV4IiwgIm9wdHNBdEluZGV4Qm9yZGVyIiwgImxpbmVDb2xvciIsICJib3JkZXJEYXNoIiwgImRhc2giLCAiYm9yZGVyRGFzaE9mZnNldCIsICJkYXNoT2Zmc2V0IiwgInRpY2tDb2xvciIsICJ0aWNrQm9yZGVyRGFzaCIsICJ0aWNrQm9yZGVyRGFzaE9mZnNldCIsICJjcm9zc0FsaWduIiwgInRpY2tBbmRQYWRkaW5nIiwgImhUaWNrQW5kUGFkZGluZyIsICJ0ZXh0QWxpZ24iLCAibGluZUNvdW50IiwgInRleHRPZmZzZXQiLCAidGV4dEJhc2VsaW5lIiwgIl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50IiwgIl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50IiwgImxhYmVsT2Zmc2V0IiwgImhhbGZDb3VudCIsICJzdHJva2VDb2xvciIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAic3Ryb2tlV2lkdGgiLCAidGV4dFN0cm9rZVdpZHRoIiwgInRpY2tUZXh0QWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3AiLCAibGFiZWxQYWRkaW5nIiwgImJhY2tkcm9wUGFkZGluZyIsICJiYWNrZHJvcENvbG9yIiwgInRyYW5zbGF0aW9uIiwgIl9jb21wdXRlTGFiZWxBcmVhIiwgImRyYXdCYWNrZ3JvdW5kIiwgInNhdmUiLCAiZmlsbFJlY3QiLCAicmVzdG9yZSIsICJmaW5kSW5kZXgiLCAiZHJhd0dyaWQiLCAiZHJhd0xpbmUiLCAicDEiLCAicDIiLCAic2V0TGluZURhc2giLCAibGluZURhc2hPZmZzZXQiLCAiYmVnaW5QYXRoIiwgIm1vdmVUbyIsICJsaW5lVG8iLCAic3Ryb2tlIiwgImRyYXdPbkNoYXJ0QXJlYSIsICJkcmF3Qm9yZGVyIiwgImxhc3RMaW5lV2lkdGgiLCAiZHJhd0xhYmVscyIsICJjbGlwQXJlYSIsICJyZW5kZXJUZXh0T3B0aW9ucyIsICJyZW5kZXJUZXh0IiwgInVuY2xpcEFyZWEiLCAiZHJhd1RpdGxlIiwgInR6IiwgImd6IiwgImJ6IiwgImF4aXNJRCIsICJfbWF4RGlnaXRzIiwgImZvbnRTaXplIiwgIlR5cGVkUmVnaXN0cnkiLCAic2NvcGUiLCAiY3JlYXRlIiwgImlzRm9yVHlwZSIsICJpc1Byb3RvdHlwZU9mIiwgInJlZ2lzdGVyIiwgInByb3RvIiwgImdldFByb3RvdHlwZU9mIiwgInBhcmVudFNjb3BlIiwgImlzSUNoYXJ0Q29tcG9uZW50IiwgInJlZ2lzdGVyRGVmYXVsdHMiLCAidW5yZWdpc3RlciIsICJpdGVtRGVmYXVsdHMiLCAibWVyZ2UiLCAicm91dGVEZWZhdWx0cyIsICJkZXNjcmliZSIsICJyb3V0ZXMiLCAicHJvcGVydHkiLCAicHJvcGVydHlQYXJ0cyIsICJzcGxpdCIsICJzb3VyY2VOYW1lIiwgInNvdXJjZVNjb3BlIiwgImpvaW4iLCAicGFydHMiLCAidGFyZ2V0TmFtZSIsICJ0YXJnZXRTY29wZSIsICJyb3V0ZSIsICJSZWdpc3RyeSIsICJjb250cm9sbGVycyIsICJfdHlwZWRSZWdpc3RyaWVzIiwgIl9lYWNoIiwgImFkZENvbnRyb2xsZXJzIiwgImFkZFBsdWdpbnMiLCAiYWRkU2NhbGVzIiwgImdldENvbnRyb2xsZXIiLCAiX2dldCIsICJnZXRQbHVnaW4iLCAiZ2V0U2NhbGUiLCAicmVtb3ZlQ29udHJvbGxlcnMiLCAicmVtb3ZlRWxlbWVudHMiLCAicmVtb3ZlUGx1Z2lucyIsICJyZW1vdmVTY2FsZXMiLCAidHlwZWRSZWdpc3RyeSIsICJhcmciLCAicmVnIiwgIl9nZXRSZWdpc3RyeUZvclR5cGUiLCAiX2V4ZWMiLCAiaXRlbVJlZyIsICJjb21wb25lbnQiLCAiY2FtZWxNZXRob2QiLCAiX2NhcGl0YWxpemUiLCAiUGx1Z2luU2VydmljZSIsICJfaW5pdCIsICJub3RpZnkiLCAiaG9vayIsICJfY3JlYXRlRGVzY3JpcHRvcnMiLCAiX2Rlc2NyaXB0b3JzIiwgImRlc2NyaXB0b3IiLCAicGx1Z2luIiwgImNhbGxDYWxsYmFjayIsICJjYW5jZWxhYmxlIiwgImludmFsaWRhdGUiLCAiX29sZENhY2hlIiwgIl9ub3RpZnlTdGF0ZUNoYW5nZXMiLCAiYWxsUGx1Z2lucyIsICJjcmVhdGVEZXNjcmlwdG9ycyIsICJwcmV2aW91c0Rlc2NyaXB0b3JzIiwgInNvbWUiLCAibG9jYWxJZHMiLCAibG9jYWwiLCAiZ2V0T3B0cyIsICJwbHVnaW5PcHRzIiwgInBsdWdpblNjb3BlS2V5cyIsICJzY3JpcHRhYmxlIiwgImluZGV4YWJsZSIsICJhbGxLZXlzIiwgImdldEluZGV4QXhpcyIsICJkYXRhc2V0RGVmYXVsdHMiLCAiZGF0YXNldE9wdGlvbnMiLCAiZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRCIsICJnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzIiwgImlkTWF0Y2hlc0F4aXMiLCAiYXhpc0Zyb21Qb3NpdGlvbiIsICJkZXRlcm1pbmVBeGlzIiwgInNjYWxlT3B0aW9ucyIsICJ0b0xvd2VyQ2FzZSIsICJnZXRBeGlzRnJvbURhdGFzZXQiLCAicmV0cmlldmVBeGlzRnJvbURhdGFzZXRzIiwgImJvdW5kRHMiLCAiZCIsICJtZXJnZVNjYWxlQ29uZmlnIiwgImNoYXJ0RGVmYXVsdHMiLCAiY29uZmlnU2NhbGVzIiwgImNoYXJ0SW5kZXhBeGlzIiwgInNjYWxlQ29uZiIsICJlcnJvciIsICJfcHJveHkiLCAiZGVmYXVsdElkIiwgImRlZmF1bHRTY2FsZU9wdGlvbnMiLCAibWVyZ2VJZiIsICJkZWZhdWx0SUQiLCAiaW5pdE9wdGlvbnMiLCAiaW5pdERhdGEiLCAiaW5pdENvbmZpZyIsICJrZXlDYWNoZSIsICJrZXlzQ2FjaGVkIiwgIlNldCIsICJjYWNoZWRLZXlzIiwgImdlbmVyYXRlIiwgImFkZElmRm91bmQiLCAiQ29uZmlnIiwgIl9jb25maWciLCAiX3Njb3BlQ2FjaGUiLCAiX3Jlc29sdmVyQ2FjaGUiLCAicGxhdGZvcm0iLCAiY2xlYXJDYWNoZSIsICJjbGVhciIsICJkYXRhc2V0VHlwZSIsICJhZGRpdGlvbmFsT3B0aW9uU2NvcGVzIiwgIl9jYWNoZWRTY29wZXMiLCAibWFpblNjb3BlIiwgInJlc2V0Q2FjaGUiLCAia2V5TGlzdHMiLCAiY2hhcnRPcHRpb25TY29wZXMiLCAicmVzb2x2ZXIiLCAic3ViUHJlZml4ZXMiLCAiZ2V0UmVzb2x2ZXIiLCAibmVlZENvbnRleHQiLCAiaXNGdW5jdGlvbiIsICJzdWJSZXNvbHZlciIsICJfYXR0YWNoQ29udGV4dCIsICJkZXNjcmlwdG9yRGVmYXVsdHMiLCAicmVzb2x2ZXJDYWNoZSIsICJfY3JlYXRlUmVzb2x2ZXIiLCAicCIsICJoYXNGdW5jdGlvbiIsICJpc1NjcmlwdGFibGUiLCAiaXNJbmRleGFibGUiLCAiS05PV05fUE9TSVRJT05TIiwgInBvc2l0aW9uSXNIb3Jpem9udGFsIiwgImNvbXBhcmUyTGV2ZWwiLCAibDEiLCAibDIiLCAib25BbmltYXRpb25zQ29tcGxldGUiLCAib25Db21wbGV0ZSIsICJvbkFuaW1hdGlvblByb2dyZXNzIiwgIm9uUHJvZ3Jlc3MiLCAiZ2V0Q2FudmFzIiwgImdldEVsZW1lbnRCeUlkIiwgImluc3RhbmNlcyIsICJnZXRDaGFydCIsICJjIiwgIm1vdmVOdW1lcmljS2V5cyIsICJpbnRLZXkiLCAiZGV0ZXJtaW5lTGFzdEV2ZW50IiwgImxhc3RFdmVudCIsICJpbkNoYXJ0QXJlYSIsICJpc0NsaWNrIiwgImdldFNpemVGb3JBcmVhIiwgImZpZWxkIiwgImdldERhdGFzZXRBcmVhIiwgIkNoYXJ0IiwgImludmFsaWRhdGVQbHVnaW5zIiwgInVzZXJDb25maWciLCAiaW5pdGlhbENhbnZhcyIsICJleGlzdGluZ0NoYXJ0IiwgInVpZCIsICJfb3B0aW9ucyIsICJfYXNwZWN0UmF0aW8iLCAiX21ldGFzZXRzIiwgIl9sYXN0RXZlbnQiLCAiX2xpc3RlbmVycyIsICJfcmVzcG9uc2l2ZUxpc3RlbmVycyIsICJfc29ydGVkTWV0YXNldHMiLCAiX3BsdWdpbnMiLCAiX2hpZGRlbkluZGljZXMiLCAiYXR0YWNoZWQiLCAiX2RvUmVzaXplIiwgImRlYm91bmNlIiwgInJlc2l6ZURlbGF5IiwgIl9pbml0aWFsaXplIiwgIm1haW50YWluQXNwZWN0UmF0aW8iLCAicmVzcG9uc2l2ZSIsICJyZXRpbmFTY2FsZSIsICJiaW5kRXZlbnRzIiwgImNsZWFyQ2FudmFzIiwgIl9yZXNpemUiLCAiX3Jlc2l6ZUJlZm9yZURyYXciLCAibmV3U2l6ZSIsICJuZXdSYXRpbyIsICJvblJlc2l6ZSIsICJyZW5kZXIiLCAiZW5zdXJlU2NhbGVzSGF2ZUlEcyIsICJzY2FsZXNPcHRpb25zIiwgImF4aXNPcHRpb25zIiwgImJ1aWxkT3JVcGRhdGVTY2FsZXMiLCAic2NhbGVPcHRzIiwgInVwZGF0ZWQiLCAiaXNSYWRpYWwiLCAiZHBvc2l0aW9uIiwgImR0eXBlIiwgInNjYWxlVHlwZSIsICJzY2FsZUNsYXNzIiwgImhhc1VwZGF0ZWQiLCAiX3VwZGF0ZU1ldGFzZXRzIiwgIl9kZXN0cm95RGF0YXNldE1ldGEiLCAic2xpY2UiLCAiX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzIiwgImJ1aWxkT3JVcGRhdGVDb250cm9sbGVycyIsICJuZXdDb250cm9sbGVycyIsICJvcmRlciIsICJ2aXNpYmxlIiwgIkNvbnRyb2xsZXJDbGFzcyIsICJfcmVzZXRFbGVtZW50cyIsICJhbmltc0Rpc2FibGVkIiwgIl91cGRhdGVTY2FsZXMiLCAiX2NoZWNrRXZlbnRCaW5kaW5ncyIsICJfdXBkYXRlSGlkZGVuSW5kaWNlcyIsICJfbWluUGFkZGluZyIsICJhdXRvUGFkZGluZyIsICJfdXBkYXRlTGF5b3V0IiwgIl91cGRhdGVEYXRhc2V0cyIsICJfZXZlbnRIYW5kbGVyIiwgIl91cGRhdGVIb3ZlclN0eWxlcyIsICJleGlzdGluZ0V2ZW50cyIsICJuZXdFdmVudHMiLCAiZXZlbnRzIiwgInNldHNFcXVhbCIsICJ1bmJpbmRFdmVudHMiLCAiY2hhbmdlcyIsICJfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzIiwgImRhdGFzZXRDb3VudCIsICJtYWtlU2V0IiwgImNoYW5nZVNldCIsICJub0FyZWEiLCAiX2lkeCIsICJfdXBkYXRlRGF0YXNldCIsICJsYXllcnMiLCAiX2RyYXdEYXRhc2V0cyIsICJfZHJhd0RhdGFzZXQiLCAidXNlQ2xpcCIsICJnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlIiwgIkludGVyYWN0aW9uIiwgInNldERhdGFzZXRWaXNpYmlsaXR5IiwgIl91cGRhdGVWaXNpYmlsaXR5IiwgImhpZGUiLCAic2hvdyIsICJfc3RvcCIsICJkZXN0cm95IiwgInRvQmFzZTY0SW1hZ2UiLCAidG9EYXRhVVJMIiwgImJpbmRVc2VyRXZlbnRzIiwgImJpbmRSZXNwb25zaXZlRXZlbnRzIiwgIl9hZGQiLCAiX3JlbW92ZSIsICJkZXRhY2hlZCIsICJ1cGRhdGVIb3ZlclN0eWxlIiwgInByZWZpeCIsICJnZXRBY3RpdmVFbGVtZW50cyIsICJzZXRBY3RpdmVFbGVtZW50cyIsICJhY3RpdmVFbGVtZW50cyIsICJsYXN0QWN0aXZlIiwgIl9lbGVtZW50c0VxdWFsIiwgInBsdWdpbklkIiwgInJlcGxheSIsICJob3Zlck9wdGlvbnMiLCAiaG92ZXIiLCAiZGVhY3RpdmF0ZWQiLCAiYWN0aXZhdGVkIiwgImV2ZW50RmlsdGVyIiwgIl9oYW5kbGVFdmVudCIsICJfZ2V0QWN0aXZlRWxlbWVudHMiLCAiX2lzQ2xpY2tFdmVudCIsICJvbkhvdmVyIiwgInZlcnNpb24iLCAiY2xpcEFyYyIsICJwaXhlbE1hcmdpbiIsICJhbmdsZU1hcmdpbiIsICJjbG9zZVBhdGgiLCAidG9SYWRpdXNDb3JuZXJzIiwgIl9yZWFkVmFsdWVUb1Byb3BzIiwgInBhcnNlQm9yZGVyUmFkaXVzIiwgImFuZ2xlRGVsdGEiLCAibyIsICJib3JkZXJSYWRpdXMiLCAiaGFsZlRoaWNrbmVzcyIsICJpbm5lckxpbWl0IiwgImNvbXB1dGVPdXRlckxpbWl0IiwgIm91dGVyQXJjTGltaXQiLCAib3V0ZXJTdGFydCIsICJvdXRlckVuZCIsICJpbm5lclN0YXJ0IiwgImlubmVyRW5kIiwgInJUaGV0YVRvWFkiLCAidGhldGEiLCAicGF0aEFyYyIsICJpbm5lclIiLCAic3BhY2luZ09mZnNldCIsICJhbHBoYSIsICJub1NwYWNpbmdJbm5lclJhZGl1cyIsICJub1NwYWNpbmdPdXRlclJhZGl1cyIsICJhdk5vZ1NwYWNpbmdSYWRpdXMiLCAiYWRqdXN0ZWRBbmdsZSIsICJiZXRhIiwgImFuZ2xlT2Zmc2V0IiwgIm91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyIsICJvdXRlckVuZEFkanVzdGVkUmFkaXVzIiwgIm91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlIiwgIm91dGVyRW5kQWRqdXN0ZWRBbmdsZSIsICJpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMiLCAiaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyIsICJpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSIsICJpbm5lckVuZEFkanVzdGVkQW5nbGUiLCAib3V0ZXJNaWRBZGp1c3RlZEFuZ2xlIiwgInBDZW50ZXIiLCAicDQiLCAiaW5uZXJNaWRBZGp1c3RlZEFuZ2xlIiwgInA4IiwgIm91dGVyU3RhcnRYIiwgIm91dGVyU3RhcnRZIiwgIm91dGVyRW5kWCIsICJvdXRlckVuZFkiLCAiZHJhd0FyYyIsICJmdWxsQ2lyY2xlcyIsICJib3JkZXJKb2luU3R5bGUiLCAiaW5uZXIiLCAibGluZUpvaW4iLCAiQXJjRWxlbWVudCIsICJjaGFydFgiLCAiY2hhcnRZIiwgInJBZGp1c3QiLCAiYmV0d2VlbkFuZ2xlcyIsICJ3aXRoaW5SYWRpdXMiLCAiX2lzQmV0d2VlbiIsICJoYWxmQW5nbGUiLCAiaGFsZlJhZGl1cyIsICJ0cmFuc2xhdGUiLCAiZml4IiwgInJhZGl1c09mZnNldCIsICJzZXRTdHlsZSIsICJsaW5lQ2FwIiwgImJvcmRlckNhcFN0eWxlIiwgInByZXZpb3VzIiwgImdldExpbmVNZXRob2QiLCAic3RlcHBlZCIsICJfc3RlcHBlZExpbmVUbyIsICJ0ZW5zaW9uIiwgImN1YmljSW50ZXJwb2xhdGlvbk1vZGUiLCAiX2JlemllckN1cnZlVG8iLCAicGF0aFZhcnMiLCAicGFyYW1zU3RhcnQiLCAicGFyYW1zRW5kIiwgInNlZ21lbnRTdGFydCIsICJzZWdtZW50RW5kIiwgIm91dHNpZGUiLCAicGF0aFNlZ21lbnQiLCAibGluZU1ldGhvZCIsICJmYXN0UGF0aFNlZ21lbnQiLCAiYXZnWCIsICJjb3VudFgiLCAicHJldlgiLCAibGFzdFkiLCAicG9pbnRJbmRleCIsICJkcmF3WCIsICJ0cnVuY1giLCAiX2dldFNlZ21lbnRNZXRob2QiLCAidXNlRmFzdFBhdGgiLCAiX2dldEludGVycG9sYXRpb25NZXRob2QiLCAiX3N0ZXBwZWRJbnRlcnBvbGF0aW9uIiwgIl9iZXppZXJJbnRlcnBvbGF0aW9uIiwgIl9wb2ludEluTGluZSIsICJzdHJva2VQYXRoV2l0aENhY2hlIiwgInBhdGgiLCAiX3BhdGgiLCAiUGF0aDJEIiwgInN0cm9rZVBhdGhEaXJlY3QiLCAic2VnbWVudHMiLCAic2VnbWVudE1ldGhvZCIsICJ1c2VQYXRoMkQiLCAiTGluZUVsZW1lbnQiLCAiX3BvaW50cyIsICJfc2VnbWVudHMiLCAiX3BvaW50c1VwZGF0ZWQiLCAiX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCAiX2NvbXB1dGVTZWdtZW50cyIsICJpbnRlcnBvbGF0ZSIsICJfYm91bmRTZWdtZW50cyIsICJfaW50ZXJwb2xhdGUiLCAiaW50ZXJwb2xhdGVkIiwgImNhcEJlemllclBvaW50cyIsICJoaXRSYWRpdXMiLCAiUG9pbnRFbGVtZW50IiwgIm1vdXNlWCIsICJtb3VzZVkiLCAiaW5YUmFuZ2UiLCAiaW5ZUmFuZ2UiLCAiaG92ZXJSYWRpdXMiLCAiZHJhd1BvaW50IiwgImdldEJhckJvdW5kcyIsICJiYXIiLCAiaGFsZiIsICJza2lwT3JMaW1pdCIsICJwYXJzZUJvcmRlcldpZHRoIiwgIm1heFciLCAibWF4SCIsICJ0b1RSQkwiLCAidG9UUkJMQ29ybmVycyIsICJtYXhSIiwgImVuYWJsZUJvcmRlciIsICJ0b3BMZWZ0IiwgInRvcFJpZ2h0IiwgImJvdHRvbUxlZnQiLCAiYm90dG9tUmlnaHQiLCAiYm91bmRpbmdSZWN0cyIsICJib3VuZHMiLCAib3V0ZXIiLCAic2tpcFgiLCAic2tpcFkiLCAic2tpcEJvdGgiLCAiaGFzUmFkaXVzIiwgImFkZE5vcm1hbFJlY3RQYXRoIiwgInJlY3QiLCAiaW5mbGF0ZVJlY3QiLCAiYW1vdW50IiwgInJlZlJlY3QiLCAiQmFyRWxlbWVudCIsICJhZGRSZWN0UGF0aCIsICJhZGRSb3VuZGVkUmVjdFBhdGgiLCAiQk9SREVSX0NPTE9SUyIsICJCQUNLR1JPVU5EX0NPTE9SUyIsICJyZXBsYWNlIiwgImdldEJvcmRlckNvbG9yIiwgImdldEJhY2tncm91bmRDb2xvciIsICJjb2xvcml6ZURlZmF1bHREYXRhc2V0IiwgImNvbG9yaXplRG91Z2hudXREYXRhc2V0IiwgImNvbG9yaXplUG9sYXJBcmVhRGF0YXNldCIsICJnZXRDb2xvcml6ZXIiLCAiY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyIsICJrIiwgImNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbiIsICJmb3JjZU92ZXJyaWRlIiwgIl9hcmdzIiwgImNoYXJ0T3B0aW9ucyIsICJjb2xvcml6ZXIiLCAibHR0YkRlY2ltYXRpb24iLCAic2FtcGxlcyIsICJkZWNpbWF0ZWQiLCAiYnVja2V0V2lkdGgiLCAic2FtcGxlZEluZGV4IiwgImVuZEluZGV4IiwgIm1heEFyZWFQb2ludCIsICJtYXhBcmVhIiwgIm5leHRBIiwgImF2Z1kiLCAiYXZnUmFuZ2VTdGFydCIsICJhdmdSYW5nZUVuZCIsICJhdmdSYW5nZUxlbmd0aCIsICJyYW5nZU9mZnMiLCAicmFuZ2VUbyIsICJwb2ludEF4IiwgInBvaW50QXkiLCAibWluTWF4RGVjaW1hdGlvbiIsICJtaW5JbmRleCIsICJtYXhJbmRleCIsICJzdGFydEluZGV4IiwgInhNaW4iLCAieE1heCIsICJkeCIsICJsYXN0SW5kZXgiLCAiaW50ZXJtZWRpYXRlSW5kZXgxIiwgImludGVybWVkaWF0ZUluZGV4MiIsICJjbGVhbkRlY2ltYXRlZERhdGFzZXQiLCAiZGVmaW5lUHJvcGVydHkiLCAiY29uZmlndXJhYmxlIiwgImVudW1lcmFibGUiLCAid3JpdGFibGUiLCAiY2xlYW5EZWNpbWF0ZWREYXRhIiwgImdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkIiwgInBvaW50Q291bnQiLCAiYWxnb3JpdGhtIiwgImJlZm9yZUVsZW1lbnRzVXBkYXRlIiwgInhBeGlzIiwgInRocmVzaG9sZCIsICJ0cG9pbnRzIiwgIl9maW5kU2VnbWVudEVuZCIsICJfZ2V0Qm91bmRzIiwgInRhcmdldFNlZ21lbnRzIiwgInRndCIsICJzdWJCb3VuZHMiLCAiZmlsbFNvdXJjZXMiLCAiX2JvdW5kU2VnbWVudCIsICJmaWxsU291cmNlIiwgIl9nZXRFZGdlIiwgIl9ub3JtYWxpemVBbmdsZSIsICJfcG9pbnRzRnJvbVNlZ21lbnRzIiwgImJvdW5kYXJ5IiwgImxpbmVQb2ludHMiLCAiX2NyZWF0ZUJvdW5kYXJ5TGluZSIsICJfc2hvdWxkQXBwbHlGaWxsIiwgIl9yZXNvbHZlVGFyZ2V0IiwgInNvdXJjZXMiLCAicHJvcGFnYXRlIiwgInZpc2l0ZWQiLCAiX2RlY29kZUZpbGwiLCAicGFyc2VGaWxsT3B0aW9uIiwgInBhcnNlRmxvYXQiLCAiZGVjb2RlVGFyZ2V0SW5kZXgiLCAiZmlyc3RDaCIsICJfZ2V0VGFyZ2V0UGl4ZWwiLCAiX2dldFRhcmdldFZhbHVlIiwgImZpbGxPcHRpb24iLCAiX2J1aWxkU3RhY2tMaW5lIiwgInNvdXJjZVBvaW50cyIsICJsaW5lc0JlbG93IiwgImdldExpbmVzQmVsb3ciLCAiYWRkUG9pbnRzQmVsb3ciLCAiYmVsb3ciLCAidW5zaGlmdCIsICJzb3VyY2VQb2ludCIsICJwb3N0cG9uZWQiLCAiZmluZFBvaW50IiwgInBvaW50VmFsdWUiLCAiZmlyc3RWYWx1ZSIsICJsYXN0VmFsdWUiLCAic2ltcGxlQXJjIiwgIl9nZXRUYXJnZXQiLCAiZ2V0TGluZUJ5SW5kZXgiLCAiY29tcHV0ZUJvdW5kYXJ5IiwgImNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5IiwgImNvbXB1dGVMaW5lYXJCb3VuZGFyeSIsICJfZHJhd2ZpbGwiLCAibGluZU9wdHMiLCAiYWJvdmUiLCAiZG9GaWxsIiwgImNsaXBWZXJ0aWNhbCIsICJjbGlwWSIsICJsaW5lTG9vcCIsICJzcmMiLCAibm90U2hhcGUiLCAiY2xpcEJvdW5kcyIsICJpbnRlcnBvbGF0ZWRMaW5lVG8iLCAidGFyZ2V0TG9vcCIsICJpbnRlcnBvbGF0ZWRQb2ludCIsICJhZnRlckRhdGFzZXRzVXBkYXRlIiwgIiRmaWxsZXIiLCAiYmVmb3JlRHJhdyIsICJkcmF3VGltZSIsICJiZWZvcmVEYXRhc2V0c0RyYXciLCAiYmVmb3JlRGF0YXNldERyYXciLCAiZ2V0Qm94U2l6ZSIsICJsYWJlbE9wdHMiLCAiYm94SGVpZ2h0IiwgImJveFdpZHRoIiwgInVzZVBvaW50U3R5bGUiLCAicG9pbnRTdHlsZVdpZHRoIiwgIml0ZW1IZWlnaHQiLCAiaXRlbXNFcXVhbCIsICJMZWdlbmQiLCAiX2FkZGVkIiwgImxlZ2VuZEhpdEJveGVzIiwgIl9ob3ZlcmVkSXRlbSIsICJkb3VnaG51dE1vZGUiLCAibGVnZW5kSXRlbXMiLCAiY29sdW1uU2l6ZXMiLCAibGluZVdpZHRocyIsICJidWlsZExhYmVscyIsICJsYWJlbEZvbnQiLCAiX2NvbXB1dGVUaXRsZUhlaWdodCIsICJfZml0Um93cyIsICJfZml0Q29scyIsICJoaXRib3hlcyIsICJ0b3RhbEhlaWdodCIsICJyb3ciLCAiaXRlbVdpZHRoIiwgIm1lYXN1cmVUZXh0IiwgIl9pdGVtSGVpZ2h0IiwgImhlaWdodExpbWl0IiwgInRvdGFsV2lkdGgiLCAiY3VycmVudENvbFdpZHRoIiwgImN1cnJlbnRDb2xIZWlnaHQiLCAiY29sIiwgImNhbGN1bGF0ZUl0ZW1TaXplIiwgImFkanVzdEhpdEJveGVzIiwgInJ0bCIsICJydGxIZWxwZXIiLCAiZ2V0UnRsQWRhcHRlciIsICJoaXRib3giLCAibGVmdEZvckx0ciIsICJfZHJhdyIsICJkZWZhdWx0Q29sb3IiLCAiaGFsZkZvbnRTaXplIiwgImN1cnNvciIsICJkcmF3TGVnZW5kQm94IiwgImxpbmVEYXNoIiwgImRyYXdPcHRpb25zIiwgIlNRUlQyIiwgInhQbHVzIiwgImRyYXdQb2ludExlZ2VuZCIsICJ5Qm94VG9wIiwgInhCb3hMZWZ0IiwgImZpbGxUZXh0IiwgInN0cmlrZXRocm91Z2giLCAib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwgInRleHREaXJlY3Rpb24iLCAidGV4dFdpZHRoIiwgInNldFdpZHRoIiwgInJlYWxYIiwgIl90ZXh0WCIsICJmb250TGluZUhlaWdodCIsICJjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0IiwgInJlc3RvcmVUZXh0RGlyZWN0aW9uIiwgInRpdGxlRm9udCIsICJ0aXRsZVBhZGRpbmciLCAidG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUiLCAiX2dldExlZ2VuZEl0ZW1BdCIsICJoaXRCb3giLCAibGgiLCAiaGFuZGxlRXZlbnQiLCAiaXNMaXN0ZW5lZCIsICJob3ZlcmVkSXRlbSIsICJzYW1lSXRlbSIsICJvbkxlYXZlIiwgImNhbGN1bGF0ZUl0ZW1XaWR0aCIsICJjYWxjdWxhdGVJdGVtSGVpZ2h0IiwgImxlZ2VuZEl0ZW1UZXh0IiwgIl9lbGVtZW50IiwgImFmdGVyRXZlbnQiLCAiY2kiLCAidXNlQm9yZGVyUmFkaXVzIiwgIlRpdGxlIiwgIl9wYWRkaW5nIiwgInRleHRTaXplIiwgIl9kcmF3QXJncyIsICJmb250T3B0cyIsICJjcmVhdGVUaXRsZSIsICJ0aXRsZUJsb2NrIiwgIldlYWtNYXAiLCAicG9zaXRpb25lcnMiLCAiYXZlcmFnZSIsICJ4U2V0IiwgInhBdmVyYWdlIiwgImV2ZW50UG9zaXRpb24iLCAibmVhcmVzdEVsZW1lbnQiLCAiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwgInRwIiwgInB1c2hPckNvbmNhdCIsICJ0b1B1c2giLCAiYXBwbHkiLCAic3BsaXROZXdsaW5lcyIsICJzdHIiLCAiU3RyaW5nIiwgImNyZWF0ZVRvb2x0aXBJdGVtIiwgImZvcm1hdHRlZFZhbHVlIiwgImdldFRvb2x0aXBTaXplIiwgInRvb2x0aXAiLCAiYm9keSIsICJmb290ZXIiLCAiYm9keUZvbnQiLCAiZm9vdGVyRm9udCIsICJ0aXRsZUxpbmVDb3VudCIsICJmb290ZXJMaW5lQ291bnQiLCAiYm9keUxpbmVJdGVtQ291bnQiLCAiY29tYmluZWRCb2R5TGVuZ3RoIiwgImJvZHlJdGVtIiwgImJlZm9yZSIsICJhZnRlciIsICJiZWZvcmVCb2R5IiwgImFmdGVyQm9keSIsICJ0aXRsZVNwYWNpbmciLCAidGl0bGVNYXJnaW5Cb3R0b20iLCAiYm9keUxpbmVIZWlnaHQiLCAiZGlzcGxheUNvbG9ycyIsICJib2R5U3BhY2luZyIsICJmb290ZXJNYXJnaW5Ub3AiLCAiZm9vdGVyU3BhY2luZyIsICJ3aWR0aFBhZGRpbmciLCAibWF4TGluZVdpZHRoIiwgImRldGVybWluZVlBbGlnbiIsICJkb2VzTm90Rml0V2l0aEFsaWduIiwgInhBbGlnbiIsICJjYXJldCIsICJjYXJldFNpemUiLCAiY2FyZXRQYWRkaW5nIiwgImRldGVybWluZVhBbGlnbiIsICJ5QWxpZ24iLCAiY2hhcnRXaWR0aCIsICJkZXRlcm1pbmVBbGlnbm1lbnQiLCAiYWxpZ25YIiwgImFsaWduWSIsICJwYWRkaW5nQW5kU2l6ZSIsICJnZXRCYWNrZ3JvdW5kUG9pbnQiLCAiYWxpZ25tZW50IiwgImNvcm5lclJhZGl1cyIsICJnZXRBbGlnbmVkWCIsICJnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyIsICJjcmVhdGVUb29sdGlwQ29udGV4dCIsICJ0b29sdGlwSXRlbXMiLCAib3ZlcnJpZGVDYWxsYmFja3MiLCAiZGVmYXVsdENhbGxiYWNrcyIsICJiZWZvcmVUaXRsZSIsICJub29wIiwgImxhYmVsQ291bnQiLCAiYWZ0ZXJUaXRsZSIsICJiZWZvcmVMYWJlbCIsICJ0b29sdGlwSXRlbSIsICJsYWJlbENvbG9yIiwgImxhYmVsVGV4dENvbG9yIiwgImJvZHlDb2xvciIsICJsYWJlbFBvaW50U3R5bGUiLCAiYWZ0ZXJMYWJlbCIsICJiZWZvcmVGb290ZXIiLCAiYWZ0ZXJGb290ZXIiLCAiaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2siLCAiVG9vbHRpcCIsICJvcGFjaXR5IiwgIl9ldmVudFBvc2l0aW9uIiwgIl9zaXplIiwgIl9jYWNoZWRBbmltYXRpb25zIiwgIl90b29sdGlwSXRlbXMiLCAiZGF0YVBvaW50cyIsICJjYXJldFgiLCAiY2FyZXRZIiwgImxhYmVsQ29sb3JzIiwgImxhYmVsUG9pbnRTdHlsZXMiLCAibGFiZWxUZXh0Q29sb3JzIiwgImdldFRpdGxlIiwgImdldEJlZm9yZUJvZHkiLCAiZ2V0Qm9keSIsICJib2R5SXRlbXMiLCAic2NvcGVkIiwgImdldEFmdGVyQm9keSIsICJnZXRGb290ZXIiLCAiX2NyZWF0ZUl0ZW1zIiwgIml0ZW1Tb3J0IiwgInBvc2l0aW9uQW5kU2l6ZSIsICJiYWNrZ3JvdW5kUG9pbnQiLCAiZXh0ZXJuYWwiLCAiZHJhd0NhcmV0IiwgInRvb2x0aXBQb2ludCIsICJjYXJldFBvc2l0aW9uIiwgImdldENhcmV0UG9zaXRpb24iLCAieDMiLCAieTMiLCAicHRYIiwgInB0WSIsICJwdCIsICJ0aXRsZUNvbG9yIiwgIl9kcmF3Q29sb3JCb3giLCAiY29sb3JYIiwgInJ0bENvbG9yWCIsICJ5T2ZmU2V0IiwgImNvbG9yWSIsICJtdWx0aUtleUJhY2tncm91bmQiLCAib3V0ZXJYIiwgImlubmVyWCIsICJzdHJva2VSZWN0IiwgImRyYXdCb2R5IiwgImJvZHlBbGlnbiIsICJ4TGluZVBhZGRpbmciLCAiZmlsbExpbmVPZlRleHQiLCAiYm9keUFsaWduRm9yQ2FsY3VsYXRpb24iLCAidGV4dENvbG9yIiwgImRyYXdGb290ZXIiLCAiZm9vdGVyQWxpZ24iLCAiZm9vdGVyQ29sb3IiLCAidG9vbHRpcFNpemUiLCAicXVhZHJhdGljQ3VydmVUbyIsICJfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0IiwgImFuaW1YIiwgImFuaW1ZIiwgIl93aWxsUmVuZGVyIiwgImhhc1Rvb2x0aXBDb250ZW50IiwgImdsb2JhbEFscGhhIiwgInBvc2l0aW9uQ2hhbmdlZCIsICJfcG9zaXRpb25DaGFuZ2VkIiwgIl9pZ25vcmVSZXBsYXlFdmVudHMiLCAiYWZ0ZXJJbml0IiwgImFmdGVyRHJhdyIsICJfZmFsbGJhY2siLCAiYWRkSWZTdHJpbmciLCAiYWRkZWRMYWJlbHMiLCAiZmluZE9yQWRkTGFiZWwiLCAibGFzdEluZGV4T2YiLCAiX2dldExhYmVsRm9yVmFsdWUiLCAiQ2F0ZWdvcnlTY2FsZSIsICJfc3RhcnRWYWx1ZSIsICJfdmFsdWVSYW5nZSIsICJfYWRkZWRMYWJlbHMiLCAiYWRkZWQiLCAiZ2VuZXJhdGVUaWNrcyIsICJnZW5lcmF0aW9uT3B0aW9ucyIsICJkYXRhUmFuZ2UiLCAiTUlOX1NQQUNJTkciLCAicHJlY2lzaW9uIiwgIm1heFRpY2tzIiwgIm1heERpZ2l0cyIsICJpbmNsdWRlQm91bmRzIiwgInVuaXQiLCAibWF4U3BhY2VzIiwgInJtaW4iLCAicm1heCIsICJjb3VudERlZmluZWQiLCAibWluU3BhY2luZyIsICJuaWNlTnVtIiwgIm5pY2VNaW4iLCAibmljZU1heCIsICJudW1TcGFjZXMiLCAiYWxtb3N0V2hvbGUiLCAiYWxtb3N0RXF1YWxzIiwgImRlY2ltYWxQbGFjZXMiLCAiX2RlY2ltYWxQbGFjZXMiLCAicmVsYXRpdmVMYWJlbFNpemUiLCAidGlja1ZhbHVlIiwgInJhZCIsICJMaW5lYXJTY2FsZUJhc2UiLCAiX2VuZFZhbHVlIiwgImhhbmRsZVRpY2tSYW5nZU9wdGlvbnMiLCAic2V0TWluIiwgInNldE1heCIsICJtaW5TaWduIiwgIm1heFNpZ24iLCAiZ2V0VGlja0xpbWl0IiwgInN0ZXBTaXplIiwgImNvbXB1dGVUaWNrTGltaXQiLCAibnVtZXJpY0dlbmVyYXRvck9wdGlvbnMiLCAiX3NldE1pbkFuZE1heEJ5S2V5IiwgIkxpbmVhclNjYWxlIiwgIlRpY2tzIiwgImZvcm1hdHRlcnMiLCAibnVtZXJpYyIsICJsb2cxMEZsb29yIiwgImxvZzEwIiwgImNoYW5nZUV4cG9uZW50IiwgIm0iLCAiaXNNYWpvciIsICJ0aWNrVmFsIiwgInN0ZXBzIiwgInJhbmdlRXhwIiwgInJhbmdlU3RlcCIsICJzdGFydEV4cCIsICJtaW5FeHAiLCAiZXhwIiwgInNpZ25pZmljYW5kIiwgImxhc3RUaWNrIiwgIkxvZ2FyaXRobWljU2NhbGUiLCAiX3plcm8iLCAibG9nYXJpdGhtaWMiLCAiZ2V0VGlja0JhY2tkcm9wSGVpZ2h0IiwgIm1lYXN1cmVMYWJlbFNpemUiLCAiX2xvbmdlc3RUZXh0IiwgImRldGVybWluZUxpbWl0cyIsICJmaXRXaXRoUG9pbnRMYWJlbHMiLCAibGltaXRzIiwgInZhbHVlQ291bnQiLCAiX3BvaW50TGFiZWxzIiwgInBvaW50TGFiZWxPcHRzIiwgImFkZGl0aW9uYWxBbmdsZSIsICJjZW50ZXJQb2ludExhYmVscyIsICJnZXRQb2ludExhYmVsQ29udGV4dCIsICJnZXRQb2ludFBvc2l0aW9uIiwgImRyYXdpbmdBcmVhIiwgInBsRm9udCIsICJoTGltaXRzIiwgInZMaW1pdHMiLCAidXBkYXRlTGltaXRzIiwgInNldENlbnRlclBvaW50IiwgIl9wb2ludExhYmVsSXRlbXMiLCAiYnVpbGRQb2ludExhYmVsSXRlbXMiLCAiY3JlYXRlUG9pbnRMYWJlbEl0ZW0iLCAiaXRlbU9wdHMiLCAib3V0ZXJEaXN0YW5jZSIsICJleHRyYSIsICJwb2ludExhYmVsUG9zaXRpb24iLCAieUZvckFuZ2xlIiwgImdldFRleHRBbGlnbkZvckFuZ2xlIiwgImxlZnRGb3JUZXh0QWxpZ24iLCAiaXNOb3RPdmVybGFwcGVkIiwgImFwZXhlc0luQXJlYSIsICJkcmF3UG9pbnRMYWJlbEJveCIsICJiYWNrZHJvcExlZnQiLCAiYmFja2Ryb3BUb3AiLCAiYmFja2Ryb3BXaWR0aCIsICJiYWNrZHJvcEhlaWdodCIsICJkcmF3UG9pbnRMYWJlbHMiLCAicGF0aFJhZGl1c0xpbmUiLCAiZHJhd1JhZGl1c0xpbmUiLCAiZ3JpZExpbmVPcHRzIiwgImNyZWF0ZVBvaW50TGFiZWxDb250ZXh0IiwgIlJhZGlhbExpbmVhclNjYWxlIiwgImxlZnRNb3ZlbWVudCIsICJyaWdodE1vdmVtZW50IiwgInRvcE1vdmVtZW50IiwgImJvdHRvbU1vdmVtZW50IiwgImFuZ2xlTXVsdGlwbGllciIsICJzY2FsaW5nRmFjdG9yIiwgImdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyIiwgInNjYWxlZERpc3RhbmNlIiwgInBvaW50TGFiZWwiLCAiZGlzdGFuY2VGcm9tQ2VudGVyIiwgImdldEJhc2VQb3NpdGlvbiIsICJnZXRQb2ludExhYmVsUG9zaXRpb24iLCAicm90YXRlIiwgImFuaW1hdGUiLCAiSU5URVJWQUxTIiwgIm1pbGxpc2Vjb25kIiwgImNvbW1vbiIsICJzZWNvbmQiLCAibWludXRlIiwgImhvdXIiLCAiZGF5IiwgIndlZWsiLCAibW9udGgiLCAicXVhcnRlciIsICJ5ZWFyIiwgIlVOSVRTIiwgInNvcnRlciIsICJpbnB1dCIsICJhZGFwdGVyIiwgIl9hZGFwdGVyIiwgInBhcnNlciIsICJpc29XZWVrZGF5IiwgIl9wYXJzZU9wdHMiLCAiZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyIsICJtaW5Vbml0IiwgImNhcGFjaXR5IiwgImludGVydmFsIiwgIk1BWF9TQUZFX0lOVEVHRVIiLCAiZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmciLCAiZGV0ZXJtaW5lTWFqb3JVbml0IiwgImFkZFRpY2siLCAidGltZSIsICJ0aW1lc3RhbXBzIiwgIl9sb29rdXAiLCAidGltZXN0YW1wIiwgInNldE1ham9yVGlja3MiLCAibWFqb3JVbml0IiwgInRpY2tzRnJvbVRpbWVzdGFtcHMiLCAiVGltZVNjYWxlIiwgIl91bml0IiwgIl9tYWpvclVuaXQiLCAiX29mZnNldHMiLCAiX25vcm1hbGl6ZWQiLCAiYWRhcHRlcnMiLCAiZGlzcGxheUZvcm1hdHMiLCAibm9ybWFsaXplZCIsICJfYXBwbHlCb3VuZHMiLCAiX2dldExhYmVsQm91bmRzIiwgImdldExhYmVsVGltZXN0YW1wcyIsICJ0aW1lT3B0cyIsICJfZ2VuZXJhdGUiLCAiX2ZpbHRlckJldHdlZW4iLCAiX2dldExhYmVsQ2FwYWNpdHkiLCAiaW5pdE9mZnNldHMiLCAib2Zmc2V0QWZ0ZXJBdXRvc2tpcCIsICJnZXREZWNpbWFsRm9yVmFsdWUiLCAibWlub3IiLCAid2Vla2RheSIsICJoYXNXZWVrZGF5IiwgImdldERhdGFUaW1lc3RhbXBzIiwgInRvb2x0aXBGb3JtYXQiLCAiZGF0ZXRpbWUiLCAiZm10IiwgIl90aWNrRm9ybWF0RnVuY3Rpb24iLCAiZm9ybWF0dGVyIiwgIm1pbm9yRm9ybWF0IiwgIm1ham9yRm9ybWF0IiwgIm9mZnNldHMiLCAiX2dldExhYmVsU2l6ZSIsICJ0aWNrc09wdHMiLCAidGlja0xhYmVsV2lkdGgiLCAiY29zUm90YXRpb24iLCAic2luUm90YXRpb24iLCAidGlja0ZvbnRTaXplIiwgImV4YW1wbGVUaW1lIiwgImV4YW1wbGVMYWJlbCIsICJub3JtYWxpemUiLCAidGFibGUiLCAicHJldlNvdXJjZSIsICJuZXh0U291cmNlIiwgInByZXZUYXJnZXQiLCAibmV4dFRhcmdldCIsICJzcGFuIiwgIlRpbWVTZXJpZXNTY2FsZSIsICJfdGFibGUiLCAiX21pblBvcyIsICJfdGFibGVSYW5nZSIsICJfZ2V0VGltZXN0YW1wc0ZvclRhYmxlIiwgImJ1aWxkTG9va3VwVGFibGUiLCAicmVnaXN0ZXJhYmxlcyJdCn0K
